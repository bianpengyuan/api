// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mcp/v1alpha1/mcp.proto

#ifndef PROTOBUF_mcp_2fv1alpha1_2fmcp_2eproto__INCLUDED
#define PROTOBUF_mcp_2fv1alpha1_2fmcp_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include "google/rpc/status.pb.h"
#include "gogoproto/gogo.pb.h"
#include "mcp/v1alpha1/resource.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_mcp_2fv1alpha1_2fmcp_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[10];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsSinkNode_AnnotationsEntry_DoNotUseImpl();
void InitDefaultsSinkNode_AnnotationsEntry_DoNotUse();
void InitDefaultsSinkNodeImpl();
void InitDefaultsSinkNode();
void InitDefaultsMeshConfigRequestImpl();
void InitDefaultsMeshConfigRequest();
void InitDefaultsMeshConfigResponseImpl();
void InitDefaultsMeshConfigResponse();
void InitDefaultsIncrementalMeshConfigRequest_InitialResourceVersionsEntry_DoNotUseImpl();
void InitDefaultsIncrementalMeshConfigRequest_InitialResourceVersionsEntry_DoNotUse();
void InitDefaultsIncrementalMeshConfigRequestImpl();
void InitDefaultsIncrementalMeshConfigRequest();
void InitDefaultsIncrementalMeshConfigResponseImpl();
void InitDefaultsIncrementalMeshConfigResponse();
void InitDefaultsRequestResources_InitialResourceVersionsEntry_DoNotUseImpl();
void InitDefaultsRequestResources_InitialResourceVersionsEntry_DoNotUse();
void InitDefaultsRequestResourcesImpl();
void InitDefaultsRequestResources();
void InitDefaultsResourcesImpl();
void InitDefaultsResources();
inline void InitDefaults() {
  InitDefaultsSinkNode_AnnotationsEntry_DoNotUse();
  InitDefaultsSinkNode();
  InitDefaultsMeshConfigRequest();
  InitDefaultsMeshConfigResponse();
  InitDefaultsIncrementalMeshConfigRequest_InitialResourceVersionsEntry_DoNotUse();
  InitDefaultsIncrementalMeshConfigRequest();
  InitDefaultsIncrementalMeshConfigResponse();
  InitDefaultsRequestResources_InitialResourceVersionsEntry_DoNotUse();
  InitDefaultsRequestResources();
  InitDefaultsResources();
}
}  // namespace protobuf_mcp_2fv1alpha1_2fmcp_2eproto
namespace istio {
namespace mcp {
namespace v1alpha1 {
class IncrementalMeshConfigRequest;
class IncrementalMeshConfigRequestDefaultTypeInternal;
extern IncrementalMeshConfigRequestDefaultTypeInternal _IncrementalMeshConfigRequest_default_instance_;
class IncrementalMeshConfigRequest_InitialResourceVersionsEntry_DoNotUse;
class IncrementalMeshConfigRequest_InitialResourceVersionsEntry_DoNotUseDefaultTypeInternal;
extern IncrementalMeshConfigRequest_InitialResourceVersionsEntry_DoNotUseDefaultTypeInternal _IncrementalMeshConfigRequest_InitialResourceVersionsEntry_DoNotUse_default_instance_;
class IncrementalMeshConfigResponse;
class IncrementalMeshConfigResponseDefaultTypeInternal;
extern IncrementalMeshConfigResponseDefaultTypeInternal _IncrementalMeshConfigResponse_default_instance_;
class MeshConfigRequest;
class MeshConfigRequestDefaultTypeInternal;
extern MeshConfigRequestDefaultTypeInternal _MeshConfigRequest_default_instance_;
class MeshConfigResponse;
class MeshConfigResponseDefaultTypeInternal;
extern MeshConfigResponseDefaultTypeInternal _MeshConfigResponse_default_instance_;
class RequestResources;
class RequestResourcesDefaultTypeInternal;
extern RequestResourcesDefaultTypeInternal _RequestResources_default_instance_;
class RequestResources_InitialResourceVersionsEntry_DoNotUse;
class RequestResources_InitialResourceVersionsEntry_DoNotUseDefaultTypeInternal;
extern RequestResources_InitialResourceVersionsEntry_DoNotUseDefaultTypeInternal _RequestResources_InitialResourceVersionsEntry_DoNotUse_default_instance_;
class Resources;
class ResourcesDefaultTypeInternal;
extern ResourcesDefaultTypeInternal _Resources_default_instance_;
class SinkNode;
class SinkNodeDefaultTypeInternal;
extern SinkNodeDefaultTypeInternal _SinkNode_default_instance_;
class SinkNode_AnnotationsEntry_DoNotUse;
class SinkNode_AnnotationsEntry_DoNotUseDefaultTypeInternal;
extern SinkNode_AnnotationsEntry_DoNotUseDefaultTypeInternal _SinkNode_AnnotationsEntry_DoNotUse_default_instance_;
}  // namespace v1alpha1
}  // namespace mcp
}  // namespace istio
namespace istio {
namespace mcp {
namespace v1alpha1 {

// ===================================================================

class SinkNode_AnnotationsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<SinkNode_AnnotationsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<SinkNode_AnnotationsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  SinkNode_AnnotationsEntry_DoNotUse();
  SinkNode_AnnotationsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const SinkNode_AnnotationsEntry_DoNotUse& other);
  static const SinkNode_AnnotationsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SinkNode_AnnotationsEntry_DoNotUse*>(&_SinkNode_AnnotationsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class SinkNode : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:istio.mcp.v1alpha1.SinkNode) */ {
 public:
  SinkNode();
  virtual ~SinkNode();

  SinkNode(const SinkNode& from);

  inline SinkNode& operator=(const SinkNode& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SinkNode(SinkNode&& from) noexcept
    : SinkNode() {
    *this = ::std::move(from);
  }

  inline SinkNode& operator=(SinkNode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SinkNode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SinkNode* internal_default_instance() {
    return reinterpret_cast<const SinkNode*>(
               &_SinkNode_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(SinkNode* other);
  friend void swap(SinkNode& a, SinkNode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SinkNode* New() const PROTOBUF_FINAL { return New(NULL); }

  SinkNode* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SinkNode& from);
  void MergeFrom(const SinkNode& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SinkNode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> annotations = 2;
  int annotations_size() const;
  void clear_annotations();
  static const int kAnnotationsFieldNumber = 2;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      annotations() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_annotations();

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:istio.mcp.v1alpha1.SinkNode)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      SinkNode_AnnotationsEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > annotations_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  mutable int _cached_size_;
  friend struct ::protobuf_mcp_2fv1alpha1_2fmcp_2eproto::TableStruct;
  friend void ::protobuf_mcp_2fv1alpha1_2fmcp_2eproto::InitDefaultsSinkNodeImpl();
};
// -------------------------------------------------------------------

class MeshConfigRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:istio.mcp.v1alpha1.MeshConfigRequest) */ {
 public:
  MeshConfigRequest();
  virtual ~MeshConfigRequest();

  MeshConfigRequest(const MeshConfigRequest& from);

  inline MeshConfigRequest& operator=(const MeshConfigRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MeshConfigRequest(MeshConfigRequest&& from) noexcept
    : MeshConfigRequest() {
    *this = ::std::move(from);
  }

  inline MeshConfigRequest& operator=(MeshConfigRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MeshConfigRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MeshConfigRequest* internal_default_instance() {
    return reinterpret_cast<const MeshConfigRequest*>(
               &_MeshConfigRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(MeshConfigRequest* other);
  friend void swap(MeshConfigRequest& a, MeshConfigRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MeshConfigRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  MeshConfigRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MeshConfigRequest& from);
  void MergeFrom(const MeshConfigRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MeshConfigRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string version_info = 1;
  void clear_version_info();
  static const int kVersionInfoFieldNumber = 1;
  const ::std::string& version_info() const;
  void set_version_info(const ::std::string& value);
  #if LANG_CXX11
  void set_version_info(::std::string&& value);
  #endif
  void set_version_info(const char* value);
  void set_version_info(const char* value, size_t size);
  ::std::string* mutable_version_info();
  ::std::string* release_version_info();
  void set_allocated_version_info(::std::string* version_info);

  // string type_url = 3;
  void clear_type_url();
  static const int kTypeUrlFieldNumber = 3;
  const ::std::string& type_url() const;
  void set_type_url(const ::std::string& value);
  #if LANG_CXX11
  void set_type_url(::std::string&& value);
  #endif
  void set_type_url(const char* value);
  void set_type_url(const char* value, size_t size);
  ::std::string* mutable_type_url();
  ::std::string* release_type_url();
  void set_allocated_type_url(::std::string* type_url);

  // string response_nonce = 4;
  void clear_response_nonce();
  static const int kResponseNonceFieldNumber = 4;
  const ::std::string& response_nonce() const;
  void set_response_nonce(const ::std::string& value);
  #if LANG_CXX11
  void set_response_nonce(::std::string&& value);
  #endif
  void set_response_nonce(const char* value);
  void set_response_nonce(const char* value, size_t size);
  ::std::string* mutable_response_nonce();
  ::std::string* release_response_nonce();
  void set_allocated_response_nonce(::std::string* response_nonce);

  // .istio.mcp.v1alpha1.SinkNode sink_node = 2;
  bool has_sink_node() const;
  void clear_sink_node();
  static const int kSinkNodeFieldNumber = 2;
  const ::istio::mcp::v1alpha1::SinkNode& sink_node() const;
  ::istio::mcp::v1alpha1::SinkNode* release_sink_node();
  ::istio::mcp::v1alpha1::SinkNode* mutable_sink_node();
  void set_allocated_sink_node(::istio::mcp::v1alpha1::SinkNode* sink_node);

  // .google.rpc.Status error_detail = 5;
  bool has_error_detail() const;
  void clear_error_detail();
  static const int kErrorDetailFieldNumber = 5;
  const ::google::rpc::Status& error_detail() const;
  ::google::rpc::Status* release_error_detail();
  ::google::rpc::Status* mutable_error_detail();
  void set_allocated_error_detail(::google::rpc::Status* error_detail);

  // @@protoc_insertion_point(class_scope:istio.mcp.v1alpha1.MeshConfigRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr version_info_;
  ::google::protobuf::internal::ArenaStringPtr type_url_;
  ::google::protobuf::internal::ArenaStringPtr response_nonce_;
  ::istio::mcp::v1alpha1::SinkNode* sink_node_;
  ::google::rpc::Status* error_detail_;
  mutable int _cached_size_;
  friend struct ::protobuf_mcp_2fv1alpha1_2fmcp_2eproto::TableStruct;
  friend void ::protobuf_mcp_2fv1alpha1_2fmcp_2eproto::InitDefaultsMeshConfigRequestImpl();
};
// -------------------------------------------------------------------

class MeshConfigResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:istio.mcp.v1alpha1.MeshConfigResponse) */ {
 public:
  MeshConfigResponse();
  virtual ~MeshConfigResponse();

  MeshConfigResponse(const MeshConfigResponse& from);

  inline MeshConfigResponse& operator=(const MeshConfigResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MeshConfigResponse(MeshConfigResponse&& from) noexcept
    : MeshConfigResponse() {
    *this = ::std::move(from);
  }

  inline MeshConfigResponse& operator=(MeshConfigResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MeshConfigResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MeshConfigResponse* internal_default_instance() {
    return reinterpret_cast<const MeshConfigResponse*>(
               &_MeshConfigResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(MeshConfigResponse* other);
  friend void swap(MeshConfigResponse& a, MeshConfigResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MeshConfigResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  MeshConfigResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MeshConfigResponse& from);
  void MergeFrom(const MeshConfigResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MeshConfigResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .istio.mcp.v1alpha1.Resource resources = 2 [(.gogoproto.nullable) = false];
  int resources_size() const;
  void clear_resources();
  static const int kResourcesFieldNumber = 2;
  const ::istio::mcp::v1alpha1::Resource& resources(int index) const;
  ::istio::mcp::v1alpha1::Resource* mutable_resources(int index);
  ::istio::mcp::v1alpha1::Resource* add_resources();
  ::google::protobuf::RepeatedPtrField< ::istio::mcp::v1alpha1::Resource >*
      mutable_resources();
  const ::google::protobuf::RepeatedPtrField< ::istio::mcp::v1alpha1::Resource >&
      resources() const;

  // string version_info = 1;
  void clear_version_info();
  static const int kVersionInfoFieldNumber = 1;
  const ::std::string& version_info() const;
  void set_version_info(const ::std::string& value);
  #if LANG_CXX11
  void set_version_info(::std::string&& value);
  #endif
  void set_version_info(const char* value);
  void set_version_info(const char* value, size_t size);
  ::std::string* mutable_version_info();
  ::std::string* release_version_info();
  void set_allocated_version_info(::std::string* version_info);

  // string type_url = 3;
  void clear_type_url();
  static const int kTypeUrlFieldNumber = 3;
  const ::std::string& type_url() const;
  void set_type_url(const ::std::string& value);
  #if LANG_CXX11
  void set_type_url(::std::string&& value);
  #endif
  void set_type_url(const char* value);
  void set_type_url(const char* value, size_t size);
  ::std::string* mutable_type_url();
  ::std::string* release_type_url();
  void set_allocated_type_url(::std::string* type_url);

  // string nonce = 4;
  void clear_nonce();
  static const int kNonceFieldNumber = 4;
  const ::std::string& nonce() const;
  void set_nonce(const ::std::string& value);
  #if LANG_CXX11
  void set_nonce(::std::string&& value);
  #endif
  void set_nonce(const char* value);
  void set_nonce(const char* value, size_t size);
  ::std::string* mutable_nonce();
  ::std::string* release_nonce();
  void set_allocated_nonce(::std::string* nonce);

  // @@protoc_insertion_point(class_scope:istio.mcp.v1alpha1.MeshConfigResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::istio::mcp::v1alpha1::Resource > resources_;
  ::google::protobuf::internal::ArenaStringPtr version_info_;
  ::google::protobuf::internal::ArenaStringPtr type_url_;
  ::google::protobuf::internal::ArenaStringPtr nonce_;
  mutable int _cached_size_;
  friend struct ::protobuf_mcp_2fv1alpha1_2fmcp_2eproto::TableStruct;
  friend void ::protobuf_mcp_2fv1alpha1_2fmcp_2eproto::InitDefaultsMeshConfigResponseImpl();
};
// -------------------------------------------------------------------

class IncrementalMeshConfigRequest_InitialResourceVersionsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<IncrementalMeshConfigRequest_InitialResourceVersionsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<IncrementalMeshConfigRequest_InitialResourceVersionsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  IncrementalMeshConfigRequest_InitialResourceVersionsEntry_DoNotUse();
  IncrementalMeshConfigRequest_InitialResourceVersionsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const IncrementalMeshConfigRequest_InitialResourceVersionsEntry_DoNotUse& other);
  static const IncrementalMeshConfigRequest_InitialResourceVersionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const IncrementalMeshConfigRequest_InitialResourceVersionsEntry_DoNotUse*>(&_IncrementalMeshConfigRequest_InitialResourceVersionsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class IncrementalMeshConfigRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:istio.mcp.v1alpha1.IncrementalMeshConfigRequest) */ {
 public:
  IncrementalMeshConfigRequest();
  virtual ~IncrementalMeshConfigRequest();

  IncrementalMeshConfigRequest(const IncrementalMeshConfigRequest& from);

  inline IncrementalMeshConfigRequest& operator=(const IncrementalMeshConfigRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IncrementalMeshConfigRequest(IncrementalMeshConfigRequest&& from) noexcept
    : IncrementalMeshConfigRequest() {
    *this = ::std::move(from);
  }

  inline IncrementalMeshConfigRequest& operator=(IncrementalMeshConfigRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const IncrementalMeshConfigRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IncrementalMeshConfigRequest* internal_default_instance() {
    return reinterpret_cast<const IncrementalMeshConfigRequest*>(
               &_IncrementalMeshConfigRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(IncrementalMeshConfigRequest* other);
  friend void swap(IncrementalMeshConfigRequest& a, IncrementalMeshConfigRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IncrementalMeshConfigRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  IncrementalMeshConfigRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const IncrementalMeshConfigRequest& from);
  void MergeFrom(const IncrementalMeshConfigRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(IncrementalMeshConfigRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> initial_resource_versions = 3;
  int initial_resource_versions_size() const;
  void clear_initial_resource_versions();
  static const int kInitialResourceVersionsFieldNumber = 3;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      initial_resource_versions() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_initial_resource_versions();

  // string type_url = 2;
  void clear_type_url();
  static const int kTypeUrlFieldNumber = 2;
  const ::std::string& type_url() const;
  void set_type_url(const ::std::string& value);
  #if LANG_CXX11
  void set_type_url(::std::string&& value);
  #endif
  void set_type_url(const char* value);
  void set_type_url(const char* value, size_t size);
  ::std::string* mutable_type_url();
  ::std::string* release_type_url();
  void set_allocated_type_url(::std::string* type_url);

  // string response_nonce = 4;
  void clear_response_nonce();
  static const int kResponseNonceFieldNumber = 4;
  const ::std::string& response_nonce() const;
  void set_response_nonce(const ::std::string& value);
  #if LANG_CXX11
  void set_response_nonce(::std::string&& value);
  #endif
  void set_response_nonce(const char* value);
  void set_response_nonce(const char* value, size_t size);
  ::std::string* mutable_response_nonce();
  ::std::string* release_response_nonce();
  void set_allocated_response_nonce(::std::string* response_nonce);

  // .istio.mcp.v1alpha1.SinkNode sink_node = 1;
  bool has_sink_node() const;
  void clear_sink_node();
  static const int kSinkNodeFieldNumber = 1;
  const ::istio::mcp::v1alpha1::SinkNode& sink_node() const;
  ::istio::mcp::v1alpha1::SinkNode* release_sink_node();
  ::istio::mcp::v1alpha1::SinkNode* mutable_sink_node();
  void set_allocated_sink_node(::istio::mcp::v1alpha1::SinkNode* sink_node);

  // .google.rpc.Status error_detail = 5;
  bool has_error_detail() const;
  void clear_error_detail();
  static const int kErrorDetailFieldNumber = 5;
  const ::google::rpc::Status& error_detail() const;
  ::google::rpc::Status* release_error_detail();
  ::google::rpc::Status* mutable_error_detail();
  void set_allocated_error_detail(::google::rpc::Status* error_detail);

  // @@protoc_insertion_point(class_scope:istio.mcp.v1alpha1.IncrementalMeshConfigRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      IncrementalMeshConfigRequest_InitialResourceVersionsEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > initial_resource_versions_;
  ::google::protobuf::internal::ArenaStringPtr type_url_;
  ::google::protobuf::internal::ArenaStringPtr response_nonce_;
  ::istio::mcp::v1alpha1::SinkNode* sink_node_;
  ::google::rpc::Status* error_detail_;
  mutable int _cached_size_;
  friend struct ::protobuf_mcp_2fv1alpha1_2fmcp_2eproto::TableStruct;
  friend void ::protobuf_mcp_2fv1alpha1_2fmcp_2eproto::InitDefaultsIncrementalMeshConfigRequestImpl();
};
// -------------------------------------------------------------------

class IncrementalMeshConfigResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:istio.mcp.v1alpha1.IncrementalMeshConfigResponse) */ {
 public:
  IncrementalMeshConfigResponse();
  virtual ~IncrementalMeshConfigResponse();

  IncrementalMeshConfigResponse(const IncrementalMeshConfigResponse& from);

  inline IncrementalMeshConfigResponse& operator=(const IncrementalMeshConfigResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IncrementalMeshConfigResponse(IncrementalMeshConfigResponse&& from) noexcept
    : IncrementalMeshConfigResponse() {
    *this = ::std::move(from);
  }

  inline IncrementalMeshConfigResponse& operator=(IncrementalMeshConfigResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const IncrementalMeshConfigResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IncrementalMeshConfigResponse* internal_default_instance() {
    return reinterpret_cast<const IncrementalMeshConfigResponse*>(
               &_IncrementalMeshConfigResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(IncrementalMeshConfigResponse* other);
  friend void swap(IncrementalMeshConfigResponse& a, IncrementalMeshConfigResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IncrementalMeshConfigResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  IncrementalMeshConfigResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const IncrementalMeshConfigResponse& from);
  void MergeFrom(const IncrementalMeshConfigResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(IncrementalMeshConfigResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .istio.mcp.v1alpha1.Resource resources = 2 [(.gogoproto.nullable) = false];
  int resources_size() const;
  void clear_resources();
  static const int kResourcesFieldNumber = 2;
  const ::istio::mcp::v1alpha1::Resource& resources(int index) const;
  ::istio::mcp::v1alpha1::Resource* mutable_resources(int index);
  ::istio::mcp::v1alpha1::Resource* add_resources();
  ::google::protobuf::RepeatedPtrField< ::istio::mcp::v1alpha1::Resource >*
      mutable_resources();
  const ::google::protobuf::RepeatedPtrField< ::istio::mcp::v1alpha1::Resource >&
      resources() const;

  // repeated string removed_resources = 3;
  int removed_resources_size() const;
  void clear_removed_resources();
  static const int kRemovedResourcesFieldNumber = 3;
  const ::std::string& removed_resources(int index) const;
  ::std::string* mutable_removed_resources(int index);
  void set_removed_resources(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_removed_resources(int index, ::std::string&& value);
  #endif
  void set_removed_resources(int index, const char* value);
  void set_removed_resources(int index, const char* value, size_t size);
  ::std::string* add_removed_resources();
  void add_removed_resources(const ::std::string& value);
  #if LANG_CXX11
  void add_removed_resources(::std::string&& value);
  #endif
  void add_removed_resources(const char* value);
  void add_removed_resources(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& removed_resources() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_removed_resources();

  // string system_version_info = 1;
  void clear_system_version_info();
  static const int kSystemVersionInfoFieldNumber = 1;
  const ::std::string& system_version_info() const;
  void set_system_version_info(const ::std::string& value);
  #if LANG_CXX11
  void set_system_version_info(::std::string&& value);
  #endif
  void set_system_version_info(const char* value);
  void set_system_version_info(const char* value, size_t size);
  ::std::string* mutable_system_version_info();
  ::std::string* release_system_version_info();
  void set_allocated_system_version_info(::std::string* system_version_info);

  // string nonce = 4;
  void clear_nonce();
  static const int kNonceFieldNumber = 4;
  const ::std::string& nonce() const;
  void set_nonce(const ::std::string& value);
  #if LANG_CXX11
  void set_nonce(::std::string&& value);
  #endif
  void set_nonce(const char* value);
  void set_nonce(const char* value, size_t size);
  ::std::string* mutable_nonce();
  ::std::string* release_nonce();
  void set_allocated_nonce(::std::string* nonce);

  // @@protoc_insertion_point(class_scope:istio.mcp.v1alpha1.IncrementalMeshConfigResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::istio::mcp::v1alpha1::Resource > resources_;
  ::google::protobuf::RepeatedPtrField< ::std::string> removed_resources_;
  ::google::protobuf::internal::ArenaStringPtr system_version_info_;
  ::google::protobuf::internal::ArenaStringPtr nonce_;
  mutable int _cached_size_;
  friend struct ::protobuf_mcp_2fv1alpha1_2fmcp_2eproto::TableStruct;
  friend void ::protobuf_mcp_2fv1alpha1_2fmcp_2eproto::InitDefaultsIncrementalMeshConfigResponseImpl();
};
// -------------------------------------------------------------------

class RequestResources_InitialResourceVersionsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<RequestResources_InitialResourceVersionsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<RequestResources_InitialResourceVersionsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  RequestResources_InitialResourceVersionsEntry_DoNotUse();
  RequestResources_InitialResourceVersionsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const RequestResources_InitialResourceVersionsEntry_DoNotUse& other);
  static const RequestResources_InitialResourceVersionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const RequestResources_InitialResourceVersionsEntry_DoNotUse*>(&_RequestResources_InitialResourceVersionsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class RequestResources : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:istio.mcp.v1alpha1.RequestResources) */ {
 public:
  RequestResources();
  virtual ~RequestResources();

  RequestResources(const RequestResources& from);

  inline RequestResources& operator=(const RequestResources& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestResources(RequestResources&& from) noexcept
    : RequestResources() {
    *this = ::std::move(from);
  }

  inline RequestResources& operator=(RequestResources&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestResources& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestResources* internal_default_instance() {
    return reinterpret_cast<const RequestResources*>(
               &_RequestResources_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(RequestResources* other);
  friend void swap(RequestResources& a, RequestResources& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestResources* New() const PROTOBUF_FINAL { return New(NULL); }

  RequestResources* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RequestResources& from);
  void MergeFrom(const RequestResources& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RequestResources* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> initial_resource_versions = 3;
  int initial_resource_versions_size() const;
  void clear_initial_resource_versions();
  static const int kInitialResourceVersionsFieldNumber = 3;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      initial_resource_versions() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_initial_resource_versions();

  // string collection = 2;
  void clear_collection();
  static const int kCollectionFieldNumber = 2;
  const ::std::string& collection() const;
  void set_collection(const ::std::string& value);
  #if LANG_CXX11
  void set_collection(::std::string&& value);
  #endif
  void set_collection(const char* value);
  void set_collection(const char* value, size_t size);
  ::std::string* mutable_collection();
  ::std::string* release_collection();
  void set_allocated_collection(::std::string* collection);

  // string response_nonce = 4;
  void clear_response_nonce();
  static const int kResponseNonceFieldNumber = 4;
  const ::std::string& response_nonce() const;
  void set_response_nonce(const ::std::string& value);
  #if LANG_CXX11
  void set_response_nonce(::std::string&& value);
  #endif
  void set_response_nonce(const char* value);
  void set_response_nonce(const char* value, size_t size);
  ::std::string* mutable_response_nonce();
  ::std::string* release_response_nonce();
  void set_allocated_response_nonce(::std::string* response_nonce);

  // .istio.mcp.v1alpha1.SinkNode sink_node = 1;
  bool has_sink_node() const;
  void clear_sink_node();
  static const int kSinkNodeFieldNumber = 1;
  const ::istio::mcp::v1alpha1::SinkNode& sink_node() const;
  ::istio::mcp::v1alpha1::SinkNode* release_sink_node();
  ::istio::mcp::v1alpha1::SinkNode* mutable_sink_node();
  void set_allocated_sink_node(::istio::mcp::v1alpha1::SinkNode* sink_node);

  // .google.rpc.Status error_detail = 5;
  bool has_error_detail() const;
  void clear_error_detail();
  static const int kErrorDetailFieldNumber = 5;
  const ::google::rpc::Status& error_detail() const;
  ::google::rpc::Status* release_error_detail();
  ::google::rpc::Status* mutable_error_detail();
  void set_allocated_error_detail(::google::rpc::Status* error_detail);

  // bool incremental = 6;
  void clear_incremental();
  static const int kIncrementalFieldNumber = 6;
  bool incremental() const;
  void set_incremental(bool value);

  // @@protoc_insertion_point(class_scope:istio.mcp.v1alpha1.RequestResources)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      RequestResources_InitialResourceVersionsEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > initial_resource_versions_;
  ::google::protobuf::internal::ArenaStringPtr collection_;
  ::google::protobuf::internal::ArenaStringPtr response_nonce_;
  ::istio::mcp::v1alpha1::SinkNode* sink_node_;
  ::google::rpc::Status* error_detail_;
  bool incremental_;
  mutable int _cached_size_;
  friend struct ::protobuf_mcp_2fv1alpha1_2fmcp_2eproto::TableStruct;
  friend void ::protobuf_mcp_2fv1alpha1_2fmcp_2eproto::InitDefaultsRequestResourcesImpl();
};
// -------------------------------------------------------------------

class Resources : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:istio.mcp.v1alpha1.Resources) */ {
 public:
  Resources();
  virtual ~Resources();

  Resources(const Resources& from);

  inline Resources& operator=(const Resources& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Resources(Resources&& from) noexcept
    : Resources() {
    *this = ::std::move(from);
  }

  inline Resources& operator=(Resources&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Resources& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Resources* internal_default_instance() {
    return reinterpret_cast<const Resources*>(
               &_Resources_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(Resources* other);
  friend void swap(Resources& a, Resources& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Resources* New() const PROTOBUF_FINAL { return New(NULL); }

  Resources* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Resources& from);
  void MergeFrom(const Resources& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Resources* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .istio.mcp.v1alpha1.Resource resources = 3 [(.gogoproto.nullable) = false];
  int resources_size() const;
  void clear_resources();
  static const int kResourcesFieldNumber = 3;
  const ::istio::mcp::v1alpha1::Resource& resources(int index) const;
  ::istio::mcp::v1alpha1::Resource* mutable_resources(int index);
  ::istio::mcp::v1alpha1::Resource* add_resources();
  ::google::protobuf::RepeatedPtrField< ::istio::mcp::v1alpha1::Resource >*
      mutable_resources();
  const ::google::protobuf::RepeatedPtrField< ::istio::mcp::v1alpha1::Resource >&
      resources() const;

  // repeated string removed_resources = 4;
  int removed_resources_size() const;
  void clear_removed_resources();
  static const int kRemovedResourcesFieldNumber = 4;
  const ::std::string& removed_resources(int index) const;
  ::std::string* mutable_removed_resources(int index);
  void set_removed_resources(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_removed_resources(int index, ::std::string&& value);
  #endif
  void set_removed_resources(int index, const char* value);
  void set_removed_resources(int index, const char* value, size_t size);
  ::std::string* add_removed_resources();
  void add_removed_resources(const ::std::string& value);
  #if LANG_CXX11
  void add_removed_resources(::std::string&& value);
  #endif
  void add_removed_resources(const char* value);
  void add_removed_resources(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& removed_resources() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_removed_resources();

  // string system_version_info = 1;
  void clear_system_version_info();
  static const int kSystemVersionInfoFieldNumber = 1;
  const ::std::string& system_version_info() const;
  void set_system_version_info(const ::std::string& value);
  #if LANG_CXX11
  void set_system_version_info(::std::string&& value);
  #endif
  void set_system_version_info(const char* value);
  void set_system_version_info(const char* value, size_t size);
  ::std::string* mutable_system_version_info();
  ::std::string* release_system_version_info();
  void set_allocated_system_version_info(::std::string* system_version_info);

  // string collection = 2;
  void clear_collection();
  static const int kCollectionFieldNumber = 2;
  const ::std::string& collection() const;
  void set_collection(const ::std::string& value);
  #if LANG_CXX11
  void set_collection(::std::string&& value);
  #endif
  void set_collection(const char* value);
  void set_collection(const char* value, size_t size);
  ::std::string* mutable_collection();
  ::std::string* release_collection();
  void set_allocated_collection(::std::string* collection);

  // string nonce = 5;
  void clear_nonce();
  static const int kNonceFieldNumber = 5;
  const ::std::string& nonce() const;
  void set_nonce(const ::std::string& value);
  #if LANG_CXX11
  void set_nonce(::std::string&& value);
  #endif
  void set_nonce(const char* value);
  void set_nonce(const char* value, size_t size);
  ::std::string* mutable_nonce();
  ::std::string* release_nonce();
  void set_allocated_nonce(::std::string* nonce);

  // bool incremental = 6;
  void clear_incremental();
  static const int kIncrementalFieldNumber = 6;
  bool incremental() const;
  void set_incremental(bool value);

  // @@protoc_insertion_point(class_scope:istio.mcp.v1alpha1.Resources)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::istio::mcp::v1alpha1::Resource > resources_;
  ::google::protobuf::RepeatedPtrField< ::std::string> removed_resources_;
  ::google::protobuf::internal::ArenaStringPtr system_version_info_;
  ::google::protobuf::internal::ArenaStringPtr collection_;
  ::google::protobuf::internal::ArenaStringPtr nonce_;
  bool incremental_;
  mutable int _cached_size_;
  friend struct ::protobuf_mcp_2fv1alpha1_2fmcp_2eproto::TableStruct;
  friend void ::protobuf_mcp_2fv1alpha1_2fmcp_2eproto::InitDefaultsResourcesImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// SinkNode

// string id = 1;
inline void SinkNode::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SinkNode::id() const {
  // @@protoc_insertion_point(field_get:istio.mcp.v1alpha1.SinkNode.id)
  return id_.GetNoArena();
}
inline void SinkNode::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.mcp.v1alpha1.SinkNode.id)
}
#if LANG_CXX11
inline void SinkNode::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.mcp.v1alpha1.SinkNode.id)
}
#endif
inline void SinkNode::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.mcp.v1alpha1.SinkNode.id)
}
inline void SinkNode::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.mcp.v1alpha1.SinkNode.id)
}
inline ::std::string* SinkNode::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:istio.mcp.v1alpha1.SinkNode.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SinkNode::release_id() {
  // @@protoc_insertion_point(field_release:istio.mcp.v1alpha1.SinkNode.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SinkNode::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:istio.mcp.v1alpha1.SinkNode.id)
}

// map<string, string> annotations = 2;
inline int SinkNode::annotations_size() const {
  return annotations_.size();
}
inline void SinkNode::clear_annotations() {
  annotations_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
SinkNode::annotations() const {
  // @@protoc_insertion_point(field_map:istio.mcp.v1alpha1.SinkNode.annotations)
  return annotations_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
SinkNode::mutable_annotations() {
  // @@protoc_insertion_point(field_mutable_map:istio.mcp.v1alpha1.SinkNode.annotations)
  return annotations_.MutableMap();
}

// -------------------------------------------------------------------

// MeshConfigRequest

// string version_info = 1;
inline void MeshConfigRequest::clear_version_info() {
  version_info_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MeshConfigRequest::version_info() const {
  // @@protoc_insertion_point(field_get:istio.mcp.v1alpha1.MeshConfigRequest.version_info)
  return version_info_.GetNoArena();
}
inline void MeshConfigRequest::set_version_info(const ::std::string& value) {
  
  version_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.mcp.v1alpha1.MeshConfigRequest.version_info)
}
#if LANG_CXX11
inline void MeshConfigRequest::set_version_info(::std::string&& value) {
  
  version_info_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.mcp.v1alpha1.MeshConfigRequest.version_info)
}
#endif
inline void MeshConfigRequest::set_version_info(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.mcp.v1alpha1.MeshConfigRequest.version_info)
}
inline void MeshConfigRequest::set_version_info(const char* value, size_t size) {
  
  version_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.mcp.v1alpha1.MeshConfigRequest.version_info)
}
inline ::std::string* MeshConfigRequest::mutable_version_info() {
  
  // @@protoc_insertion_point(field_mutable:istio.mcp.v1alpha1.MeshConfigRequest.version_info)
  return version_info_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MeshConfigRequest::release_version_info() {
  // @@protoc_insertion_point(field_release:istio.mcp.v1alpha1.MeshConfigRequest.version_info)
  
  return version_info_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MeshConfigRequest::set_allocated_version_info(::std::string* version_info) {
  if (version_info != NULL) {
    
  } else {
    
  }
  version_info_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version_info);
  // @@protoc_insertion_point(field_set_allocated:istio.mcp.v1alpha1.MeshConfigRequest.version_info)
}

// .istio.mcp.v1alpha1.SinkNode sink_node = 2;
inline bool MeshConfigRequest::has_sink_node() const {
  return this != internal_default_instance() && sink_node_ != NULL;
}
inline void MeshConfigRequest::clear_sink_node() {
  if (GetArenaNoVirtual() == NULL && sink_node_ != NULL) {
    delete sink_node_;
  }
  sink_node_ = NULL;
}
inline const ::istio::mcp::v1alpha1::SinkNode& MeshConfigRequest::sink_node() const {
  const ::istio::mcp::v1alpha1::SinkNode* p = sink_node_;
  // @@protoc_insertion_point(field_get:istio.mcp.v1alpha1.MeshConfigRequest.sink_node)
  return p != NULL ? *p : *reinterpret_cast<const ::istio::mcp::v1alpha1::SinkNode*>(
      &::istio::mcp::v1alpha1::_SinkNode_default_instance_);
}
inline ::istio::mcp::v1alpha1::SinkNode* MeshConfigRequest::release_sink_node() {
  // @@protoc_insertion_point(field_release:istio.mcp.v1alpha1.MeshConfigRequest.sink_node)
  
  ::istio::mcp::v1alpha1::SinkNode* temp = sink_node_;
  sink_node_ = NULL;
  return temp;
}
inline ::istio::mcp::v1alpha1::SinkNode* MeshConfigRequest::mutable_sink_node() {
  
  if (sink_node_ == NULL) {
    sink_node_ = new ::istio::mcp::v1alpha1::SinkNode;
  }
  // @@protoc_insertion_point(field_mutable:istio.mcp.v1alpha1.MeshConfigRequest.sink_node)
  return sink_node_;
}
inline void MeshConfigRequest::set_allocated_sink_node(::istio::mcp::v1alpha1::SinkNode* sink_node) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sink_node_;
  }
  if (sink_node) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sink_node = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sink_node, submessage_arena);
    }
    
  } else {
    
  }
  sink_node_ = sink_node;
  // @@protoc_insertion_point(field_set_allocated:istio.mcp.v1alpha1.MeshConfigRequest.sink_node)
}

// string type_url = 3;
inline void MeshConfigRequest::clear_type_url() {
  type_url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MeshConfigRequest::type_url() const {
  // @@protoc_insertion_point(field_get:istio.mcp.v1alpha1.MeshConfigRequest.type_url)
  return type_url_.GetNoArena();
}
inline void MeshConfigRequest::set_type_url(const ::std::string& value) {
  
  type_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.mcp.v1alpha1.MeshConfigRequest.type_url)
}
#if LANG_CXX11
inline void MeshConfigRequest::set_type_url(::std::string&& value) {
  
  type_url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.mcp.v1alpha1.MeshConfigRequest.type_url)
}
#endif
inline void MeshConfigRequest::set_type_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.mcp.v1alpha1.MeshConfigRequest.type_url)
}
inline void MeshConfigRequest::set_type_url(const char* value, size_t size) {
  
  type_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.mcp.v1alpha1.MeshConfigRequest.type_url)
}
inline ::std::string* MeshConfigRequest::mutable_type_url() {
  
  // @@protoc_insertion_point(field_mutable:istio.mcp.v1alpha1.MeshConfigRequest.type_url)
  return type_url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MeshConfigRequest::release_type_url() {
  // @@protoc_insertion_point(field_release:istio.mcp.v1alpha1.MeshConfigRequest.type_url)
  
  return type_url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MeshConfigRequest::set_allocated_type_url(::std::string* type_url) {
  if (type_url != NULL) {
    
  } else {
    
  }
  type_url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type_url);
  // @@protoc_insertion_point(field_set_allocated:istio.mcp.v1alpha1.MeshConfigRequest.type_url)
}

// string response_nonce = 4;
inline void MeshConfigRequest::clear_response_nonce() {
  response_nonce_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MeshConfigRequest::response_nonce() const {
  // @@protoc_insertion_point(field_get:istio.mcp.v1alpha1.MeshConfigRequest.response_nonce)
  return response_nonce_.GetNoArena();
}
inline void MeshConfigRequest::set_response_nonce(const ::std::string& value) {
  
  response_nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.mcp.v1alpha1.MeshConfigRequest.response_nonce)
}
#if LANG_CXX11
inline void MeshConfigRequest::set_response_nonce(::std::string&& value) {
  
  response_nonce_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.mcp.v1alpha1.MeshConfigRequest.response_nonce)
}
#endif
inline void MeshConfigRequest::set_response_nonce(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  response_nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.mcp.v1alpha1.MeshConfigRequest.response_nonce)
}
inline void MeshConfigRequest::set_response_nonce(const char* value, size_t size) {
  
  response_nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.mcp.v1alpha1.MeshConfigRequest.response_nonce)
}
inline ::std::string* MeshConfigRequest::mutable_response_nonce() {
  
  // @@protoc_insertion_point(field_mutable:istio.mcp.v1alpha1.MeshConfigRequest.response_nonce)
  return response_nonce_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MeshConfigRequest::release_response_nonce() {
  // @@protoc_insertion_point(field_release:istio.mcp.v1alpha1.MeshConfigRequest.response_nonce)
  
  return response_nonce_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MeshConfigRequest::set_allocated_response_nonce(::std::string* response_nonce) {
  if (response_nonce != NULL) {
    
  } else {
    
  }
  response_nonce_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), response_nonce);
  // @@protoc_insertion_point(field_set_allocated:istio.mcp.v1alpha1.MeshConfigRequest.response_nonce)
}

// .google.rpc.Status error_detail = 5;
inline bool MeshConfigRequest::has_error_detail() const {
  return this != internal_default_instance() && error_detail_ != NULL;
}
inline const ::google::rpc::Status& MeshConfigRequest::error_detail() const {
  const ::google::rpc::Status* p = error_detail_;
  // @@protoc_insertion_point(field_get:istio.mcp.v1alpha1.MeshConfigRequest.error_detail)
  return p != NULL ? *p : *reinterpret_cast<const ::google::rpc::Status*>(
      &::google::rpc::_Status_default_instance_);
}
inline ::google::rpc::Status* MeshConfigRequest::release_error_detail() {
  // @@protoc_insertion_point(field_release:istio.mcp.v1alpha1.MeshConfigRequest.error_detail)
  
  ::google::rpc::Status* temp = error_detail_;
  error_detail_ = NULL;
  return temp;
}
inline ::google::rpc::Status* MeshConfigRequest::mutable_error_detail() {
  
  if (error_detail_ == NULL) {
    error_detail_ = new ::google::rpc::Status;
  }
  // @@protoc_insertion_point(field_mutable:istio.mcp.v1alpha1.MeshConfigRequest.error_detail)
  return error_detail_;
}
inline void MeshConfigRequest::set_allocated_error_detail(::google::rpc::Status* error_detail) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(error_detail_);
  }
  if (error_detail) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      error_detail = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error_detail, submessage_arena);
    }
    
  } else {
    
  }
  error_detail_ = error_detail;
  // @@protoc_insertion_point(field_set_allocated:istio.mcp.v1alpha1.MeshConfigRequest.error_detail)
}

// -------------------------------------------------------------------

// MeshConfigResponse

// string version_info = 1;
inline void MeshConfigResponse::clear_version_info() {
  version_info_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MeshConfigResponse::version_info() const {
  // @@protoc_insertion_point(field_get:istio.mcp.v1alpha1.MeshConfigResponse.version_info)
  return version_info_.GetNoArena();
}
inline void MeshConfigResponse::set_version_info(const ::std::string& value) {
  
  version_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.mcp.v1alpha1.MeshConfigResponse.version_info)
}
#if LANG_CXX11
inline void MeshConfigResponse::set_version_info(::std::string&& value) {
  
  version_info_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.mcp.v1alpha1.MeshConfigResponse.version_info)
}
#endif
inline void MeshConfigResponse::set_version_info(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.mcp.v1alpha1.MeshConfigResponse.version_info)
}
inline void MeshConfigResponse::set_version_info(const char* value, size_t size) {
  
  version_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.mcp.v1alpha1.MeshConfigResponse.version_info)
}
inline ::std::string* MeshConfigResponse::mutable_version_info() {
  
  // @@protoc_insertion_point(field_mutable:istio.mcp.v1alpha1.MeshConfigResponse.version_info)
  return version_info_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MeshConfigResponse::release_version_info() {
  // @@protoc_insertion_point(field_release:istio.mcp.v1alpha1.MeshConfigResponse.version_info)
  
  return version_info_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MeshConfigResponse::set_allocated_version_info(::std::string* version_info) {
  if (version_info != NULL) {
    
  } else {
    
  }
  version_info_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version_info);
  // @@protoc_insertion_point(field_set_allocated:istio.mcp.v1alpha1.MeshConfigResponse.version_info)
}

// repeated .istio.mcp.v1alpha1.Resource resources = 2 [(.gogoproto.nullable) = false];
inline int MeshConfigResponse::resources_size() const {
  return resources_.size();
}
inline const ::istio::mcp::v1alpha1::Resource& MeshConfigResponse::resources(int index) const {
  // @@protoc_insertion_point(field_get:istio.mcp.v1alpha1.MeshConfigResponse.resources)
  return resources_.Get(index);
}
inline ::istio::mcp::v1alpha1::Resource* MeshConfigResponse::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:istio.mcp.v1alpha1.MeshConfigResponse.resources)
  return resources_.Mutable(index);
}
inline ::istio::mcp::v1alpha1::Resource* MeshConfigResponse::add_resources() {
  // @@protoc_insertion_point(field_add:istio.mcp.v1alpha1.MeshConfigResponse.resources)
  return resources_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::istio::mcp::v1alpha1::Resource >*
MeshConfigResponse::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:istio.mcp.v1alpha1.MeshConfigResponse.resources)
  return &resources_;
}
inline const ::google::protobuf::RepeatedPtrField< ::istio::mcp::v1alpha1::Resource >&
MeshConfigResponse::resources() const {
  // @@protoc_insertion_point(field_list:istio.mcp.v1alpha1.MeshConfigResponse.resources)
  return resources_;
}

// string type_url = 3;
inline void MeshConfigResponse::clear_type_url() {
  type_url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MeshConfigResponse::type_url() const {
  // @@protoc_insertion_point(field_get:istio.mcp.v1alpha1.MeshConfigResponse.type_url)
  return type_url_.GetNoArena();
}
inline void MeshConfigResponse::set_type_url(const ::std::string& value) {
  
  type_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.mcp.v1alpha1.MeshConfigResponse.type_url)
}
#if LANG_CXX11
inline void MeshConfigResponse::set_type_url(::std::string&& value) {
  
  type_url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.mcp.v1alpha1.MeshConfigResponse.type_url)
}
#endif
inline void MeshConfigResponse::set_type_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.mcp.v1alpha1.MeshConfigResponse.type_url)
}
inline void MeshConfigResponse::set_type_url(const char* value, size_t size) {
  
  type_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.mcp.v1alpha1.MeshConfigResponse.type_url)
}
inline ::std::string* MeshConfigResponse::mutable_type_url() {
  
  // @@protoc_insertion_point(field_mutable:istio.mcp.v1alpha1.MeshConfigResponse.type_url)
  return type_url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MeshConfigResponse::release_type_url() {
  // @@protoc_insertion_point(field_release:istio.mcp.v1alpha1.MeshConfigResponse.type_url)
  
  return type_url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MeshConfigResponse::set_allocated_type_url(::std::string* type_url) {
  if (type_url != NULL) {
    
  } else {
    
  }
  type_url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type_url);
  // @@protoc_insertion_point(field_set_allocated:istio.mcp.v1alpha1.MeshConfigResponse.type_url)
}

// string nonce = 4;
inline void MeshConfigResponse::clear_nonce() {
  nonce_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MeshConfigResponse::nonce() const {
  // @@protoc_insertion_point(field_get:istio.mcp.v1alpha1.MeshConfigResponse.nonce)
  return nonce_.GetNoArena();
}
inline void MeshConfigResponse::set_nonce(const ::std::string& value) {
  
  nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.mcp.v1alpha1.MeshConfigResponse.nonce)
}
#if LANG_CXX11
inline void MeshConfigResponse::set_nonce(::std::string&& value) {
  
  nonce_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.mcp.v1alpha1.MeshConfigResponse.nonce)
}
#endif
inline void MeshConfigResponse::set_nonce(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.mcp.v1alpha1.MeshConfigResponse.nonce)
}
inline void MeshConfigResponse::set_nonce(const char* value, size_t size) {
  
  nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.mcp.v1alpha1.MeshConfigResponse.nonce)
}
inline ::std::string* MeshConfigResponse::mutable_nonce() {
  
  // @@protoc_insertion_point(field_mutable:istio.mcp.v1alpha1.MeshConfigResponse.nonce)
  return nonce_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MeshConfigResponse::release_nonce() {
  // @@protoc_insertion_point(field_release:istio.mcp.v1alpha1.MeshConfigResponse.nonce)
  
  return nonce_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MeshConfigResponse::set_allocated_nonce(::std::string* nonce) {
  if (nonce != NULL) {
    
  } else {
    
  }
  nonce_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nonce);
  // @@protoc_insertion_point(field_set_allocated:istio.mcp.v1alpha1.MeshConfigResponse.nonce)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// IncrementalMeshConfigRequest

// .istio.mcp.v1alpha1.SinkNode sink_node = 1;
inline bool IncrementalMeshConfigRequest::has_sink_node() const {
  return this != internal_default_instance() && sink_node_ != NULL;
}
inline void IncrementalMeshConfigRequest::clear_sink_node() {
  if (GetArenaNoVirtual() == NULL && sink_node_ != NULL) {
    delete sink_node_;
  }
  sink_node_ = NULL;
}
inline const ::istio::mcp::v1alpha1::SinkNode& IncrementalMeshConfigRequest::sink_node() const {
  const ::istio::mcp::v1alpha1::SinkNode* p = sink_node_;
  // @@protoc_insertion_point(field_get:istio.mcp.v1alpha1.IncrementalMeshConfigRequest.sink_node)
  return p != NULL ? *p : *reinterpret_cast<const ::istio::mcp::v1alpha1::SinkNode*>(
      &::istio::mcp::v1alpha1::_SinkNode_default_instance_);
}
inline ::istio::mcp::v1alpha1::SinkNode* IncrementalMeshConfigRequest::release_sink_node() {
  // @@protoc_insertion_point(field_release:istio.mcp.v1alpha1.IncrementalMeshConfigRequest.sink_node)
  
  ::istio::mcp::v1alpha1::SinkNode* temp = sink_node_;
  sink_node_ = NULL;
  return temp;
}
inline ::istio::mcp::v1alpha1::SinkNode* IncrementalMeshConfigRequest::mutable_sink_node() {
  
  if (sink_node_ == NULL) {
    sink_node_ = new ::istio::mcp::v1alpha1::SinkNode;
  }
  // @@protoc_insertion_point(field_mutable:istio.mcp.v1alpha1.IncrementalMeshConfigRequest.sink_node)
  return sink_node_;
}
inline void IncrementalMeshConfigRequest::set_allocated_sink_node(::istio::mcp::v1alpha1::SinkNode* sink_node) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sink_node_;
  }
  if (sink_node) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sink_node = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sink_node, submessage_arena);
    }
    
  } else {
    
  }
  sink_node_ = sink_node;
  // @@protoc_insertion_point(field_set_allocated:istio.mcp.v1alpha1.IncrementalMeshConfigRequest.sink_node)
}

// string type_url = 2;
inline void IncrementalMeshConfigRequest::clear_type_url() {
  type_url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& IncrementalMeshConfigRequest::type_url() const {
  // @@protoc_insertion_point(field_get:istio.mcp.v1alpha1.IncrementalMeshConfigRequest.type_url)
  return type_url_.GetNoArena();
}
inline void IncrementalMeshConfigRequest::set_type_url(const ::std::string& value) {
  
  type_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.mcp.v1alpha1.IncrementalMeshConfigRequest.type_url)
}
#if LANG_CXX11
inline void IncrementalMeshConfigRequest::set_type_url(::std::string&& value) {
  
  type_url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.mcp.v1alpha1.IncrementalMeshConfigRequest.type_url)
}
#endif
inline void IncrementalMeshConfigRequest::set_type_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.mcp.v1alpha1.IncrementalMeshConfigRequest.type_url)
}
inline void IncrementalMeshConfigRequest::set_type_url(const char* value, size_t size) {
  
  type_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.mcp.v1alpha1.IncrementalMeshConfigRequest.type_url)
}
inline ::std::string* IncrementalMeshConfigRequest::mutable_type_url() {
  
  // @@protoc_insertion_point(field_mutable:istio.mcp.v1alpha1.IncrementalMeshConfigRequest.type_url)
  return type_url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IncrementalMeshConfigRequest::release_type_url() {
  // @@protoc_insertion_point(field_release:istio.mcp.v1alpha1.IncrementalMeshConfigRequest.type_url)
  
  return type_url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IncrementalMeshConfigRequest::set_allocated_type_url(::std::string* type_url) {
  if (type_url != NULL) {
    
  } else {
    
  }
  type_url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type_url);
  // @@protoc_insertion_point(field_set_allocated:istio.mcp.v1alpha1.IncrementalMeshConfigRequest.type_url)
}

// map<string, string> initial_resource_versions = 3;
inline int IncrementalMeshConfigRequest::initial_resource_versions_size() const {
  return initial_resource_versions_.size();
}
inline void IncrementalMeshConfigRequest::clear_initial_resource_versions() {
  initial_resource_versions_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
IncrementalMeshConfigRequest::initial_resource_versions() const {
  // @@protoc_insertion_point(field_map:istio.mcp.v1alpha1.IncrementalMeshConfigRequest.initial_resource_versions)
  return initial_resource_versions_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
IncrementalMeshConfigRequest::mutable_initial_resource_versions() {
  // @@protoc_insertion_point(field_mutable_map:istio.mcp.v1alpha1.IncrementalMeshConfigRequest.initial_resource_versions)
  return initial_resource_versions_.MutableMap();
}

// string response_nonce = 4;
inline void IncrementalMeshConfigRequest::clear_response_nonce() {
  response_nonce_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& IncrementalMeshConfigRequest::response_nonce() const {
  // @@protoc_insertion_point(field_get:istio.mcp.v1alpha1.IncrementalMeshConfigRequest.response_nonce)
  return response_nonce_.GetNoArena();
}
inline void IncrementalMeshConfigRequest::set_response_nonce(const ::std::string& value) {
  
  response_nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.mcp.v1alpha1.IncrementalMeshConfigRequest.response_nonce)
}
#if LANG_CXX11
inline void IncrementalMeshConfigRequest::set_response_nonce(::std::string&& value) {
  
  response_nonce_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.mcp.v1alpha1.IncrementalMeshConfigRequest.response_nonce)
}
#endif
inline void IncrementalMeshConfigRequest::set_response_nonce(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  response_nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.mcp.v1alpha1.IncrementalMeshConfigRequest.response_nonce)
}
inline void IncrementalMeshConfigRequest::set_response_nonce(const char* value, size_t size) {
  
  response_nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.mcp.v1alpha1.IncrementalMeshConfigRequest.response_nonce)
}
inline ::std::string* IncrementalMeshConfigRequest::mutable_response_nonce() {
  
  // @@protoc_insertion_point(field_mutable:istio.mcp.v1alpha1.IncrementalMeshConfigRequest.response_nonce)
  return response_nonce_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IncrementalMeshConfigRequest::release_response_nonce() {
  // @@protoc_insertion_point(field_release:istio.mcp.v1alpha1.IncrementalMeshConfigRequest.response_nonce)
  
  return response_nonce_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IncrementalMeshConfigRequest::set_allocated_response_nonce(::std::string* response_nonce) {
  if (response_nonce != NULL) {
    
  } else {
    
  }
  response_nonce_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), response_nonce);
  // @@protoc_insertion_point(field_set_allocated:istio.mcp.v1alpha1.IncrementalMeshConfigRequest.response_nonce)
}

// .google.rpc.Status error_detail = 5;
inline bool IncrementalMeshConfigRequest::has_error_detail() const {
  return this != internal_default_instance() && error_detail_ != NULL;
}
inline const ::google::rpc::Status& IncrementalMeshConfigRequest::error_detail() const {
  const ::google::rpc::Status* p = error_detail_;
  // @@protoc_insertion_point(field_get:istio.mcp.v1alpha1.IncrementalMeshConfigRequest.error_detail)
  return p != NULL ? *p : *reinterpret_cast<const ::google::rpc::Status*>(
      &::google::rpc::_Status_default_instance_);
}
inline ::google::rpc::Status* IncrementalMeshConfigRequest::release_error_detail() {
  // @@protoc_insertion_point(field_release:istio.mcp.v1alpha1.IncrementalMeshConfigRequest.error_detail)
  
  ::google::rpc::Status* temp = error_detail_;
  error_detail_ = NULL;
  return temp;
}
inline ::google::rpc::Status* IncrementalMeshConfigRequest::mutable_error_detail() {
  
  if (error_detail_ == NULL) {
    error_detail_ = new ::google::rpc::Status;
  }
  // @@protoc_insertion_point(field_mutable:istio.mcp.v1alpha1.IncrementalMeshConfigRequest.error_detail)
  return error_detail_;
}
inline void IncrementalMeshConfigRequest::set_allocated_error_detail(::google::rpc::Status* error_detail) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(error_detail_);
  }
  if (error_detail) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      error_detail = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error_detail, submessage_arena);
    }
    
  } else {
    
  }
  error_detail_ = error_detail;
  // @@protoc_insertion_point(field_set_allocated:istio.mcp.v1alpha1.IncrementalMeshConfigRequest.error_detail)
}

// -------------------------------------------------------------------

// IncrementalMeshConfigResponse

// string system_version_info = 1;
inline void IncrementalMeshConfigResponse::clear_system_version_info() {
  system_version_info_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& IncrementalMeshConfigResponse::system_version_info() const {
  // @@protoc_insertion_point(field_get:istio.mcp.v1alpha1.IncrementalMeshConfigResponse.system_version_info)
  return system_version_info_.GetNoArena();
}
inline void IncrementalMeshConfigResponse::set_system_version_info(const ::std::string& value) {
  
  system_version_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.mcp.v1alpha1.IncrementalMeshConfigResponse.system_version_info)
}
#if LANG_CXX11
inline void IncrementalMeshConfigResponse::set_system_version_info(::std::string&& value) {
  
  system_version_info_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.mcp.v1alpha1.IncrementalMeshConfigResponse.system_version_info)
}
#endif
inline void IncrementalMeshConfigResponse::set_system_version_info(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  system_version_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.mcp.v1alpha1.IncrementalMeshConfigResponse.system_version_info)
}
inline void IncrementalMeshConfigResponse::set_system_version_info(const char* value, size_t size) {
  
  system_version_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.mcp.v1alpha1.IncrementalMeshConfigResponse.system_version_info)
}
inline ::std::string* IncrementalMeshConfigResponse::mutable_system_version_info() {
  
  // @@protoc_insertion_point(field_mutable:istio.mcp.v1alpha1.IncrementalMeshConfigResponse.system_version_info)
  return system_version_info_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IncrementalMeshConfigResponse::release_system_version_info() {
  // @@protoc_insertion_point(field_release:istio.mcp.v1alpha1.IncrementalMeshConfigResponse.system_version_info)
  
  return system_version_info_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IncrementalMeshConfigResponse::set_allocated_system_version_info(::std::string* system_version_info) {
  if (system_version_info != NULL) {
    
  } else {
    
  }
  system_version_info_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), system_version_info);
  // @@protoc_insertion_point(field_set_allocated:istio.mcp.v1alpha1.IncrementalMeshConfigResponse.system_version_info)
}

// repeated .istio.mcp.v1alpha1.Resource resources = 2 [(.gogoproto.nullable) = false];
inline int IncrementalMeshConfigResponse::resources_size() const {
  return resources_.size();
}
inline const ::istio::mcp::v1alpha1::Resource& IncrementalMeshConfigResponse::resources(int index) const {
  // @@protoc_insertion_point(field_get:istio.mcp.v1alpha1.IncrementalMeshConfigResponse.resources)
  return resources_.Get(index);
}
inline ::istio::mcp::v1alpha1::Resource* IncrementalMeshConfigResponse::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:istio.mcp.v1alpha1.IncrementalMeshConfigResponse.resources)
  return resources_.Mutable(index);
}
inline ::istio::mcp::v1alpha1::Resource* IncrementalMeshConfigResponse::add_resources() {
  // @@protoc_insertion_point(field_add:istio.mcp.v1alpha1.IncrementalMeshConfigResponse.resources)
  return resources_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::istio::mcp::v1alpha1::Resource >*
IncrementalMeshConfigResponse::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:istio.mcp.v1alpha1.IncrementalMeshConfigResponse.resources)
  return &resources_;
}
inline const ::google::protobuf::RepeatedPtrField< ::istio::mcp::v1alpha1::Resource >&
IncrementalMeshConfigResponse::resources() const {
  // @@protoc_insertion_point(field_list:istio.mcp.v1alpha1.IncrementalMeshConfigResponse.resources)
  return resources_;
}

// repeated string removed_resources = 3;
inline int IncrementalMeshConfigResponse::removed_resources_size() const {
  return removed_resources_.size();
}
inline void IncrementalMeshConfigResponse::clear_removed_resources() {
  removed_resources_.Clear();
}
inline const ::std::string& IncrementalMeshConfigResponse::removed_resources(int index) const {
  // @@protoc_insertion_point(field_get:istio.mcp.v1alpha1.IncrementalMeshConfigResponse.removed_resources)
  return removed_resources_.Get(index);
}
inline ::std::string* IncrementalMeshConfigResponse::mutable_removed_resources(int index) {
  // @@protoc_insertion_point(field_mutable:istio.mcp.v1alpha1.IncrementalMeshConfigResponse.removed_resources)
  return removed_resources_.Mutable(index);
}
inline void IncrementalMeshConfigResponse::set_removed_resources(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:istio.mcp.v1alpha1.IncrementalMeshConfigResponse.removed_resources)
  removed_resources_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void IncrementalMeshConfigResponse::set_removed_resources(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:istio.mcp.v1alpha1.IncrementalMeshConfigResponse.removed_resources)
  removed_resources_.Mutable(index)->assign(std::move(value));
}
#endif
inline void IncrementalMeshConfigResponse::set_removed_resources(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  removed_resources_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:istio.mcp.v1alpha1.IncrementalMeshConfigResponse.removed_resources)
}
inline void IncrementalMeshConfigResponse::set_removed_resources(int index, const char* value, size_t size) {
  removed_resources_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:istio.mcp.v1alpha1.IncrementalMeshConfigResponse.removed_resources)
}
inline ::std::string* IncrementalMeshConfigResponse::add_removed_resources() {
  // @@protoc_insertion_point(field_add_mutable:istio.mcp.v1alpha1.IncrementalMeshConfigResponse.removed_resources)
  return removed_resources_.Add();
}
inline void IncrementalMeshConfigResponse::add_removed_resources(const ::std::string& value) {
  removed_resources_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:istio.mcp.v1alpha1.IncrementalMeshConfigResponse.removed_resources)
}
#if LANG_CXX11
inline void IncrementalMeshConfigResponse::add_removed_resources(::std::string&& value) {
  removed_resources_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:istio.mcp.v1alpha1.IncrementalMeshConfigResponse.removed_resources)
}
#endif
inline void IncrementalMeshConfigResponse::add_removed_resources(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  removed_resources_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:istio.mcp.v1alpha1.IncrementalMeshConfigResponse.removed_resources)
}
inline void IncrementalMeshConfigResponse::add_removed_resources(const char* value, size_t size) {
  removed_resources_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:istio.mcp.v1alpha1.IncrementalMeshConfigResponse.removed_resources)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
IncrementalMeshConfigResponse::removed_resources() const {
  // @@protoc_insertion_point(field_list:istio.mcp.v1alpha1.IncrementalMeshConfigResponse.removed_resources)
  return removed_resources_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
IncrementalMeshConfigResponse::mutable_removed_resources() {
  // @@protoc_insertion_point(field_mutable_list:istio.mcp.v1alpha1.IncrementalMeshConfigResponse.removed_resources)
  return &removed_resources_;
}

// string nonce = 4;
inline void IncrementalMeshConfigResponse::clear_nonce() {
  nonce_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& IncrementalMeshConfigResponse::nonce() const {
  // @@protoc_insertion_point(field_get:istio.mcp.v1alpha1.IncrementalMeshConfigResponse.nonce)
  return nonce_.GetNoArena();
}
inline void IncrementalMeshConfigResponse::set_nonce(const ::std::string& value) {
  
  nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.mcp.v1alpha1.IncrementalMeshConfigResponse.nonce)
}
#if LANG_CXX11
inline void IncrementalMeshConfigResponse::set_nonce(::std::string&& value) {
  
  nonce_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.mcp.v1alpha1.IncrementalMeshConfigResponse.nonce)
}
#endif
inline void IncrementalMeshConfigResponse::set_nonce(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.mcp.v1alpha1.IncrementalMeshConfigResponse.nonce)
}
inline void IncrementalMeshConfigResponse::set_nonce(const char* value, size_t size) {
  
  nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.mcp.v1alpha1.IncrementalMeshConfigResponse.nonce)
}
inline ::std::string* IncrementalMeshConfigResponse::mutable_nonce() {
  
  // @@protoc_insertion_point(field_mutable:istio.mcp.v1alpha1.IncrementalMeshConfigResponse.nonce)
  return nonce_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IncrementalMeshConfigResponse::release_nonce() {
  // @@protoc_insertion_point(field_release:istio.mcp.v1alpha1.IncrementalMeshConfigResponse.nonce)
  
  return nonce_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IncrementalMeshConfigResponse::set_allocated_nonce(::std::string* nonce) {
  if (nonce != NULL) {
    
  } else {
    
  }
  nonce_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nonce);
  // @@protoc_insertion_point(field_set_allocated:istio.mcp.v1alpha1.IncrementalMeshConfigResponse.nonce)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// RequestResources

// .istio.mcp.v1alpha1.SinkNode sink_node = 1;
inline bool RequestResources::has_sink_node() const {
  return this != internal_default_instance() && sink_node_ != NULL;
}
inline void RequestResources::clear_sink_node() {
  if (GetArenaNoVirtual() == NULL && sink_node_ != NULL) {
    delete sink_node_;
  }
  sink_node_ = NULL;
}
inline const ::istio::mcp::v1alpha1::SinkNode& RequestResources::sink_node() const {
  const ::istio::mcp::v1alpha1::SinkNode* p = sink_node_;
  // @@protoc_insertion_point(field_get:istio.mcp.v1alpha1.RequestResources.sink_node)
  return p != NULL ? *p : *reinterpret_cast<const ::istio::mcp::v1alpha1::SinkNode*>(
      &::istio::mcp::v1alpha1::_SinkNode_default_instance_);
}
inline ::istio::mcp::v1alpha1::SinkNode* RequestResources::release_sink_node() {
  // @@protoc_insertion_point(field_release:istio.mcp.v1alpha1.RequestResources.sink_node)
  
  ::istio::mcp::v1alpha1::SinkNode* temp = sink_node_;
  sink_node_ = NULL;
  return temp;
}
inline ::istio::mcp::v1alpha1::SinkNode* RequestResources::mutable_sink_node() {
  
  if (sink_node_ == NULL) {
    sink_node_ = new ::istio::mcp::v1alpha1::SinkNode;
  }
  // @@protoc_insertion_point(field_mutable:istio.mcp.v1alpha1.RequestResources.sink_node)
  return sink_node_;
}
inline void RequestResources::set_allocated_sink_node(::istio::mcp::v1alpha1::SinkNode* sink_node) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sink_node_;
  }
  if (sink_node) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sink_node = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sink_node, submessage_arena);
    }
    
  } else {
    
  }
  sink_node_ = sink_node;
  // @@protoc_insertion_point(field_set_allocated:istio.mcp.v1alpha1.RequestResources.sink_node)
}

// string collection = 2;
inline void RequestResources::clear_collection() {
  collection_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RequestResources::collection() const {
  // @@protoc_insertion_point(field_get:istio.mcp.v1alpha1.RequestResources.collection)
  return collection_.GetNoArena();
}
inline void RequestResources::set_collection(const ::std::string& value) {
  
  collection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.mcp.v1alpha1.RequestResources.collection)
}
#if LANG_CXX11
inline void RequestResources::set_collection(::std::string&& value) {
  
  collection_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.mcp.v1alpha1.RequestResources.collection)
}
#endif
inline void RequestResources::set_collection(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  collection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.mcp.v1alpha1.RequestResources.collection)
}
inline void RequestResources::set_collection(const char* value, size_t size) {
  
  collection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.mcp.v1alpha1.RequestResources.collection)
}
inline ::std::string* RequestResources::mutable_collection() {
  
  // @@protoc_insertion_point(field_mutable:istio.mcp.v1alpha1.RequestResources.collection)
  return collection_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestResources::release_collection() {
  // @@protoc_insertion_point(field_release:istio.mcp.v1alpha1.RequestResources.collection)
  
  return collection_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestResources::set_allocated_collection(::std::string* collection) {
  if (collection != NULL) {
    
  } else {
    
  }
  collection_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), collection);
  // @@protoc_insertion_point(field_set_allocated:istio.mcp.v1alpha1.RequestResources.collection)
}

// map<string, string> initial_resource_versions = 3;
inline int RequestResources::initial_resource_versions_size() const {
  return initial_resource_versions_.size();
}
inline void RequestResources::clear_initial_resource_versions() {
  initial_resource_versions_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
RequestResources::initial_resource_versions() const {
  // @@protoc_insertion_point(field_map:istio.mcp.v1alpha1.RequestResources.initial_resource_versions)
  return initial_resource_versions_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
RequestResources::mutable_initial_resource_versions() {
  // @@protoc_insertion_point(field_mutable_map:istio.mcp.v1alpha1.RequestResources.initial_resource_versions)
  return initial_resource_versions_.MutableMap();
}

// string response_nonce = 4;
inline void RequestResources::clear_response_nonce() {
  response_nonce_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RequestResources::response_nonce() const {
  // @@protoc_insertion_point(field_get:istio.mcp.v1alpha1.RequestResources.response_nonce)
  return response_nonce_.GetNoArena();
}
inline void RequestResources::set_response_nonce(const ::std::string& value) {
  
  response_nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.mcp.v1alpha1.RequestResources.response_nonce)
}
#if LANG_CXX11
inline void RequestResources::set_response_nonce(::std::string&& value) {
  
  response_nonce_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.mcp.v1alpha1.RequestResources.response_nonce)
}
#endif
inline void RequestResources::set_response_nonce(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  response_nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.mcp.v1alpha1.RequestResources.response_nonce)
}
inline void RequestResources::set_response_nonce(const char* value, size_t size) {
  
  response_nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.mcp.v1alpha1.RequestResources.response_nonce)
}
inline ::std::string* RequestResources::mutable_response_nonce() {
  
  // @@protoc_insertion_point(field_mutable:istio.mcp.v1alpha1.RequestResources.response_nonce)
  return response_nonce_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestResources::release_response_nonce() {
  // @@protoc_insertion_point(field_release:istio.mcp.v1alpha1.RequestResources.response_nonce)
  
  return response_nonce_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestResources::set_allocated_response_nonce(::std::string* response_nonce) {
  if (response_nonce != NULL) {
    
  } else {
    
  }
  response_nonce_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), response_nonce);
  // @@protoc_insertion_point(field_set_allocated:istio.mcp.v1alpha1.RequestResources.response_nonce)
}

// .google.rpc.Status error_detail = 5;
inline bool RequestResources::has_error_detail() const {
  return this != internal_default_instance() && error_detail_ != NULL;
}
inline const ::google::rpc::Status& RequestResources::error_detail() const {
  const ::google::rpc::Status* p = error_detail_;
  // @@protoc_insertion_point(field_get:istio.mcp.v1alpha1.RequestResources.error_detail)
  return p != NULL ? *p : *reinterpret_cast<const ::google::rpc::Status*>(
      &::google::rpc::_Status_default_instance_);
}
inline ::google::rpc::Status* RequestResources::release_error_detail() {
  // @@protoc_insertion_point(field_release:istio.mcp.v1alpha1.RequestResources.error_detail)
  
  ::google::rpc::Status* temp = error_detail_;
  error_detail_ = NULL;
  return temp;
}
inline ::google::rpc::Status* RequestResources::mutable_error_detail() {
  
  if (error_detail_ == NULL) {
    error_detail_ = new ::google::rpc::Status;
  }
  // @@protoc_insertion_point(field_mutable:istio.mcp.v1alpha1.RequestResources.error_detail)
  return error_detail_;
}
inline void RequestResources::set_allocated_error_detail(::google::rpc::Status* error_detail) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(error_detail_);
  }
  if (error_detail) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      error_detail = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error_detail, submessage_arena);
    }
    
  } else {
    
  }
  error_detail_ = error_detail;
  // @@protoc_insertion_point(field_set_allocated:istio.mcp.v1alpha1.RequestResources.error_detail)
}

// bool incremental = 6;
inline void RequestResources::clear_incremental() {
  incremental_ = false;
}
inline bool RequestResources::incremental() const {
  // @@protoc_insertion_point(field_get:istio.mcp.v1alpha1.RequestResources.incremental)
  return incremental_;
}
inline void RequestResources::set_incremental(bool value) {
  
  incremental_ = value;
  // @@protoc_insertion_point(field_set:istio.mcp.v1alpha1.RequestResources.incremental)
}

// -------------------------------------------------------------------

// Resources

// string system_version_info = 1;
inline void Resources::clear_system_version_info() {
  system_version_info_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Resources::system_version_info() const {
  // @@protoc_insertion_point(field_get:istio.mcp.v1alpha1.Resources.system_version_info)
  return system_version_info_.GetNoArena();
}
inline void Resources::set_system_version_info(const ::std::string& value) {
  
  system_version_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.mcp.v1alpha1.Resources.system_version_info)
}
#if LANG_CXX11
inline void Resources::set_system_version_info(::std::string&& value) {
  
  system_version_info_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.mcp.v1alpha1.Resources.system_version_info)
}
#endif
inline void Resources::set_system_version_info(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  system_version_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.mcp.v1alpha1.Resources.system_version_info)
}
inline void Resources::set_system_version_info(const char* value, size_t size) {
  
  system_version_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.mcp.v1alpha1.Resources.system_version_info)
}
inline ::std::string* Resources::mutable_system_version_info() {
  
  // @@protoc_insertion_point(field_mutable:istio.mcp.v1alpha1.Resources.system_version_info)
  return system_version_info_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Resources::release_system_version_info() {
  // @@protoc_insertion_point(field_release:istio.mcp.v1alpha1.Resources.system_version_info)
  
  return system_version_info_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Resources::set_allocated_system_version_info(::std::string* system_version_info) {
  if (system_version_info != NULL) {
    
  } else {
    
  }
  system_version_info_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), system_version_info);
  // @@protoc_insertion_point(field_set_allocated:istio.mcp.v1alpha1.Resources.system_version_info)
}

// string collection = 2;
inline void Resources::clear_collection() {
  collection_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Resources::collection() const {
  // @@protoc_insertion_point(field_get:istio.mcp.v1alpha1.Resources.collection)
  return collection_.GetNoArena();
}
inline void Resources::set_collection(const ::std::string& value) {
  
  collection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.mcp.v1alpha1.Resources.collection)
}
#if LANG_CXX11
inline void Resources::set_collection(::std::string&& value) {
  
  collection_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.mcp.v1alpha1.Resources.collection)
}
#endif
inline void Resources::set_collection(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  collection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.mcp.v1alpha1.Resources.collection)
}
inline void Resources::set_collection(const char* value, size_t size) {
  
  collection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.mcp.v1alpha1.Resources.collection)
}
inline ::std::string* Resources::mutable_collection() {
  
  // @@protoc_insertion_point(field_mutable:istio.mcp.v1alpha1.Resources.collection)
  return collection_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Resources::release_collection() {
  // @@protoc_insertion_point(field_release:istio.mcp.v1alpha1.Resources.collection)
  
  return collection_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Resources::set_allocated_collection(::std::string* collection) {
  if (collection != NULL) {
    
  } else {
    
  }
  collection_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), collection);
  // @@protoc_insertion_point(field_set_allocated:istio.mcp.v1alpha1.Resources.collection)
}

// repeated .istio.mcp.v1alpha1.Resource resources = 3 [(.gogoproto.nullable) = false];
inline int Resources::resources_size() const {
  return resources_.size();
}
inline const ::istio::mcp::v1alpha1::Resource& Resources::resources(int index) const {
  // @@protoc_insertion_point(field_get:istio.mcp.v1alpha1.Resources.resources)
  return resources_.Get(index);
}
inline ::istio::mcp::v1alpha1::Resource* Resources::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:istio.mcp.v1alpha1.Resources.resources)
  return resources_.Mutable(index);
}
inline ::istio::mcp::v1alpha1::Resource* Resources::add_resources() {
  // @@protoc_insertion_point(field_add:istio.mcp.v1alpha1.Resources.resources)
  return resources_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::istio::mcp::v1alpha1::Resource >*
Resources::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:istio.mcp.v1alpha1.Resources.resources)
  return &resources_;
}
inline const ::google::protobuf::RepeatedPtrField< ::istio::mcp::v1alpha1::Resource >&
Resources::resources() const {
  // @@protoc_insertion_point(field_list:istio.mcp.v1alpha1.Resources.resources)
  return resources_;
}

// repeated string removed_resources = 4;
inline int Resources::removed_resources_size() const {
  return removed_resources_.size();
}
inline void Resources::clear_removed_resources() {
  removed_resources_.Clear();
}
inline const ::std::string& Resources::removed_resources(int index) const {
  // @@protoc_insertion_point(field_get:istio.mcp.v1alpha1.Resources.removed_resources)
  return removed_resources_.Get(index);
}
inline ::std::string* Resources::mutable_removed_resources(int index) {
  // @@protoc_insertion_point(field_mutable:istio.mcp.v1alpha1.Resources.removed_resources)
  return removed_resources_.Mutable(index);
}
inline void Resources::set_removed_resources(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:istio.mcp.v1alpha1.Resources.removed_resources)
  removed_resources_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Resources::set_removed_resources(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:istio.mcp.v1alpha1.Resources.removed_resources)
  removed_resources_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Resources::set_removed_resources(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  removed_resources_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:istio.mcp.v1alpha1.Resources.removed_resources)
}
inline void Resources::set_removed_resources(int index, const char* value, size_t size) {
  removed_resources_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:istio.mcp.v1alpha1.Resources.removed_resources)
}
inline ::std::string* Resources::add_removed_resources() {
  // @@protoc_insertion_point(field_add_mutable:istio.mcp.v1alpha1.Resources.removed_resources)
  return removed_resources_.Add();
}
inline void Resources::add_removed_resources(const ::std::string& value) {
  removed_resources_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:istio.mcp.v1alpha1.Resources.removed_resources)
}
#if LANG_CXX11
inline void Resources::add_removed_resources(::std::string&& value) {
  removed_resources_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:istio.mcp.v1alpha1.Resources.removed_resources)
}
#endif
inline void Resources::add_removed_resources(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  removed_resources_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:istio.mcp.v1alpha1.Resources.removed_resources)
}
inline void Resources::add_removed_resources(const char* value, size_t size) {
  removed_resources_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:istio.mcp.v1alpha1.Resources.removed_resources)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Resources::removed_resources() const {
  // @@protoc_insertion_point(field_list:istio.mcp.v1alpha1.Resources.removed_resources)
  return removed_resources_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Resources::mutable_removed_resources() {
  // @@protoc_insertion_point(field_mutable_list:istio.mcp.v1alpha1.Resources.removed_resources)
  return &removed_resources_;
}

// string nonce = 5;
inline void Resources::clear_nonce() {
  nonce_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Resources::nonce() const {
  // @@protoc_insertion_point(field_get:istio.mcp.v1alpha1.Resources.nonce)
  return nonce_.GetNoArena();
}
inline void Resources::set_nonce(const ::std::string& value) {
  
  nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.mcp.v1alpha1.Resources.nonce)
}
#if LANG_CXX11
inline void Resources::set_nonce(::std::string&& value) {
  
  nonce_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.mcp.v1alpha1.Resources.nonce)
}
#endif
inline void Resources::set_nonce(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.mcp.v1alpha1.Resources.nonce)
}
inline void Resources::set_nonce(const char* value, size_t size) {
  
  nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.mcp.v1alpha1.Resources.nonce)
}
inline ::std::string* Resources::mutable_nonce() {
  
  // @@protoc_insertion_point(field_mutable:istio.mcp.v1alpha1.Resources.nonce)
  return nonce_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Resources::release_nonce() {
  // @@protoc_insertion_point(field_release:istio.mcp.v1alpha1.Resources.nonce)
  
  return nonce_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Resources::set_allocated_nonce(::std::string* nonce) {
  if (nonce != NULL) {
    
  } else {
    
  }
  nonce_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nonce);
  // @@protoc_insertion_point(field_set_allocated:istio.mcp.v1alpha1.Resources.nonce)
}

// bool incremental = 6;
inline void Resources::clear_incremental() {
  incremental_ = false;
}
inline bool Resources::incremental() const {
  // @@protoc_insertion_point(field_get:istio.mcp.v1alpha1.Resources.incremental)
  return incremental_;
}
inline void Resources::set_incremental(bool value) {
  
  incremental_ = value;
  // @@protoc_insertion_point(field_set:istio.mcp.v1alpha1.Resources.incremental)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1alpha1
}  // namespace mcp
}  // namespace istio

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_mcp_2fv1alpha1_2fmcp_2eproto__INCLUDED
