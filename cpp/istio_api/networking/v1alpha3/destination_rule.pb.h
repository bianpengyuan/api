// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: networking/v1alpha3/destination_rule.proto

#ifndef PROTOBUF_networking_2fv1alpha3_2fdestination_5frule_2eproto__INCLUDED
#define PROTOBUF_networking_2fv1alpha3_2fdestination_5frule_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/duration.pb.h>
#include "networking/v1alpha3/virtual_service.pb.h"
#include "gogoproto/gogo.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_networking_2fv1alpha3_2fdestination_5frule_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[14];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsDestinationRuleImpl();
void InitDefaultsDestinationRule();
void InitDefaultsTrafficPolicy_PortTrafficPolicyImpl();
void InitDefaultsTrafficPolicy_PortTrafficPolicy();
void InitDefaultsTrafficPolicyImpl();
void InitDefaultsTrafficPolicy();
void InitDefaultsSubset_LabelsEntry_DoNotUseImpl();
void InitDefaultsSubset_LabelsEntry_DoNotUse();
void InitDefaultsSubsetImpl();
void InitDefaultsSubset();
void InitDefaultsLoadBalancerSettings_ConsistentHashLB_HTTPCookieImpl();
void InitDefaultsLoadBalancerSettings_ConsistentHashLB_HTTPCookie();
void InitDefaultsLoadBalancerSettings_ConsistentHashLBImpl();
void InitDefaultsLoadBalancerSettings_ConsistentHashLB();
void InitDefaultsLoadBalancerSettingsImpl();
void InitDefaultsLoadBalancerSettings();
void InitDefaultsConnectionPoolSettings_TCPSettings_TcpKeepaliveImpl();
void InitDefaultsConnectionPoolSettings_TCPSettings_TcpKeepalive();
void InitDefaultsConnectionPoolSettings_TCPSettingsImpl();
void InitDefaultsConnectionPoolSettings_TCPSettings();
void InitDefaultsConnectionPoolSettings_HTTPSettingsImpl();
void InitDefaultsConnectionPoolSettings_HTTPSettings();
void InitDefaultsConnectionPoolSettingsImpl();
void InitDefaultsConnectionPoolSettings();
void InitDefaultsOutlierDetectionImpl();
void InitDefaultsOutlierDetection();
void InitDefaultsTLSSettingsImpl();
void InitDefaultsTLSSettings();
inline void InitDefaults() {
  InitDefaultsDestinationRule();
  InitDefaultsTrafficPolicy_PortTrafficPolicy();
  InitDefaultsTrafficPolicy();
  InitDefaultsSubset_LabelsEntry_DoNotUse();
  InitDefaultsSubset();
  InitDefaultsLoadBalancerSettings_ConsistentHashLB_HTTPCookie();
  InitDefaultsLoadBalancerSettings_ConsistentHashLB();
  InitDefaultsLoadBalancerSettings();
  InitDefaultsConnectionPoolSettings_TCPSettings_TcpKeepalive();
  InitDefaultsConnectionPoolSettings_TCPSettings();
  InitDefaultsConnectionPoolSettings_HTTPSettings();
  InitDefaultsConnectionPoolSettings();
  InitDefaultsOutlierDetection();
  InitDefaultsTLSSettings();
}
}  // namespace protobuf_networking_2fv1alpha3_2fdestination_5frule_2eproto
namespace istio {
namespace networking {
namespace v1alpha3 {
class ConnectionPoolSettings;
class ConnectionPoolSettingsDefaultTypeInternal;
extern ConnectionPoolSettingsDefaultTypeInternal _ConnectionPoolSettings_default_instance_;
class ConnectionPoolSettings_HTTPSettings;
class ConnectionPoolSettings_HTTPSettingsDefaultTypeInternal;
extern ConnectionPoolSettings_HTTPSettingsDefaultTypeInternal _ConnectionPoolSettings_HTTPSettings_default_instance_;
class ConnectionPoolSettings_TCPSettings;
class ConnectionPoolSettings_TCPSettingsDefaultTypeInternal;
extern ConnectionPoolSettings_TCPSettingsDefaultTypeInternal _ConnectionPoolSettings_TCPSettings_default_instance_;
class ConnectionPoolSettings_TCPSettings_TcpKeepalive;
class ConnectionPoolSettings_TCPSettings_TcpKeepaliveDefaultTypeInternal;
extern ConnectionPoolSettings_TCPSettings_TcpKeepaliveDefaultTypeInternal _ConnectionPoolSettings_TCPSettings_TcpKeepalive_default_instance_;
class DestinationRule;
class DestinationRuleDefaultTypeInternal;
extern DestinationRuleDefaultTypeInternal _DestinationRule_default_instance_;
class LoadBalancerSettings;
class LoadBalancerSettingsDefaultTypeInternal;
extern LoadBalancerSettingsDefaultTypeInternal _LoadBalancerSettings_default_instance_;
class LoadBalancerSettings_ConsistentHashLB;
class LoadBalancerSettings_ConsistentHashLBDefaultTypeInternal;
extern LoadBalancerSettings_ConsistentHashLBDefaultTypeInternal _LoadBalancerSettings_ConsistentHashLB_default_instance_;
class LoadBalancerSettings_ConsistentHashLB_HTTPCookie;
class LoadBalancerSettings_ConsistentHashLB_HTTPCookieDefaultTypeInternal;
extern LoadBalancerSettings_ConsistentHashLB_HTTPCookieDefaultTypeInternal _LoadBalancerSettings_ConsistentHashLB_HTTPCookie_default_instance_;
class OutlierDetection;
class OutlierDetectionDefaultTypeInternal;
extern OutlierDetectionDefaultTypeInternal _OutlierDetection_default_instance_;
class Subset;
class SubsetDefaultTypeInternal;
extern SubsetDefaultTypeInternal _Subset_default_instance_;
class Subset_LabelsEntry_DoNotUse;
class Subset_LabelsEntry_DoNotUseDefaultTypeInternal;
extern Subset_LabelsEntry_DoNotUseDefaultTypeInternal _Subset_LabelsEntry_DoNotUse_default_instance_;
class TLSSettings;
class TLSSettingsDefaultTypeInternal;
extern TLSSettingsDefaultTypeInternal _TLSSettings_default_instance_;
class TrafficPolicy;
class TrafficPolicyDefaultTypeInternal;
extern TrafficPolicyDefaultTypeInternal _TrafficPolicy_default_instance_;
class TrafficPolicy_PortTrafficPolicy;
class TrafficPolicy_PortTrafficPolicyDefaultTypeInternal;
extern TrafficPolicy_PortTrafficPolicyDefaultTypeInternal _TrafficPolicy_PortTrafficPolicy_default_instance_;
}  // namespace v1alpha3
}  // namespace networking
}  // namespace istio
namespace istio {
namespace networking {
namespace v1alpha3 {

enum LoadBalancerSettings_SimpleLB {
  LoadBalancerSettings_SimpleLB_ROUND_ROBIN = 0,
  LoadBalancerSettings_SimpleLB_LEAST_CONN = 1,
  LoadBalancerSettings_SimpleLB_RANDOM = 2,
  LoadBalancerSettings_SimpleLB_PASSTHROUGH = 3,
  LoadBalancerSettings_SimpleLB_LoadBalancerSettings_SimpleLB_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LoadBalancerSettings_SimpleLB_LoadBalancerSettings_SimpleLB_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool LoadBalancerSettings_SimpleLB_IsValid(int value);
const LoadBalancerSettings_SimpleLB LoadBalancerSettings_SimpleLB_SimpleLB_MIN = LoadBalancerSettings_SimpleLB_ROUND_ROBIN;
const LoadBalancerSettings_SimpleLB LoadBalancerSettings_SimpleLB_SimpleLB_MAX = LoadBalancerSettings_SimpleLB_PASSTHROUGH;
const int LoadBalancerSettings_SimpleLB_SimpleLB_ARRAYSIZE = LoadBalancerSettings_SimpleLB_SimpleLB_MAX + 1;

const ::google::protobuf::EnumDescriptor* LoadBalancerSettings_SimpleLB_descriptor();
inline const ::std::string& LoadBalancerSettings_SimpleLB_Name(LoadBalancerSettings_SimpleLB value) {
  return ::google::protobuf::internal::NameOfEnum(
    LoadBalancerSettings_SimpleLB_descriptor(), value);
}
inline bool LoadBalancerSettings_SimpleLB_Parse(
    const ::std::string& name, LoadBalancerSettings_SimpleLB* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LoadBalancerSettings_SimpleLB>(
    LoadBalancerSettings_SimpleLB_descriptor(), name, value);
}
enum TLSSettings_TLSmode {
  TLSSettings_TLSmode_DISABLE = 0,
  TLSSettings_TLSmode_SIMPLE = 1,
  TLSSettings_TLSmode_MUTUAL = 2,
  TLSSettings_TLSmode_ISTIO_MUTUAL = 3,
  TLSSettings_TLSmode_TLSSettings_TLSmode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TLSSettings_TLSmode_TLSSettings_TLSmode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TLSSettings_TLSmode_IsValid(int value);
const TLSSettings_TLSmode TLSSettings_TLSmode_TLSmode_MIN = TLSSettings_TLSmode_DISABLE;
const TLSSettings_TLSmode TLSSettings_TLSmode_TLSmode_MAX = TLSSettings_TLSmode_ISTIO_MUTUAL;
const int TLSSettings_TLSmode_TLSmode_ARRAYSIZE = TLSSettings_TLSmode_TLSmode_MAX + 1;

const ::google::protobuf::EnumDescriptor* TLSSettings_TLSmode_descriptor();
inline const ::std::string& TLSSettings_TLSmode_Name(TLSSettings_TLSmode value) {
  return ::google::protobuf::internal::NameOfEnum(
    TLSSettings_TLSmode_descriptor(), value);
}
inline bool TLSSettings_TLSmode_Parse(
    const ::std::string& name, TLSSettings_TLSmode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TLSSettings_TLSmode>(
    TLSSettings_TLSmode_descriptor(), name, value);
}
// ===================================================================

class DestinationRule : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:istio.networking.v1alpha3.DestinationRule) */ {
 public:
  DestinationRule();
  virtual ~DestinationRule();

  DestinationRule(const DestinationRule& from);

  inline DestinationRule& operator=(const DestinationRule& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DestinationRule(DestinationRule&& from) noexcept
    : DestinationRule() {
    *this = ::std::move(from);
  }

  inline DestinationRule& operator=(DestinationRule&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DestinationRule& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DestinationRule* internal_default_instance() {
    return reinterpret_cast<const DestinationRule*>(
               &_DestinationRule_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(DestinationRule* other);
  friend void swap(DestinationRule& a, DestinationRule& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DestinationRule* New() const PROTOBUF_FINAL { return New(NULL); }

  DestinationRule* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DestinationRule& from);
  void MergeFrom(const DestinationRule& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DestinationRule* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .istio.networking.v1alpha3.Subset subsets = 3;
  int subsets_size() const;
  void clear_subsets();
  static const int kSubsetsFieldNumber = 3;
  const ::istio::networking::v1alpha3::Subset& subsets(int index) const;
  ::istio::networking::v1alpha3::Subset* mutable_subsets(int index);
  ::istio::networking::v1alpha3::Subset* add_subsets();
  ::google::protobuf::RepeatedPtrField< ::istio::networking::v1alpha3::Subset >*
      mutable_subsets();
  const ::google::protobuf::RepeatedPtrField< ::istio::networking::v1alpha3::Subset >&
      subsets() const;

  // repeated string export_to = 4;
  int export_to_size() const;
  void clear_export_to();
  static const int kExportToFieldNumber = 4;
  const ::std::string& export_to(int index) const;
  ::std::string* mutable_export_to(int index);
  void set_export_to(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_export_to(int index, ::std::string&& value);
  #endif
  void set_export_to(int index, const char* value);
  void set_export_to(int index, const char* value, size_t size);
  ::std::string* add_export_to();
  void add_export_to(const ::std::string& value);
  #if LANG_CXX11
  void add_export_to(::std::string&& value);
  #endif
  void add_export_to(const char* value);
  void add_export_to(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& export_to() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_export_to();

  // string host = 1;
  void clear_host();
  static const int kHostFieldNumber = 1;
  const ::std::string& host() const;
  void set_host(const ::std::string& value);
  #if LANG_CXX11
  void set_host(::std::string&& value);
  #endif
  void set_host(const char* value);
  void set_host(const char* value, size_t size);
  ::std::string* mutable_host();
  ::std::string* release_host();
  void set_allocated_host(::std::string* host);

  // .istio.networking.v1alpha3.TrafficPolicy traffic_policy = 2;
  bool has_traffic_policy() const;
  void clear_traffic_policy();
  static const int kTrafficPolicyFieldNumber = 2;
  const ::istio::networking::v1alpha3::TrafficPolicy& traffic_policy() const;
  ::istio::networking::v1alpha3::TrafficPolicy* release_traffic_policy();
  ::istio::networking::v1alpha3::TrafficPolicy* mutable_traffic_policy();
  void set_allocated_traffic_policy(::istio::networking::v1alpha3::TrafficPolicy* traffic_policy);

  // @@protoc_insertion_point(class_scope:istio.networking.v1alpha3.DestinationRule)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::istio::networking::v1alpha3::Subset > subsets_;
  ::google::protobuf::RepeatedPtrField< ::std::string> export_to_;
  ::google::protobuf::internal::ArenaStringPtr host_;
  ::istio::networking::v1alpha3::TrafficPolicy* traffic_policy_;
  mutable int _cached_size_;
  friend struct ::protobuf_networking_2fv1alpha3_2fdestination_5frule_2eproto::TableStruct;
  friend void ::protobuf_networking_2fv1alpha3_2fdestination_5frule_2eproto::InitDefaultsDestinationRuleImpl();
};
// -------------------------------------------------------------------

class TrafficPolicy_PortTrafficPolicy : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:istio.networking.v1alpha3.TrafficPolicy.PortTrafficPolicy) */ {
 public:
  TrafficPolicy_PortTrafficPolicy();
  virtual ~TrafficPolicy_PortTrafficPolicy();

  TrafficPolicy_PortTrafficPolicy(const TrafficPolicy_PortTrafficPolicy& from);

  inline TrafficPolicy_PortTrafficPolicy& operator=(const TrafficPolicy_PortTrafficPolicy& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrafficPolicy_PortTrafficPolicy(TrafficPolicy_PortTrafficPolicy&& from) noexcept
    : TrafficPolicy_PortTrafficPolicy() {
    *this = ::std::move(from);
  }

  inline TrafficPolicy_PortTrafficPolicy& operator=(TrafficPolicy_PortTrafficPolicy&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficPolicy_PortTrafficPolicy& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficPolicy_PortTrafficPolicy* internal_default_instance() {
    return reinterpret_cast<const TrafficPolicy_PortTrafficPolicy*>(
               &_TrafficPolicy_PortTrafficPolicy_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(TrafficPolicy_PortTrafficPolicy* other);
  friend void swap(TrafficPolicy_PortTrafficPolicy& a, TrafficPolicy_PortTrafficPolicy& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrafficPolicy_PortTrafficPolicy* New() const PROTOBUF_FINAL { return New(NULL); }

  TrafficPolicy_PortTrafficPolicy* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TrafficPolicy_PortTrafficPolicy& from);
  void MergeFrom(const TrafficPolicy_PortTrafficPolicy& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TrafficPolicy_PortTrafficPolicy* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .istio.networking.v1alpha3.PortSelector port = 1;
  bool has_port() const;
  void clear_port();
  static const int kPortFieldNumber = 1;
  const ::istio::networking::v1alpha3::PortSelector& port() const;
  ::istio::networking::v1alpha3::PortSelector* release_port();
  ::istio::networking::v1alpha3::PortSelector* mutable_port();
  void set_allocated_port(::istio::networking::v1alpha3::PortSelector* port);

  // .istio.networking.v1alpha3.LoadBalancerSettings load_balancer = 2;
  bool has_load_balancer() const;
  void clear_load_balancer();
  static const int kLoadBalancerFieldNumber = 2;
  const ::istio::networking::v1alpha3::LoadBalancerSettings& load_balancer() const;
  ::istio::networking::v1alpha3::LoadBalancerSettings* release_load_balancer();
  ::istio::networking::v1alpha3::LoadBalancerSettings* mutable_load_balancer();
  void set_allocated_load_balancer(::istio::networking::v1alpha3::LoadBalancerSettings* load_balancer);

  // .istio.networking.v1alpha3.ConnectionPoolSettings connection_pool = 3;
  bool has_connection_pool() const;
  void clear_connection_pool();
  static const int kConnectionPoolFieldNumber = 3;
  const ::istio::networking::v1alpha3::ConnectionPoolSettings& connection_pool() const;
  ::istio::networking::v1alpha3::ConnectionPoolSettings* release_connection_pool();
  ::istio::networking::v1alpha3::ConnectionPoolSettings* mutable_connection_pool();
  void set_allocated_connection_pool(::istio::networking::v1alpha3::ConnectionPoolSettings* connection_pool);

  // .istio.networking.v1alpha3.OutlierDetection outlier_detection = 4;
  bool has_outlier_detection() const;
  void clear_outlier_detection();
  static const int kOutlierDetectionFieldNumber = 4;
  const ::istio::networking::v1alpha3::OutlierDetection& outlier_detection() const;
  ::istio::networking::v1alpha3::OutlierDetection* release_outlier_detection();
  ::istio::networking::v1alpha3::OutlierDetection* mutable_outlier_detection();
  void set_allocated_outlier_detection(::istio::networking::v1alpha3::OutlierDetection* outlier_detection);

  // .istio.networking.v1alpha3.TLSSettings tls = 5;
  bool has_tls() const;
  void clear_tls();
  static const int kTlsFieldNumber = 5;
  const ::istio::networking::v1alpha3::TLSSettings& tls() const;
  ::istio::networking::v1alpha3::TLSSettings* release_tls();
  ::istio::networking::v1alpha3::TLSSettings* mutable_tls();
  void set_allocated_tls(::istio::networking::v1alpha3::TLSSettings* tls);

  // @@protoc_insertion_point(class_scope:istio.networking.v1alpha3.TrafficPolicy.PortTrafficPolicy)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::istio::networking::v1alpha3::PortSelector* port_;
  ::istio::networking::v1alpha3::LoadBalancerSettings* load_balancer_;
  ::istio::networking::v1alpha3::ConnectionPoolSettings* connection_pool_;
  ::istio::networking::v1alpha3::OutlierDetection* outlier_detection_;
  ::istio::networking::v1alpha3::TLSSettings* tls_;
  mutable int _cached_size_;
  friend struct ::protobuf_networking_2fv1alpha3_2fdestination_5frule_2eproto::TableStruct;
  friend void ::protobuf_networking_2fv1alpha3_2fdestination_5frule_2eproto::InitDefaultsTrafficPolicy_PortTrafficPolicyImpl();
};
// -------------------------------------------------------------------

class TrafficPolicy : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:istio.networking.v1alpha3.TrafficPolicy) */ {
 public:
  TrafficPolicy();
  virtual ~TrafficPolicy();

  TrafficPolicy(const TrafficPolicy& from);

  inline TrafficPolicy& operator=(const TrafficPolicy& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrafficPolicy(TrafficPolicy&& from) noexcept
    : TrafficPolicy() {
    *this = ::std::move(from);
  }

  inline TrafficPolicy& operator=(TrafficPolicy&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficPolicy& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficPolicy* internal_default_instance() {
    return reinterpret_cast<const TrafficPolicy*>(
               &_TrafficPolicy_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(TrafficPolicy* other);
  friend void swap(TrafficPolicy& a, TrafficPolicy& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrafficPolicy* New() const PROTOBUF_FINAL { return New(NULL); }

  TrafficPolicy* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TrafficPolicy& from);
  void MergeFrom(const TrafficPolicy& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TrafficPolicy* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef TrafficPolicy_PortTrafficPolicy PortTrafficPolicy;

  // accessors -------------------------------------------------------

  // repeated .istio.networking.v1alpha3.TrafficPolicy.PortTrafficPolicy port_level_settings = 5;
  int port_level_settings_size() const;
  void clear_port_level_settings();
  static const int kPortLevelSettingsFieldNumber = 5;
  const ::istio::networking::v1alpha3::TrafficPolicy_PortTrafficPolicy& port_level_settings(int index) const;
  ::istio::networking::v1alpha3::TrafficPolicy_PortTrafficPolicy* mutable_port_level_settings(int index);
  ::istio::networking::v1alpha3::TrafficPolicy_PortTrafficPolicy* add_port_level_settings();
  ::google::protobuf::RepeatedPtrField< ::istio::networking::v1alpha3::TrafficPolicy_PortTrafficPolicy >*
      mutable_port_level_settings();
  const ::google::protobuf::RepeatedPtrField< ::istio::networking::v1alpha3::TrafficPolicy_PortTrafficPolicy >&
      port_level_settings() const;

  // .istio.networking.v1alpha3.LoadBalancerSettings load_balancer = 1;
  bool has_load_balancer() const;
  void clear_load_balancer();
  static const int kLoadBalancerFieldNumber = 1;
  const ::istio::networking::v1alpha3::LoadBalancerSettings& load_balancer() const;
  ::istio::networking::v1alpha3::LoadBalancerSettings* release_load_balancer();
  ::istio::networking::v1alpha3::LoadBalancerSettings* mutable_load_balancer();
  void set_allocated_load_balancer(::istio::networking::v1alpha3::LoadBalancerSettings* load_balancer);

  // .istio.networking.v1alpha3.ConnectionPoolSettings connection_pool = 2;
  bool has_connection_pool() const;
  void clear_connection_pool();
  static const int kConnectionPoolFieldNumber = 2;
  const ::istio::networking::v1alpha3::ConnectionPoolSettings& connection_pool() const;
  ::istio::networking::v1alpha3::ConnectionPoolSettings* release_connection_pool();
  ::istio::networking::v1alpha3::ConnectionPoolSettings* mutable_connection_pool();
  void set_allocated_connection_pool(::istio::networking::v1alpha3::ConnectionPoolSettings* connection_pool);

  // .istio.networking.v1alpha3.OutlierDetection outlier_detection = 3;
  bool has_outlier_detection() const;
  void clear_outlier_detection();
  static const int kOutlierDetectionFieldNumber = 3;
  const ::istio::networking::v1alpha3::OutlierDetection& outlier_detection() const;
  ::istio::networking::v1alpha3::OutlierDetection* release_outlier_detection();
  ::istio::networking::v1alpha3::OutlierDetection* mutable_outlier_detection();
  void set_allocated_outlier_detection(::istio::networking::v1alpha3::OutlierDetection* outlier_detection);

  // .istio.networking.v1alpha3.TLSSettings tls = 4;
  bool has_tls() const;
  void clear_tls();
  static const int kTlsFieldNumber = 4;
  const ::istio::networking::v1alpha3::TLSSettings& tls() const;
  ::istio::networking::v1alpha3::TLSSettings* release_tls();
  ::istio::networking::v1alpha3::TLSSettings* mutable_tls();
  void set_allocated_tls(::istio::networking::v1alpha3::TLSSettings* tls);

  // @@protoc_insertion_point(class_scope:istio.networking.v1alpha3.TrafficPolicy)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::istio::networking::v1alpha3::TrafficPolicy_PortTrafficPolicy > port_level_settings_;
  ::istio::networking::v1alpha3::LoadBalancerSettings* load_balancer_;
  ::istio::networking::v1alpha3::ConnectionPoolSettings* connection_pool_;
  ::istio::networking::v1alpha3::OutlierDetection* outlier_detection_;
  ::istio::networking::v1alpha3::TLSSettings* tls_;
  mutable int _cached_size_;
  friend struct ::protobuf_networking_2fv1alpha3_2fdestination_5frule_2eproto::TableStruct;
  friend void ::protobuf_networking_2fv1alpha3_2fdestination_5frule_2eproto::InitDefaultsTrafficPolicyImpl();
};
// -------------------------------------------------------------------

class Subset_LabelsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<Subset_LabelsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<Subset_LabelsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  Subset_LabelsEntry_DoNotUse();
  Subset_LabelsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const Subset_LabelsEntry_DoNotUse& other);
  static const Subset_LabelsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Subset_LabelsEntry_DoNotUse*>(&_Subset_LabelsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class Subset : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:istio.networking.v1alpha3.Subset) */ {
 public:
  Subset();
  virtual ~Subset();

  Subset(const Subset& from);

  inline Subset& operator=(const Subset& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Subset(Subset&& from) noexcept
    : Subset() {
    *this = ::std::move(from);
  }

  inline Subset& operator=(Subset&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Subset& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Subset* internal_default_instance() {
    return reinterpret_cast<const Subset*>(
               &_Subset_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Subset* other);
  friend void swap(Subset& a, Subset& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Subset* New() const PROTOBUF_FINAL { return New(NULL); }

  Subset* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Subset& from);
  void MergeFrom(const Subset& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Subset* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> labels = 2;
  int labels_size() const;
  void clear_labels();
  static const int kLabelsFieldNumber = 2;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      labels() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_labels();

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .istio.networking.v1alpha3.TrafficPolicy traffic_policy = 3;
  bool has_traffic_policy() const;
  void clear_traffic_policy();
  static const int kTrafficPolicyFieldNumber = 3;
  const ::istio::networking::v1alpha3::TrafficPolicy& traffic_policy() const;
  ::istio::networking::v1alpha3::TrafficPolicy* release_traffic_policy();
  ::istio::networking::v1alpha3::TrafficPolicy* mutable_traffic_policy();
  void set_allocated_traffic_policy(::istio::networking::v1alpha3::TrafficPolicy* traffic_policy);

  // @@protoc_insertion_point(class_scope:istio.networking.v1alpha3.Subset)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      Subset_LabelsEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > labels_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::istio::networking::v1alpha3::TrafficPolicy* traffic_policy_;
  mutable int _cached_size_;
  friend struct ::protobuf_networking_2fv1alpha3_2fdestination_5frule_2eproto::TableStruct;
  friend void ::protobuf_networking_2fv1alpha3_2fdestination_5frule_2eproto::InitDefaultsSubsetImpl();
};
// -------------------------------------------------------------------

class LoadBalancerSettings_ConsistentHashLB_HTTPCookie : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB.HTTPCookie) */ {
 public:
  LoadBalancerSettings_ConsistentHashLB_HTTPCookie();
  virtual ~LoadBalancerSettings_ConsistentHashLB_HTTPCookie();

  LoadBalancerSettings_ConsistentHashLB_HTTPCookie(const LoadBalancerSettings_ConsistentHashLB_HTTPCookie& from);

  inline LoadBalancerSettings_ConsistentHashLB_HTTPCookie& operator=(const LoadBalancerSettings_ConsistentHashLB_HTTPCookie& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoadBalancerSettings_ConsistentHashLB_HTTPCookie(LoadBalancerSettings_ConsistentHashLB_HTTPCookie&& from) noexcept
    : LoadBalancerSettings_ConsistentHashLB_HTTPCookie() {
    *this = ::std::move(from);
  }

  inline LoadBalancerSettings_ConsistentHashLB_HTTPCookie& operator=(LoadBalancerSettings_ConsistentHashLB_HTTPCookie&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoadBalancerSettings_ConsistentHashLB_HTTPCookie& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoadBalancerSettings_ConsistentHashLB_HTTPCookie* internal_default_instance() {
    return reinterpret_cast<const LoadBalancerSettings_ConsistentHashLB_HTTPCookie*>(
               &_LoadBalancerSettings_ConsistentHashLB_HTTPCookie_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(LoadBalancerSettings_ConsistentHashLB_HTTPCookie* other);
  friend void swap(LoadBalancerSettings_ConsistentHashLB_HTTPCookie& a, LoadBalancerSettings_ConsistentHashLB_HTTPCookie& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoadBalancerSettings_ConsistentHashLB_HTTPCookie* New() const PROTOBUF_FINAL { return New(NULL); }

  LoadBalancerSettings_ConsistentHashLB_HTTPCookie* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LoadBalancerSettings_ConsistentHashLB_HTTPCookie& from);
  void MergeFrom(const LoadBalancerSettings_ConsistentHashLB_HTTPCookie& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LoadBalancerSettings_ConsistentHashLB_HTTPCookie* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string path = 2;
  void clear_path();
  static const int kPathFieldNumber = 2;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // .google.protobuf.Duration ttl = 3 [(.gogoproto.stdduration) = true];
  bool has_ttl() const;
  void clear_ttl();
  static const int kTtlFieldNumber = 3;
  const ::google::protobuf::Duration& ttl() const;
  ::google::protobuf::Duration* release_ttl();
  ::google::protobuf::Duration* mutable_ttl();
  void set_allocated_ttl(::google::protobuf::Duration* ttl);

  // @@protoc_insertion_point(class_scope:istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB.HTTPCookie)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::Duration* ttl_;
  mutable int _cached_size_;
  friend struct ::protobuf_networking_2fv1alpha3_2fdestination_5frule_2eproto::TableStruct;
  friend void ::protobuf_networking_2fv1alpha3_2fdestination_5frule_2eproto::InitDefaultsLoadBalancerSettings_ConsistentHashLB_HTTPCookieImpl();
};
// -------------------------------------------------------------------

class LoadBalancerSettings_ConsistentHashLB : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB) */ {
 public:
  LoadBalancerSettings_ConsistentHashLB();
  virtual ~LoadBalancerSettings_ConsistentHashLB();

  LoadBalancerSettings_ConsistentHashLB(const LoadBalancerSettings_ConsistentHashLB& from);

  inline LoadBalancerSettings_ConsistentHashLB& operator=(const LoadBalancerSettings_ConsistentHashLB& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoadBalancerSettings_ConsistentHashLB(LoadBalancerSettings_ConsistentHashLB&& from) noexcept
    : LoadBalancerSettings_ConsistentHashLB() {
    *this = ::std::move(from);
  }

  inline LoadBalancerSettings_ConsistentHashLB& operator=(LoadBalancerSettings_ConsistentHashLB&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoadBalancerSettings_ConsistentHashLB& default_instance();

  enum HashKeyCase {
    kHttpHeaderName = 1,
    kHttpCookie = 2,
    kUseSourceIp = 3,
    HASH_KEY_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoadBalancerSettings_ConsistentHashLB* internal_default_instance() {
    return reinterpret_cast<const LoadBalancerSettings_ConsistentHashLB*>(
               &_LoadBalancerSettings_ConsistentHashLB_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(LoadBalancerSettings_ConsistentHashLB* other);
  friend void swap(LoadBalancerSettings_ConsistentHashLB& a, LoadBalancerSettings_ConsistentHashLB& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoadBalancerSettings_ConsistentHashLB* New() const PROTOBUF_FINAL { return New(NULL); }

  LoadBalancerSettings_ConsistentHashLB* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LoadBalancerSettings_ConsistentHashLB& from);
  void MergeFrom(const LoadBalancerSettings_ConsistentHashLB& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LoadBalancerSettings_ConsistentHashLB* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef LoadBalancerSettings_ConsistentHashLB_HTTPCookie HTTPCookie;

  // accessors -------------------------------------------------------

  // uint64 minimum_ring_size = 4;
  void clear_minimum_ring_size();
  static const int kMinimumRingSizeFieldNumber = 4;
  ::google::protobuf::uint64 minimum_ring_size() const;
  void set_minimum_ring_size(::google::protobuf::uint64 value);

  // string http_header_name = 1;
  private:
  bool has_http_header_name() const;
  public:
  void clear_http_header_name();
  static const int kHttpHeaderNameFieldNumber = 1;
  const ::std::string& http_header_name() const;
  void set_http_header_name(const ::std::string& value);
  #if LANG_CXX11
  void set_http_header_name(::std::string&& value);
  #endif
  void set_http_header_name(const char* value);
  void set_http_header_name(const char* value, size_t size);
  ::std::string* mutable_http_header_name();
  ::std::string* release_http_header_name();
  void set_allocated_http_header_name(::std::string* http_header_name);

  // .istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB.HTTPCookie http_cookie = 2;
  bool has_http_cookie() const;
  void clear_http_cookie();
  static const int kHttpCookieFieldNumber = 2;
  const ::istio::networking::v1alpha3::LoadBalancerSettings_ConsistentHashLB_HTTPCookie& http_cookie() const;
  ::istio::networking::v1alpha3::LoadBalancerSettings_ConsistentHashLB_HTTPCookie* release_http_cookie();
  ::istio::networking::v1alpha3::LoadBalancerSettings_ConsistentHashLB_HTTPCookie* mutable_http_cookie();
  void set_allocated_http_cookie(::istio::networking::v1alpha3::LoadBalancerSettings_ConsistentHashLB_HTTPCookie* http_cookie);

  // bool use_source_ip = 3;
  private:
  bool has_use_source_ip() const;
  public:
  void clear_use_source_ip();
  static const int kUseSourceIpFieldNumber = 3;
  bool use_source_ip() const;
  void set_use_source_ip(bool value);

  HashKeyCase hash_key_case() const;
  // @@protoc_insertion_point(class_scope:istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB)
 private:
  void set_has_http_header_name();
  void set_has_http_cookie();
  void set_has_use_source_ip();

  inline bool has_hash_key() const;
  void clear_hash_key();
  inline void clear_has_hash_key();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 minimum_ring_size_;
  union HashKeyUnion {
    HashKeyUnion() {}
    ::google::protobuf::internal::ArenaStringPtr http_header_name_;
    ::istio::networking::v1alpha3::LoadBalancerSettings_ConsistentHashLB_HTTPCookie* http_cookie_;
    bool use_source_ip_;
  } hash_key_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_networking_2fv1alpha3_2fdestination_5frule_2eproto::TableStruct;
  friend void ::protobuf_networking_2fv1alpha3_2fdestination_5frule_2eproto::InitDefaultsLoadBalancerSettings_ConsistentHashLBImpl();
};
// -------------------------------------------------------------------

class LoadBalancerSettings : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:istio.networking.v1alpha3.LoadBalancerSettings) */ {
 public:
  LoadBalancerSettings();
  virtual ~LoadBalancerSettings();

  LoadBalancerSettings(const LoadBalancerSettings& from);

  inline LoadBalancerSettings& operator=(const LoadBalancerSettings& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoadBalancerSettings(LoadBalancerSettings&& from) noexcept
    : LoadBalancerSettings() {
    *this = ::std::move(from);
  }

  inline LoadBalancerSettings& operator=(LoadBalancerSettings&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoadBalancerSettings& default_instance();

  enum LbPolicyCase {
    kSimple = 1,
    kConsistentHash = 2,
    LB_POLICY_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoadBalancerSettings* internal_default_instance() {
    return reinterpret_cast<const LoadBalancerSettings*>(
               &_LoadBalancerSettings_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(LoadBalancerSettings* other);
  friend void swap(LoadBalancerSettings& a, LoadBalancerSettings& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoadBalancerSettings* New() const PROTOBUF_FINAL { return New(NULL); }

  LoadBalancerSettings* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LoadBalancerSettings& from);
  void MergeFrom(const LoadBalancerSettings& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LoadBalancerSettings* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef LoadBalancerSettings_ConsistentHashLB ConsistentHashLB;

  typedef LoadBalancerSettings_SimpleLB SimpleLB;
  static const SimpleLB ROUND_ROBIN =
    LoadBalancerSettings_SimpleLB_ROUND_ROBIN;
  static const SimpleLB LEAST_CONN =
    LoadBalancerSettings_SimpleLB_LEAST_CONN;
  static const SimpleLB RANDOM =
    LoadBalancerSettings_SimpleLB_RANDOM;
  static const SimpleLB PASSTHROUGH =
    LoadBalancerSettings_SimpleLB_PASSTHROUGH;
  static inline bool SimpleLB_IsValid(int value) {
    return LoadBalancerSettings_SimpleLB_IsValid(value);
  }
  static const SimpleLB SimpleLB_MIN =
    LoadBalancerSettings_SimpleLB_SimpleLB_MIN;
  static const SimpleLB SimpleLB_MAX =
    LoadBalancerSettings_SimpleLB_SimpleLB_MAX;
  static const int SimpleLB_ARRAYSIZE =
    LoadBalancerSettings_SimpleLB_SimpleLB_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SimpleLB_descriptor() {
    return LoadBalancerSettings_SimpleLB_descriptor();
  }
  static inline const ::std::string& SimpleLB_Name(SimpleLB value) {
    return LoadBalancerSettings_SimpleLB_Name(value);
  }
  static inline bool SimpleLB_Parse(const ::std::string& name,
      SimpleLB* value) {
    return LoadBalancerSettings_SimpleLB_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .istio.networking.v1alpha3.LoadBalancerSettings.SimpleLB simple = 1;
  private:
  bool has_simple() const;
  public:
  void clear_simple();
  static const int kSimpleFieldNumber = 1;
  ::istio::networking::v1alpha3::LoadBalancerSettings_SimpleLB simple() const;
  void set_simple(::istio::networking::v1alpha3::LoadBalancerSettings_SimpleLB value);

  // .istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB consistent_hash = 2;
  bool has_consistent_hash() const;
  void clear_consistent_hash();
  static const int kConsistentHashFieldNumber = 2;
  const ::istio::networking::v1alpha3::LoadBalancerSettings_ConsistentHashLB& consistent_hash() const;
  ::istio::networking::v1alpha3::LoadBalancerSettings_ConsistentHashLB* release_consistent_hash();
  ::istio::networking::v1alpha3::LoadBalancerSettings_ConsistentHashLB* mutable_consistent_hash();
  void set_allocated_consistent_hash(::istio::networking::v1alpha3::LoadBalancerSettings_ConsistentHashLB* consistent_hash);

  LbPolicyCase lb_policy_case() const;
  // @@protoc_insertion_point(class_scope:istio.networking.v1alpha3.LoadBalancerSettings)
 private:
  void set_has_simple();
  void set_has_consistent_hash();

  inline bool has_lb_policy() const;
  void clear_lb_policy();
  inline void clear_has_lb_policy();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union LbPolicyUnion {
    LbPolicyUnion() {}
    int simple_;
    ::istio::networking::v1alpha3::LoadBalancerSettings_ConsistentHashLB* consistent_hash_;
  } lb_policy_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_networking_2fv1alpha3_2fdestination_5frule_2eproto::TableStruct;
  friend void ::protobuf_networking_2fv1alpha3_2fdestination_5frule_2eproto::InitDefaultsLoadBalancerSettingsImpl();
};
// -------------------------------------------------------------------

class ConnectionPoolSettings_TCPSettings_TcpKeepalive : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:istio.networking.v1alpha3.ConnectionPoolSettings.TCPSettings.TcpKeepalive) */ {
 public:
  ConnectionPoolSettings_TCPSettings_TcpKeepalive();
  virtual ~ConnectionPoolSettings_TCPSettings_TcpKeepalive();

  ConnectionPoolSettings_TCPSettings_TcpKeepalive(const ConnectionPoolSettings_TCPSettings_TcpKeepalive& from);

  inline ConnectionPoolSettings_TCPSettings_TcpKeepalive& operator=(const ConnectionPoolSettings_TCPSettings_TcpKeepalive& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConnectionPoolSettings_TCPSettings_TcpKeepalive(ConnectionPoolSettings_TCPSettings_TcpKeepalive&& from) noexcept
    : ConnectionPoolSettings_TCPSettings_TcpKeepalive() {
    *this = ::std::move(from);
  }

  inline ConnectionPoolSettings_TCPSettings_TcpKeepalive& operator=(ConnectionPoolSettings_TCPSettings_TcpKeepalive&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnectionPoolSettings_TCPSettings_TcpKeepalive& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConnectionPoolSettings_TCPSettings_TcpKeepalive* internal_default_instance() {
    return reinterpret_cast<const ConnectionPoolSettings_TCPSettings_TcpKeepalive*>(
               &_ConnectionPoolSettings_TCPSettings_TcpKeepalive_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(ConnectionPoolSettings_TCPSettings_TcpKeepalive* other);
  friend void swap(ConnectionPoolSettings_TCPSettings_TcpKeepalive& a, ConnectionPoolSettings_TCPSettings_TcpKeepalive& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConnectionPoolSettings_TCPSettings_TcpKeepalive* New() const PROTOBUF_FINAL { return New(NULL); }

  ConnectionPoolSettings_TCPSettings_TcpKeepalive* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ConnectionPoolSettings_TCPSettings_TcpKeepalive& from);
  void MergeFrom(const ConnectionPoolSettings_TCPSettings_TcpKeepalive& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ConnectionPoolSettings_TCPSettings_TcpKeepalive* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.protobuf.Duration time = 2;
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 2;
  const ::google::protobuf::Duration& time() const;
  ::google::protobuf::Duration* release_time();
  ::google::protobuf::Duration* mutable_time();
  void set_allocated_time(::google::protobuf::Duration* time);

  // .google.protobuf.Duration interval = 3;
  bool has_interval() const;
  void clear_interval();
  static const int kIntervalFieldNumber = 3;
  const ::google::protobuf::Duration& interval() const;
  ::google::protobuf::Duration* release_interval();
  ::google::protobuf::Duration* mutable_interval();
  void set_allocated_interval(::google::protobuf::Duration* interval);

  // uint32 probes = 1;
  void clear_probes();
  static const int kProbesFieldNumber = 1;
  ::google::protobuf::uint32 probes() const;
  void set_probes(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:istio.networking.v1alpha3.ConnectionPoolSettings.TCPSettings.TcpKeepalive)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::Duration* time_;
  ::google::protobuf::Duration* interval_;
  ::google::protobuf::uint32 probes_;
  mutable int _cached_size_;
  friend struct ::protobuf_networking_2fv1alpha3_2fdestination_5frule_2eproto::TableStruct;
  friend void ::protobuf_networking_2fv1alpha3_2fdestination_5frule_2eproto::InitDefaultsConnectionPoolSettings_TCPSettings_TcpKeepaliveImpl();
};
// -------------------------------------------------------------------

class ConnectionPoolSettings_TCPSettings : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:istio.networking.v1alpha3.ConnectionPoolSettings.TCPSettings) */ {
 public:
  ConnectionPoolSettings_TCPSettings();
  virtual ~ConnectionPoolSettings_TCPSettings();

  ConnectionPoolSettings_TCPSettings(const ConnectionPoolSettings_TCPSettings& from);

  inline ConnectionPoolSettings_TCPSettings& operator=(const ConnectionPoolSettings_TCPSettings& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConnectionPoolSettings_TCPSettings(ConnectionPoolSettings_TCPSettings&& from) noexcept
    : ConnectionPoolSettings_TCPSettings() {
    *this = ::std::move(from);
  }

  inline ConnectionPoolSettings_TCPSettings& operator=(ConnectionPoolSettings_TCPSettings&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnectionPoolSettings_TCPSettings& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConnectionPoolSettings_TCPSettings* internal_default_instance() {
    return reinterpret_cast<const ConnectionPoolSettings_TCPSettings*>(
               &_ConnectionPoolSettings_TCPSettings_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(ConnectionPoolSettings_TCPSettings* other);
  friend void swap(ConnectionPoolSettings_TCPSettings& a, ConnectionPoolSettings_TCPSettings& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConnectionPoolSettings_TCPSettings* New() const PROTOBUF_FINAL { return New(NULL); }

  ConnectionPoolSettings_TCPSettings* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ConnectionPoolSettings_TCPSettings& from);
  void MergeFrom(const ConnectionPoolSettings_TCPSettings& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ConnectionPoolSettings_TCPSettings* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ConnectionPoolSettings_TCPSettings_TcpKeepalive TcpKeepalive;

  // accessors -------------------------------------------------------

  // .google.protobuf.Duration connect_timeout = 2;
  bool has_connect_timeout() const;
  void clear_connect_timeout();
  static const int kConnectTimeoutFieldNumber = 2;
  const ::google::protobuf::Duration& connect_timeout() const;
  ::google::protobuf::Duration* release_connect_timeout();
  ::google::protobuf::Duration* mutable_connect_timeout();
  void set_allocated_connect_timeout(::google::protobuf::Duration* connect_timeout);

  // .istio.networking.v1alpha3.ConnectionPoolSettings.TCPSettings.TcpKeepalive tcp_keepalive = 3;
  bool has_tcp_keepalive() const;
  void clear_tcp_keepalive();
  static const int kTcpKeepaliveFieldNumber = 3;
  const ::istio::networking::v1alpha3::ConnectionPoolSettings_TCPSettings_TcpKeepalive& tcp_keepalive() const;
  ::istio::networking::v1alpha3::ConnectionPoolSettings_TCPSettings_TcpKeepalive* release_tcp_keepalive();
  ::istio::networking::v1alpha3::ConnectionPoolSettings_TCPSettings_TcpKeepalive* mutable_tcp_keepalive();
  void set_allocated_tcp_keepalive(::istio::networking::v1alpha3::ConnectionPoolSettings_TCPSettings_TcpKeepalive* tcp_keepalive);

  // int32 max_connections = 1;
  void clear_max_connections();
  static const int kMaxConnectionsFieldNumber = 1;
  ::google::protobuf::int32 max_connections() const;
  void set_max_connections(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:istio.networking.v1alpha3.ConnectionPoolSettings.TCPSettings)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::Duration* connect_timeout_;
  ::istio::networking::v1alpha3::ConnectionPoolSettings_TCPSettings_TcpKeepalive* tcp_keepalive_;
  ::google::protobuf::int32 max_connections_;
  mutable int _cached_size_;
  friend struct ::protobuf_networking_2fv1alpha3_2fdestination_5frule_2eproto::TableStruct;
  friend void ::protobuf_networking_2fv1alpha3_2fdestination_5frule_2eproto::InitDefaultsConnectionPoolSettings_TCPSettingsImpl();
};
// -------------------------------------------------------------------

class ConnectionPoolSettings_HTTPSettings : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:istio.networking.v1alpha3.ConnectionPoolSettings.HTTPSettings) */ {
 public:
  ConnectionPoolSettings_HTTPSettings();
  virtual ~ConnectionPoolSettings_HTTPSettings();

  ConnectionPoolSettings_HTTPSettings(const ConnectionPoolSettings_HTTPSettings& from);

  inline ConnectionPoolSettings_HTTPSettings& operator=(const ConnectionPoolSettings_HTTPSettings& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConnectionPoolSettings_HTTPSettings(ConnectionPoolSettings_HTTPSettings&& from) noexcept
    : ConnectionPoolSettings_HTTPSettings() {
    *this = ::std::move(from);
  }

  inline ConnectionPoolSettings_HTTPSettings& operator=(ConnectionPoolSettings_HTTPSettings&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnectionPoolSettings_HTTPSettings& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConnectionPoolSettings_HTTPSettings* internal_default_instance() {
    return reinterpret_cast<const ConnectionPoolSettings_HTTPSettings*>(
               &_ConnectionPoolSettings_HTTPSettings_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(ConnectionPoolSettings_HTTPSettings* other);
  friend void swap(ConnectionPoolSettings_HTTPSettings& a, ConnectionPoolSettings_HTTPSettings& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConnectionPoolSettings_HTTPSettings* New() const PROTOBUF_FINAL { return New(NULL); }

  ConnectionPoolSettings_HTTPSettings* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ConnectionPoolSettings_HTTPSettings& from);
  void MergeFrom(const ConnectionPoolSettings_HTTPSettings& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ConnectionPoolSettings_HTTPSettings* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 http1_max_pending_requests = 1;
  void clear_http1_max_pending_requests();
  static const int kHttp1MaxPendingRequestsFieldNumber = 1;
  ::google::protobuf::int32 http1_max_pending_requests() const;
  void set_http1_max_pending_requests(::google::protobuf::int32 value);

  // int32 http2_max_requests = 2;
  void clear_http2_max_requests();
  static const int kHttp2MaxRequestsFieldNumber = 2;
  ::google::protobuf::int32 http2_max_requests() const;
  void set_http2_max_requests(::google::protobuf::int32 value);

  // int32 max_requests_per_connection = 3;
  void clear_max_requests_per_connection();
  static const int kMaxRequestsPerConnectionFieldNumber = 3;
  ::google::protobuf::int32 max_requests_per_connection() const;
  void set_max_requests_per_connection(::google::protobuf::int32 value);

  // int32 max_retries = 4;
  void clear_max_retries();
  static const int kMaxRetriesFieldNumber = 4;
  ::google::protobuf::int32 max_retries() const;
  void set_max_retries(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:istio.networking.v1alpha3.ConnectionPoolSettings.HTTPSettings)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 http1_max_pending_requests_;
  ::google::protobuf::int32 http2_max_requests_;
  ::google::protobuf::int32 max_requests_per_connection_;
  ::google::protobuf::int32 max_retries_;
  mutable int _cached_size_;
  friend struct ::protobuf_networking_2fv1alpha3_2fdestination_5frule_2eproto::TableStruct;
  friend void ::protobuf_networking_2fv1alpha3_2fdestination_5frule_2eproto::InitDefaultsConnectionPoolSettings_HTTPSettingsImpl();
};
// -------------------------------------------------------------------

class ConnectionPoolSettings : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:istio.networking.v1alpha3.ConnectionPoolSettings) */ {
 public:
  ConnectionPoolSettings();
  virtual ~ConnectionPoolSettings();

  ConnectionPoolSettings(const ConnectionPoolSettings& from);

  inline ConnectionPoolSettings& operator=(const ConnectionPoolSettings& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConnectionPoolSettings(ConnectionPoolSettings&& from) noexcept
    : ConnectionPoolSettings() {
    *this = ::std::move(from);
  }

  inline ConnectionPoolSettings& operator=(ConnectionPoolSettings&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnectionPoolSettings& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConnectionPoolSettings* internal_default_instance() {
    return reinterpret_cast<const ConnectionPoolSettings*>(
               &_ConnectionPoolSettings_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(ConnectionPoolSettings* other);
  friend void swap(ConnectionPoolSettings& a, ConnectionPoolSettings& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConnectionPoolSettings* New() const PROTOBUF_FINAL { return New(NULL); }

  ConnectionPoolSettings* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ConnectionPoolSettings& from);
  void MergeFrom(const ConnectionPoolSettings& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ConnectionPoolSettings* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ConnectionPoolSettings_TCPSettings TCPSettings;
  typedef ConnectionPoolSettings_HTTPSettings HTTPSettings;

  // accessors -------------------------------------------------------

  // .istio.networking.v1alpha3.ConnectionPoolSettings.TCPSettings tcp = 1;
  bool has_tcp() const;
  void clear_tcp();
  static const int kTcpFieldNumber = 1;
  const ::istio::networking::v1alpha3::ConnectionPoolSettings_TCPSettings& tcp() const;
  ::istio::networking::v1alpha3::ConnectionPoolSettings_TCPSettings* release_tcp();
  ::istio::networking::v1alpha3::ConnectionPoolSettings_TCPSettings* mutable_tcp();
  void set_allocated_tcp(::istio::networking::v1alpha3::ConnectionPoolSettings_TCPSettings* tcp);

  // .istio.networking.v1alpha3.ConnectionPoolSettings.HTTPSettings http = 2;
  bool has_http() const;
  void clear_http();
  static const int kHttpFieldNumber = 2;
  const ::istio::networking::v1alpha3::ConnectionPoolSettings_HTTPSettings& http() const;
  ::istio::networking::v1alpha3::ConnectionPoolSettings_HTTPSettings* release_http();
  ::istio::networking::v1alpha3::ConnectionPoolSettings_HTTPSettings* mutable_http();
  void set_allocated_http(::istio::networking::v1alpha3::ConnectionPoolSettings_HTTPSettings* http);

  // @@protoc_insertion_point(class_scope:istio.networking.v1alpha3.ConnectionPoolSettings)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::istio::networking::v1alpha3::ConnectionPoolSettings_TCPSettings* tcp_;
  ::istio::networking::v1alpha3::ConnectionPoolSettings_HTTPSettings* http_;
  mutable int _cached_size_;
  friend struct ::protobuf_networking_2fv1alpha3_2fdestination_5frule_2eproto::TableStruct;
  friend void ::protobuf_networking_2fv1alpha3_2fdestination_5frule_2eproto::InitDefaultsConnectionPoolSettingsImpl();
};
// -------------------------------------------------------------------

class OutlierDetection : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:istio.networking.v1alpha3.OutlierDetection) */ {
 public:
  OutlierDetection();
  virtual ~OutlierDetection();

  OutlierDetection(const OutlierDetection& from);

  inline OutlierDetection& operator=(const OutlierDetection& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OutlierDetection(OutlierDetection&& from) noexcept
    : OutlierDetection() {
    *this = ::std::move(from);
  }

  inline OutlierDetection& operator=(OutlierDetection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OutlierDetection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OutlierDetection* internal_default_instance() {
    return reinterpret_cast<const OutlierDetection*>(
               &_OutlierDetection_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(OutlierDetection* other);
  friend void swap(OutlierDetection& a, OutlierDetection& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OutlierDetection* New() const PROTOBUF_FINAL { return New(NULL); }

  OutlierDetection* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OutlierDetection& from);
  void MergeFrom(const OutlierDetection& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OutlierDetection* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.protobuf.Duration interval = 2;
  bool has_interval() const;
  void clear_interval();
  static const int kIntervalFieldNumber = 2;
  const ::google::protobuf::Duration& interval() const;
  ::google::protobuf::Duration* release_interval();
  ::google::protobuf::Duration* mutable_interval();
  void set_allocated_interval(::google::protobuf::Duration* interval);

  // .google.protobuf.Duration base_ejection_time = 3;
  bool has_base_ejection_time() const;
  void clear_base_ejection_time();
  static const int kBaseEjectionTimeFieldNumber = 3;
  const ::google::protobuf::Duration& base_ejection_time() const;
  ::google::protobuf::Duration* release_base_ejection_time();
  ::google::protobuf::Duration* mutable_base_ejection_time();
  void set_allocated_base_ejection_time(::google::protobuf::Duration* base_ejection_time);

  // int32 consecutive_errors = 1;
  void clear_consecutive_errors();
  static const int kConsecutiveErrorsFieldNumber = 1;
  ::google::protobuf::int32 consecutive_errors() const;
  void set_consecutive_errors(::google::protobuf::int32 value);

  // int32 max_ejection_percent = 4;
  void clear_max_ejection_percent();
  static const int kMaxEjectionPercentFieldNumber = 4;
  ::google::protobuf::int32 max_ejection_percent() const;
  void set_max_ejection_percent(::google::protobuf::int32 value);

  // int32 min_health_percent = 5;
  void clear_min_health_percent();
  static const int kMinHealthPercentFieldNumber = 5;
  ::google::protobuf::int32 min_health_percent() const;
  void set_min_health_percent(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:istio.networking.v1alpha3.OutlierDetection)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::Duration* interval_;
  ::google::protobuf::Duration* base_ejection_time_;
  ::google::protobuf::int32 consecutive_errors_;
  ::google::protobuf::int32 max_ejection_percent_;
  ::google::protobuf::int32 min_health_percent_;
  mutable int _cached_size_;
  friend struct ::protobuf_networking_2fv1alpha3_2fdestination_5frule_2eproto::TableStruct;
  friend void ::protobuf_networking_2fv1alpha3_2fdestination_5frule_2eproto::InitDefaultsOutlierDetectionImpl();
};
// -------------------------------------------------------------------

class TLSSettings : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:istio.networking.v1alpha3.TLSSettings) */ {
 public:
  TLSSettings();
  virtual ~TLSSettings();

  TLSSettings(const TLSSettings& from);

  inline TLSSettings& operator=(const TLSSettings& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TLSSettings(TLSSettings&& from) noexcept
    : TLSSettings() {
    *this = ::std::move(from);
  }

  inline TLSSettings& operator=(TLSSettings&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TLSSettings& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TLSSettings* internal_default_instance() {
    return reinterpret_cast<const TLSSettings*>(
               &_TLSSettings_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(TLSSettings* other);
  friend void swap(TLSSettings& a, TLSSettings& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TLSSettings* New() const PROTOBUF_FINAL { return New(NULL); }

  TLSSettings* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TLSSettings& from);
  void MergeFrom(const TLSSettings& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TLSSettings* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef TLSSettings_TLSmode TLSmode;
  static const TLSmode DISABLE =
    TLSSettings_TLSmode_DISABLE;
  static const TLSmode SIMPLE =
    TLSSettings_TLSmode_SIMPLE;
  static const TLSmode MUTUAL =
    TLSSettings_TLSmode_MUTUAL;
  static const TLSmode ISTIO_MUTUAL =
    TLSSettings_TLSmode_ISTIO_MUTUAL;
  static inline bool TLSmode_IsValid(int value) {
    return TLSSettings_TLSmode_IsValid(value);
  }
  static const TLSmode TLSmode_MIN =
    TLSSettings_TLSmode_TLSmode_MIN;
  static const TLSmode TLSmode_MAX =
    TLSSettings_TLSmode_TLSmode_MAX;
  static const int TLSmode_ARRAYSIZE =
    TLSSettings_TLSmode_TLSmode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TLSmode_descriptor() {
    return TLSSettings_TLSmode_descriptor();
  }
  static inline const ::std::string& TLSmode_Name(TLSmode value) {
    return TLSSettings_TLSmode_Name(value);
  }
  static inline bool TLSmode_Parse(const ::std::string& name,
      TLSmode* value) {
    return TLSSettings_TLSmode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated string subject_alt_names = 5;
  int subject_alt_names_size() const;
  void clear_subject_alt_names();
  static const int kSubjectAltNamesFieldNumber = 5;
  const ::std::string& subject_alt_names(int index) const;
  ::std::string* mutable_subject_alt_names(int index);
  void set_subject_alt_names(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_subject_alt_names(int index, ::std::string&& value);
  #endif
  void set_subject_alt_names(int index, const char* value);
  void set_subject_alt_names(int index, const char* value, size_t size);
  ::std::string* add_subject_alt_names();
  void add_subject_alt_names(const ::std::string& value);
  #if LANG_CXX11
  void add_subject_alt_names(::std::string&& value);
  #endif
  void add_subject_alt_names(const char* value);
  void add_subject_alt_names(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& subject_alt_names() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_subject_alt_names();

  // string client_certificate = 2;
  void clear_client_certificate();
  static const int kClientCertificateFieldNumber = 2;
  const ::std::string& client_certificate() const;
  void set_client_certificate(const ::std::string& value);
  #if LANG_CXX11
  void set_client_certificate(::std::string&& value);
  #endif
  void set_client_certificate(const char* value);
  void set_client_certificate(const char* value, size_t size);
  ::std::string* mutable_client_certificate();
  ::std::string* release_client_certificate();
  void set_allocated_client_certificate(::std::string* client_certificate);

  // string private_key = 3;
  void clear_private_key();
  static const int kPrivateKeyFieldNumber = 3;
  const ::std::string& private_key() const;
  void set_private_key(const ::std::string& value);
  #if LANG_CXX11
  void set_private_key(::std::string&& value);
  #endif
  void set_private_key(const char* value);
  void set_private_key(const char* value, size_t size);
  ::std::string* mutable_private_key();
  ::std::string* release_private_key();
  void set_allocated_private_key(::std::string* private_key);

  // string ca_certificates = 4;
  void clear_ca_certificates();
  static const int kCaCertificatesFieldNumber = 4;
  const ::std::string& ca_certificates() const;
  void set_ca_certificates(const ::std::string& value);
  #if LANG_CXX11
  void set_ca_certificates(::std::string&& value);
  #endif
  void set_ca_certificates(const char* value);
  void set_ca_certificates(const char* value, size_t size);
  ::std::string* mutable_ca_certificates();
  ::std::string* release_ca_certificates();
  void set_allocated_ca_certificates(::std::string* ca_certificates);

  // string sni = 6;
  void clear_sni();
  static const int kSniFieldNumber = 6;
  const ::std::string& sni() const;
  void set_sni(const ::std::string& value);
  #if LANG_CXX11
  void set_sni(::std::string&& value);
  #endif
  void set_sni(const char* value);
  void set_sni(const char* value, size_t size);
  ::std::string* mutable_sni();
  ::std::string* release_sni();
  void set_allocated_sni(::std::string* sni);

  // .istio.networking.v1alpha3.TLSSettings.TLSmode mode = 1;
  void clear_mode();
  static const int kModeFieldNumber = 1;
  ::istio::networking::v1alpha3::TLSSettings_TLSmode mode() const;
  void set_mode(::istio::networking::v1alpha3::TLSSettings_TLSmode value);

  // @@protoc_insertion_point(class_scope:istio.networking.v1alpha3.TLSSettings)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> subject_alt_names_;
  ::google::protobuf::internal::ArenaStringPtr client_certificate_;
  ::google::protobuf::internal::ArenaStringPtr private_key_;
  ::google::protobuf::internal::ArenaStringPtr ca_certificates_;
  ::google::protobuf::internal::ArenaStringPtr sni_;
  int mode_;
  mutable int _cached_size_;
  friend struct ::protobuf_networking_2fv1alpha3_2fdestination_5frule_2eproto::TableStruct;
  friend void ::protobuf_networking_2fv1alpha3_2fdestination_5frule_2eproto::InitDefaultsTLSSettingsImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DestinationRule

// string host = 1;
inline void DestinationRule::clear_host() {
  host_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DestinationRule::host() const {
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.DestinationRule.host)
  return host_.GetNoArena();
}
inline void DestinationRule::set_host(const ::std::string& value) {
  
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.networking.v1alpha3.DestinationRule.host)
}
#if LANG_CXX11
inline void DestinationRule::set_host(::std::string&& value) {
  
  host_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.networking.v1alpha3.DestinationRule.host)
}
#endif
inline void DestinationRule::set_host(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.networking.v1alpha3.DestinationRule.host)
}
inline void DestinationRule::set_host(const char* value, size_t size) {
  
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.networking.v1alpha3.DestinationRule.host)
}
inline ::std::string* DestinationRule::mutable_host() {
  
  // @@protoc_insertion_point(field_mutable:istio.networking.v1alpha3.DestinationRule.host)
  return host_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DestinationRule::release_host() {
  // @@protoc_insertion_point(field_release:istio.networking.v1alpha3.DestinationRule.host)
  
  return host_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DestinationRule::set_allocated_host(::std::string* host) {
  if (host != NULL) {
    
  } else {
    
  }
  host_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), host);
  // @@protoc_insertion_point(field_set_allocated:istio.networking.v1alpha3.DestinationRule.host)
}

// .istio.networking.v1alpha3.TrafficPolicy traffic_policy = 2;
inline bool DestinationRule::has_traffic_policy() const {
  return this != internal_default_instance() && traffic_policy_ != NULL;
}
inline void DestinationRule::clear_traffic_policy() {
  if (GetArenaNoVirtual() == NULL && traffic_policy_ != NULL) {
    delete traffic_policy_;
  }
  traffic_policy_ = NULL;
}
inline const ::istio::networking::v1alpha3::TrafficPolicy& DestinationRule::traffic_policy() const {
  const ::istio::networking::v1alpha3::TrafficPolicy* p = traffic_policy_;
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.DestinationRule.traffic_policy)
  return p != NULL ? *p : *reinterpret_cast<const ::istio::networking::v1alpha3::TrafficPolicy*>(
      &::istio::networking::v1alpha3::_TrafficPolicy_default_instance_);
}
inline ::istio::networking::v1alpha3::TrafficPolicy* DestinationRule::release_traffic_policy() {
  // @@protoc_insertion_point(field_release:istio.networking.v1alpha3.DestinationRule.traffic_policy)
  
  ::istio::networking::v1alpha3::TrafficPolicy* temp = traffic_policy_;
  traffic_policy_ = NULL;
  return temp;
}
inline ::istio::networking::v1alpha3::TrafficPolicy* DestinationRule::mutable_traffic_policy() {
  
  if (traffic_policy_ == NULL) {
    traffic_policy_ = new ::istio::networking::v1alpha3::TrafficPolicy;
  }
  // @@protoc_insertion_point(field_mutable:istio.networking.v1alpha3.DestinationRule.traffic_policy)
  return traffic_policy_;
}
inline void DestinationRule::set_allocated_traffic_policy(::istio::networking::v1alpha3::TrafficPolicy* traffic_policy) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete traffic_policy_;
  }
  if (traffic_policy) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      traffic_policy = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, traffic_policy, submessage_arena);
    }
    
  } else {
    
  }
  traffic_policy_ = traffic_policy;
  // @@protoc_insertion_point(field_set_allocated:istio.networking.v1alpha3.DestinationRule.traffic_policy)
}

// repeated .istio.networking.v1alpha3.Subset subsets = 3;
inline int DestinationRule::subsets_size() const {
  return subsets_.size();
}
inline void DestinationRule::clear_subsets() {
  subsets_.Clear();
}
inline const ::istio::networking::v1alpha3::Subset& DestinationRule::subsets(int index) const {
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.DestinationRule.subsets)
  return subsets_.Get(index);
}
inline ::istio::networking::v1alpha3::Subset* DestinationRule::mutable_subsets(int index) {
  // @@protoc_insertion_point(field_mutable:istio.networking.v1alpha3.DestinationRule.subsets)
  return subsets_.Mutable(index);
}
inline ::istio::networking::v1alpha3::Subset* DestinationRule::add_subsets() {
  // @@protoc_insertion_point(field_add:istio.networking.v1alpha3.DestinationRule.subsets)
  return subsets_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::istio::networking::v1alpha3::Subset >*
DestinationRule::mutable_subsets() {
  // @@protoc_insertion_point(field_mutable_list:istio.networking.v1alpha3.DestinationRule.subsets)
  return &subsets_;
}
inline const ::google::protobuf::RepeatedPtrField< ::istio::networking::v1alpha3::Subset >&
DestinationRule::subsets() const {
  // @@protoc_insertion_point(field_list:istio.networking.v1alpha3.DestinationRule.subsets)
  return subsets_;
}

// repeated string export_to = 4;
inline int DestinationRule::export_to_size() const {
  return export_to_.size();
}
inline void DestinationRule::clear_export_to() {
  export_to_.Clear();
}
inline const ::std::string& DestinationRule::export_to(int index) const {
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.DestinationRule.export_to)
  return export_to_.Get(index);
}
inline ::std::string* DestinationRule::mutable_export_to(int index) {
  // @@protoc_insertion_point(field_mutable:istio.networking.v1alpha3.DestinationRule.export_to)
  return export_to_.Mutable(index);
}
inline void DestinationRule::set_export_to(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:istio.networking.v1alpha3.DestinationRule.export_to)
  export_to_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void DestinationRule::set_export_to(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:istio.networking.v1alpha3.DestinationRule.export_to)
  export_to_.Mutable(index)->assign(std::move(value));
}
#endif
inline void DestinationRule::set_export_to(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  export_to_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:istio.networking.v1alpha3.DestinationRule.export_to)
}
inline void DestinationRule::set_export_to(int index, const char* value, size_t size) {
  export_to_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:istio.networking.v1alpha3.DestinationRule.export_to)
}
inline ::std::string* DestinationRule::add_export_to() {
  // @@protoc_insertion_point(field_add_mutable:istio.networking.v1alpha3.DestinationRule.export_to)
  return export_to_.Add();
}
inline void DestinationRule::add_export_to(const ::std::string& value) {
  export_to_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:istio.networking.v1alpha3.DestinationRule.export_to)
}
#if LANG_CXX11
inline void DestinationRule::add_export_to(::std::string&& value) {
  export_to_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:istio.networking.v1alpha3.DestinationRule.export_to)
}
#endif
inline void DestinationRule::add_export_to(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  export_to_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:istio.networking.v1alpha3.DestinationRule.export_to)
}
inline void DestinationRule::add_export_to(const char* value, size_t size) {
  export_to_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:istio.networking.v1alpha3.DestinationRule.export_to)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DestinationRule::export_to() const {
  // @@protoc_insertion_point(field_list:istio.networking.v1alpha3.DestinationRule.export_to)
  return export_to_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DestinationRule::mutable_export_to() {
  // @@protoc_insertion_point(field_mutable_list:istio.networking.v1alpha3.DestinationRule.export_to)
  return &export_to_;
}

// -------------------------------------------------------------------

// TrafficPolicy_PortTrafficPolicy

// .istio.networking.v1alpha3.PortSelector port = 1;
inline bool TrafficPolicy_PortTrafficPolicy::has_port() const {
  return this != internal_default_instance() && port_ != NULL;
}
inline const ::istio::networking::v1alpha3::PortSelector& TrafficPolicy_PortTrafficPolicy::port() const {
  const ::istio::networking::v1alpha3::PortSelector* p = port_;
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.TrafficPolicy.PortTrafficPolicy.port)
  return p != NULL ? *p : *reinterpret_cast<const ::istio::networking::v1alpha3::PortSelector*>(
      &::istio::networking::v1alpha3::_PortSelector_default_instance_);
}
inline ::istio::networking::v1alpha3::PortSelector* TrafficPolicy_PortTrafficPolicy::release_port() {
  // @@protoc_insertion_point(field_release:istio.networking.v1alpha3.TrafficPolicy.PortTrafficPolicy.port)
  
  ::istio::networking::v1alpha3::PortSelector* temp = port_;
  port_ = NULL;
  return temp;
}
inline ::istio::networking::v1alpha3::PortSelector* TrafficPolicy_PortTrafficPolicy::mutable_port() {
  
  if (port_ == NULL) {
    port_ = new ::istio::networking::v1alpha3::PortSelector;
  }
  // @@protoc_insertion_point(field_mutable:istio.networking.v1alpha3.TrafficPolicy.PortTrafficPolicy.port)
  return port_;
}
inline void TrafficPolicy_PortTrafficPolicy::set_allocated_port(::istio::networking::v1alpha3::PortSelector* port) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(port_);
  }
  if (port) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      port = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, port, submessage_arena);
    }
    
  } else {
    
  }
  port_ = port;
  // @@protoc_insertion_point(field_set_allocated:istio.networking.v1alpha3.TrafficPolicy.PortTrafficPolicy.port)
}

// .istio.networking.v1alpha3.LoadBalancerSettings load_balancer = 2;
inline bool TrafficPolicy_PortTrafficPolicy::has_load_balancer() const {
  return this != internal_default_instance() && load_balancer_ != NULL;
}
inline void TrafficPolicy_PortTrafficPolicy::clear_load_balancer() {
  if (GetArenaNoVirtual() == NULL && load_balancer_ != NULL) {
    delete load_balancer_;
  }
  load_balancer_ = NULL;
}
inline const ::istio::networking::v1alpha3::LoadBalancerSettings& TrafficPolicy_PortTrafficPolicy::load_balancer() const {
  const ::istio::networking::v1alpha3::LoadBalancerSettings* p = load_balancer_;
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.TrafficPolicy.PortTrafficPolicy.load_balancer)
  return p != NULL ? *p : *reinterpret_cast<const ::istio::networking::v1alpha3::LoadBalancerSettings*>(
      &::istio::networking::v1alpha3::_LoadBalancerSettings_default_instance_);
}
inline ::istio::networking::v1alpha3::LoadBalancerSettings* TrafficPolicy_PortTrafficPolicy::release_load_balancer() {
  // @@protoc_insertion_point(field_release:istio.networking.v1alpha3.TrafficPolicy.PortTrafficPolicy.load_balancer)
  
  ::istio::networking::v1alpha3::LoadBalancerSettings* temp = load_balancer_;
  load_balancer_ = NULL;
  return temp;
}
inline ::istio::networking::v1alpha3::LoadBalancerSettings* TrafficPolicy_PortTrafficPolicy::mutable_load_balancer() {
  
  if (load_balancer_ == NULL) {
    load_balancer_ = new ::istio::networking::v1alpha3::LoadBalancerSettings;
  }
  // @@protoc_insertion_point(field_mutable:istio.networking.v1alpha3.TrafficPolicy.PortTrafficPolicy.load_balancer)
  return load_balancer_;
}
inline void TrafficPolicy_PortTrafficPolicy::set_allocated_load_balancer(::istio::networking::v1alpha3::LoadBalancerSettings* load_balancer) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete load_balancer_;
  }
  if (load_balancer) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      load_balancer = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, load_balancer, submessage_arena);
    }
    
  } else {
    
  }
  load_balancer_ = load_balancer;
  // @@protoc_insertion_point(field_set_allocated:istio.networking.v1alpha3.TrafficPolicy.PortTrafficPolicy.load_balancer)
}

// .istio.networking.v1alpha3.ConnectionPoolSettings connection_pool = 3;
inline bool TrafficPolicy_PortTrafficPolicy::has_connection_pool() const {
  return this != internal_default_instance() && connection_pool_ != NULL;
}
inline void TrafficPolicy_PortTrafficPolicy::clear_connection_pool() {
  if (GetArenaNoVirtual() == NULL && connection_pool_ != NULL) {
    delete connection_pool_;
  }
  connection_pool_ = NULL;
}
inline const ::istio::networking::v1alpha3::ConnectionPoolSettings& TrafficPolicy_PortTrafficPolicy::connection_pool() const {
  const ::istio::networking::v1alpha3::ConnectionPoolSettings* p = connection_pool_;
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.TrafficPolicy.PortTrafficPolicy.connection_pool)
  return p != NULL ? *p : *reinterpret_cast<const ::istio::networking::v1alpha3::ConnectionPoolSettings*>(
      &::istio::networking::v1alpha3::_ConnectionPoolSettings_default_instance_);
}
inline ::istio::networking::v1alpha3::ConnectionPoolSettings* TrafficPolicy_PortTrafficPolicy::release_connection_pool() {
  // @@protoc_insertion_point(field_release:istio.networking.v1alpha3.TrafficPolicy.PortTrafficPolicy.connection_pool)
  
  ::istio::networking::v1alpha3::ConnectionPoolSettings* temp = connection_pool_;
  connection_pool_ = NULL;
  return temp;
}
inline ::istio::networking::v1alpha3::ConnectionPoolSettings* TrafficPolicy_PortTrafficPolicy::mutable_connection_pool() {
  
  if (connection_pool_ == NULL) {
    connection_pool_ = new ::istio::networking::v1alpha3::ConnectionPoolSettings;
  }
  // @@protoc_insertion_point(field_mutable:istio.networking.v1alpha3.TrafficPolicy.PortTrafficPolicy.connection_pool)
  return connection_pool_;
}
inline void TrafficPolicy_PortTrafficPolicy::set_allocated_connection_pool(::istio::networking::v1alpha3::ConnectionPoolSettings* connection_pool) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete connection_pool_;
  }
  if (connection_pool) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      connection_pool = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, connection_pool, submessage_arena);
    }
    
  } else {
    
  }
  connection_pool_ = connection_pool;
  // @@protoc_insertion_point(field_set_allocated:istio.networking.v1alpha3.TrafficPolicy.PortTrafficPolicy.connection_pool)
}

// .istio.networking.v1alpha3.OutlierDetection outlier_detection = 4;
inline bool TrafficPolicy_PortTrafficPolicy::has_outlier_detection() const {
  return this != internal_default_instance() && outlier_detection_ != NULL;
}
inline void TrafficPolicy_PortTrafficPolicy::clear_outlier_detection() {
  if (GetArenaNoVirtual() == NULL && outlier_detection_ != NULL) {
    delete outlier_detection_;
  }
  outlier_detection_ = NULL;
}
inline const ::istio::networking::v1alpha3::OutlierDetection& TrafficPolicy_PortTrafficPolicy::outlier_detection() const {
  const ::istio::networking::v1alpha3::OutlierDetection* p = outlier_detection_;
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.TrafficPolicy.PortTrafficPolicy.outlier_detection)
  return p != NULL ? *p : *reinterpret_cast<const ::istio::networking::v1alpha3::OutlierDetection*>(
      &::istio::networking::v1alpha3::_OutlierDetection_default_instance_);
}
inline ::istio::networking::v1alpha3::OutlierDetection* TrafficPolicy_PortTrafficPolicy::release_outlier_detection() {
  // @@protoc_insertion_point(field_release:istio.networking.v1alpha3.TrafficPolicy.PortTrafficPolicy.outlier_detection)
  
  ::istio::networking::v1alpha3::OutlierDetection* temp = outlier_detection_;
  outlier_detection_ = NULL;
  return temp;
}
inline ::istio::networking::v1alpha3::OutlierDetection* TrafficPolicy_PortTrafficPolicy::mutable_outlier_detection() {
  
  if (outlier_detection_ == NULL) {
    outlier_detection_ = new ::istio::networking::v1alpha3::OutlierDetection;
  }
  // @@protoc_insertion_point(field_mutable:istio.networking.v1alpha3.TrafficPolicy.PortTrafficPolicy.outlier_detection)
  return outlier_detection_;
}
inline void TrafficPolicy_PortTrafficPolicy::set_allocated_outlier_detection(::istio::networking::v1alpha3::OutlierDetection* outlier_detection) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete outlier_detection_;
  }
  if (outlier_detection) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      outlier_detection = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, outlier_detection, submessage_arena);
    }
    
  } else {
    
  }
  outlier_detection_ = outlier_detection;
  // @@protoc_insertion_point(field_set_allocated:istio.networking.v1alpha3.TrafficPolicy.PortTrafficPolicy.outlier_detection)
}

// .istio.networking.v1alpha3.TLSSettings tls = 5;
inline bool TrafficPolicy_PortTrafficPolicy::has_tls() const {
  return this != internal_default_instance() && tls_ != NULL;
}
inline void TrafficPolicy_PortTrafficPolicy::clear_tls() {
  if (GetArenaNoVirtual() == NULL && tls_ != NULL) {
    delete tls_;
  }
  tls_ = NULL;
}
inline const ::istio::networking::v1alpha3::TLSSettings& TrafficPolicy_PortTrafficPolicy::tls() const {
  const ::istio::networking::v1alpha3::TLSSettings* p = tls_;
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.TrafficPolicy.PortTrafficPolicy.tls)
  return p != NULL ? *p : *reinterpret_cast<const ::istio::networking::v1alpha3::TLSSettings*>(
      &::istio::networking::v1alpha3::_TLSSettings_default_instance_);
}
inline ::istio::networking::v1alpha3::TLSSettings* TrafficPolicy_PortTrafficPolicy::release_tls() {
  // @@protoc_insertion_point(field_release:istio.networking.v1alpha3.TrafficPolicy.PortTrafficPolicy.tls)
  
  ::istio::networking::v1alpha3::TLSSettings* temp = tls_;
  tls_ = NULL;
  return temp;
}
inline ::istio::networking::v1alpha3::TLSSettings* TrafficPolicy_PortTrafficPolicy::mutable_tls() {
  
  if (tls_ == NULL) {
    tls_ = new ::istio::networking::v1alpha3::TLSSettings;
  }
  // @@protoc_insertion_point(field_mutable:istio.networking.v1alpha3.TrafficPolicy.PortTrafficPolicy.tls)
  return tls_;
}
inline void TrafficPolicy_PortTrafficPolicy::set_allocated_tls(::istio::networking::v1alpha3::TLSSettings* tls) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete tls_;
  }
  if (tls) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tls = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tls, submessage_arena);
    }
    
  } else {
    
  }
  tls_ = tls;
  // @@protoc_insertion_point(field_set_allocated:istio.networking.v1alpha3.TrafficPolicy.PortTrafficPolicy.tls)
}

// -------------------------------------------------------------------

// TrafficPolicy

// .istio.networking.v1alpha3.LoadBalancerSettings load_balancer = 1;
inline bool TrafficPolicy::has_load_balancer() const {
  return this != internal_default_instance() && load_balancer_ != NULL;
}
inline void TrafficPolicy::clear_load_balancer() {
  if (GetArenaNoVirtual() == NULL && load_balancer_ != NULL) {
    delete load_balancer_;
  }
  load_balancer_ = NULL;
}
inline const ::istio::networking::v1alpha3::LoadBalancerSettings& TrafficPolicy::load_balancer() const {
  const ::istio::networking::v1alpha3::LoadBalancerSettings* p = load_balancer_;
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.TrafficPolicy.load_balancer)
  return p != NULL ? *p : *reinterpret_cast<const ::istio::networking::v1alpha3::LoadBalancerSettings*>(
      &::istio::networking::v1alpha3::_LoadBalancerSettings_default_instance_);
}
inline ::istio::networking::v1alpha3::LoadBalancerSettings* TrafficPolicy::release_load_balancer() {
  // @@protoc_insertion_point(field_release:istio.networking.v1alpha3.TrafficPolicy.load_balancer)
  
  ::istio::networking::v1alpha3::LoadBalancerSettings* temp = load_balancer_;
  load_balancer_ = NULL;
  return temp;
}
inline ::istio::networking::v1alpha3::LoadBalancerSettings* TrafficPolicy::mutable_load_balancer() {
  
  if (load_balancer_ == NULL) {
    load_balancer_ = new ::istio::networking::v1alpha3::LoadBalancerSettings;
  }
  // @@protoc_insertion_point(field_mutable:istio.networking.v1alpha3.TrafficPolicy.load_balancer)
  return load_balancer_;
}
inline void TrafficPolicy::set_allocated_load_balancer(::istio::networking::v1alpha3::LoadBalancerSettings* load_balancer) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete load_balancer_;
  }
  if (load_balancer) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      load_balancer = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, load_balancer, submessage_arena);
    }
    
  } else {
    
  }
  load_balancer_ = load_balancer;
  // @@protoc_insertion_point(field_set_allocated:istio.networking.v1alpha3.TrafficPolicy.load_balancer)
}

// .istio.networking.v1alpha3.ConnectionPoolSettings connection_pool = 2;
inline bool TrafficPolicy::has_connection_pool() const {
  return this != internal_default_instance() && connection_pool_ != NULL;
}
inline void TrafficPolicy::clear_connection_pool() {
  if (GetArenaNoVirtual() == NULL && connection_pool_ != NULL) {
    delete connection_pool_;
  }
  connection_pool_ = NULL;
}
inline const ::istio::networking::v1alpha3::ConnectionPoolSettings& TrafficPolicy::connection_pool() const {
  const ::istio::networking::v1alpha3::ConnectionPoolSettings* p = connection_pool_;
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.TrafficPolicy.connection_pool)
  return p != NULL ? *p : *reinterpret_cast<const ::istio::networking::v1alpha3::ConnectionPoolSettings*>(
      &::istio::networking::v1alpha3::_ConnectionPoolSettings_default_instance_);
}
inline ::istio::networking::v1alpha3::ConnectionPoolSettings* TrafficPolicy::release_connection_pool() {
  // @@protoc_insertion_point(field_release:istio.networking.v1alpha3.TrafficPolicy.connection_pool)
  
  ::istio::networking::v1alpha3::ConnectionPoolSettings* temp = connection_pool_;
  connection_pool_ = NULL;
  return temp;
}
inline ::istio::networking::v1alpha3::ConnectionPoolSettings* TrafficPolicy::mutable_connection_pool() {
  
  if (connection_pool_ == NULL) {
    connection_pool_ = new ::istio::networking::v1alpha3::ConnectionPoolSettings;
  }
  // @@protoc_insertion_point(field_mutable:istio.networking.v1alpha3.TrafficPolicy.connection_pool)
  return connection_pool_;
}
inline void TrafficPolicy::set_allocated_connection_pool(::istio::networking::v1alpha3::ConnectionPoolSettings* connection_pool) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete connection_pool_;
  }
  if (connection_pool) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      connection_pool = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, connection_pool, submessage_arena);
    }
    
  } else {
    
  }
  connection_pool_ = connection_pool;
  // @@protoc_insertion_point(field_set_allocated:istio.networking.v1alpha3.TrafficPolicy.connection_pool)
}

// .istio.networking.v1alpha3.OutlierDetection outlier_detection = 3;
inline bool TrafficPolicy::has_outlier_detection() const {
  return this != internal_default_instance() && outlier_detection_ != NULL;
}
inline void TrafficPolicy::clear_outlier_detection() {
  if (GetArenaNoVirtual() == NULL && outlier_detection_ != NULL) {
    delete outlier_detection_;
  }
  outlier_detection_ = NULL;
}
inline const ::istio::networking::v1alpha3::OutlierDetection& TrafficPolicy::outlier_detection() const {
  const ::istio::networking::v1alpha3::OutlierDetection* p = outlier_detection_;
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.TrafficPolicy.outlier_detection)
  return p != NULL ? *p : *reinterpret_cast<const ::istio::networking::v1alpha3::OutlierDetection*>(
      &::istio::networking::v1alpha3::_OutlierDetection_default_instance_);
}
inline ::istio::networking::v1alpha3::OutlierDetection* TrafficPolicy::release_outlier_detection() {
  // @@protoc_insertion_point(field_release:istio.networking.v1alpha3.TrafficPolicy.outlier_detection)
  
  ::istio::networking::v1alpha3::OutlierDetection* temp = outlier_detection_;
  outlier_detection_ = NULL;
  return temp;
}
inline ::istio::networking::v1alpha3::OutlierDetection* TrafficPolicy::mutable_outlier_detection() {
  
  if (outlier_detection_ == NULL) {
    outlier_detection_ = new ::istio::networking::v1alpha3::OutlierDetection;
  }
  // @@protoc_insertion_point(field_mutable:istio.networking.v1alpha3.TrafficPolicy.outlier_detection)
  return outlier_detection_;
}
inline void TrafficPolicy::set_allocated_outlier_detection(::istio::networking::v1alpha3::OutlierDetection* outlier_detection) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete outlier_detection_;
  }
  if (outlier_detection) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      outlier_detection = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, outlier_detection, submessage_arena);
    }
    
  } else {
    
  }
  outlier_detection_ = outlier_detection;
  // @@protoc_insertion_point(field_set_allocated:istio.networking.v1alpha3.TrafficPolicy.outlier_detection)
}

// .istio.networking.v1alpha3.TLSSettings tls = 4;
inline bool TrafficPolicy::has_tls() const {
  return this != internal_default_instance() && tls_ != NULL;
}
inline void TrafficPolicy::clear_tls() {
  if (GetArenaNoVirtual() == NULL && tls_ != NULL) {
    delete tls_;
  }
  tls_ = NULL;
}
inline const ::istio::networking::v1alpha3::TLSSettings& TrafficPolicy::tls() const {
  const ::istio::networking::v1alpha3::TLSSettings* p = tls_;
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.TrafficPolicy.tls)
  return p != NULL ? *p : *reinterpret_cast<const ::istio::networking::v1alpha3::TLSSettings*>(
      &::istio::networking::v1alpha3::_TLSSettings_default_instance_);
}
inline ::istio::networking::v1alpha3::TLSSettings* TrafficPolicy::release_tls() {
  // @@protoc_insertion_point(field_release:istio.networking.v1alpha3.TrafficPolicy.tls)
  
  ::istio::networking::v1alpha3::TLSSettings* temp = tls_;
  tls_ = NULL;
  return temp;
}
inline ::istio::networking::v1alpha3::TLSSettings* TrafficPolicy::mutable_tls() {
  
  if (tls_ == NULL) {
    tls_ = new ::istio::networking::v1alpha3::TLSSettings;
  }
  // @@protoc_insertion_point(field_mutable:istio.networking.v1alpha3.TrafficPolicy.tls)
  return tls_;
}
inline void TrafficPolicy::set_allocated_tls(::istio::networking::v1alpha3::TLSSettings* tls) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete tls_;
  }
  if (tls) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tls = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tls, submessage_arena);
    }
    
  } else {
    
  }
  tls_ = tls;
  // @@protoc_insertion_point(field_set_allocated:istio.networking.v1alpha3.TrafficPolicy.tls)
}

// repeated .istio.networking.v1alpha3.TrafficPolicy.PortTrafficPolicy port_level_settings = 5;
inline int TrafficPolicy::port_level_settings_size() const {
  return port_level_settings_.size();
}
inline void TrafficPolicy::clear_port_level_settings() {
  port_level_settings_.Clear();
}
inline const ::istio::networking::v1alpha3::TrafficPolicy_PortTrafficPolicy& TrafficPolicy::port_level_settings(int index) const {
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.TrafficPolicy.port_level_settings)
  return port_level_settings_.Get(index);
}
inline ::istio::networking::v1alpha3::TrafficPolicy_PortTrafficPolicy* TrafficPolicy::mutable_port_level_settings(int index) {
  // @@protoc_insertion_point(field_mutable:istio.networking.v1alpha3.TrafficPolicy.port_level_settings)
  return port_level_settings_.Mutable(index);
}
inline ::istio::networking::v1alpha3::TrafficPolicy_PortTrafficPolicy* TrafficPolicy::add_port_level_settings() {
  // @@protoc_insertion_point(field_add:istio.networking.v1alpha3.TrafficPolicy.port_level_settings)
  return port_level_settings_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::istio::networking::v1alpha3::TrafficPolicy_PortTrafficPolicy >*
TrafficPolicy::mutable_port_level_settings() {
  // @@protoc_insertion_point(field_mutable_list:istio.networking.v1alpha3.TrafficPolicy.port_level_settings)
  return &port_level_settings_;
}
inline const ::google::protobuf::RepeatedPtrField< ::istio::networking::v1alpha3::TrafficPolicy_PortTrafficPolicy >&
TrafficPolicy::port_level_settings() const {
  // @@protoc_insertion_point(field_list:istio.networking.v1alpha3.TrafficPolicy.port_level_settings)
  return port_level_settings_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Subset

// string name = 1;
inline void Subset::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Subset::name() const {
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.Subset.name)
  return name_.GetNoArena();
}
inline void Subset::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.networking.v1alpha3.Subset.name)
}
#if LANG_CXX11
inline void Subset::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.networking.v1alpha3.Subset.name)
}
#endif
inline void Subset::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.networking.v1alpha3.Subset.name)
}
inline void Subset::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.networking.v1alpha3.Subset.name)
}
inline ::std::string* Subset::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:istio.networking.v1alpha3.Subset.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Subset::release_name() {
  // @@protoc_insertion_point(field_release:istio.networking.v1alpha3.Subset.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Subset::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:istio.networking.v1alpha3.Subset.name)
}

// map<string, string> labels = 2;
inline int Subset::labels_size() const {
  return labels_.size();
}
inline void Subset::clear_labels() {
  labels_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
Subset::labels() const {
  // @@protoc_insertion_point(field_map:istio.networking.v1alpha3.Subset.labels)
  return labels_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
Subset::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_map:istio.networking.v1alpha3.Subset.labels)
  return labels_.MutableMap();
}

// .istio.networking.v1alpha3.TrafficPolicy traffic_policy = 3;
inline bool Subset::has_traffic_policy() const {
  return this != internal_default_instance() && traffic_policy_ != NULL;
}
inline void Subset::clear_traffic_policy() {
  if (GetArenaNoVirtual() == NULL && traffic_policy_ != NULL) {
    delete traffic_policy_;
  }
  traffic_policy_ = NULL;
}
inline const ::istio::networking::v1alpha3::TrafficPolicy& Subset::traffic_policy() const {
  const ::istio::networking::v1alpha3::TrafficPolicy* p = traffic_policy_;
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.Subset.traffic_policy)
  return p != NULL ? *p : *reinterpret_cast<const ::istio::networking::v1alpha3::TrafficPolicy*>(
      &::istio::networking::v1alpha3::_TrafficPolicy_default_instance_);
}
inline ::istio::networking::v1alpha3::TrafficPolicy* Subset::release_traffic_policy() {
  // @@protoc_insertion_point(field_release:istio.networking.v1alpha3.Subset.traffic_policy)
  
  ::istio::networking::v1alpha3::TrafficPolicy* temp = traffic_policy_;
  traffic_policy_ = NULL;
  return temp;
}
inline ::istio::networking::v1alpha3::TrafficPolicy* Subset::mutable_traffic_policy() {
  
  if (traffic_policy_ == NULL) {
    traffic_policy_ = new ::istio::networking::v1alpha3::TrafficPolicy;
  }
  // @@protoc_insertion_point(field_mutable:istio.networking.v1alpha3.Subset.traffic_policy)
  return traffic_policy_;
}
inline void Subset::set_allocated_traffic_policy(::istio::networking::v1alpha3::TrafficPolicy* traffic_policy) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete traffic_policy_;
  }
  if (traffic_policy) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      traffic_policy = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, traffic_policy, submessage_arena);
    }
    
  } else {
    
  }
  traffic_policy_ = traffic_policy;
  // @@protoc_insertion_point(field_set_allocated:istio.networking.v1alpha3.Subset.traffic_policy)
}

// -------------------------------------------------------------------

// LoadBalancerSettings_ConsistentHashLB_HTTPCookie

// string name = 1;
inline void LoadBalancerSettings_ConsistentHashLB_HTTPCookie::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoadBalancerSettings_ConsistentHashLB_HTTPCookie::name() const {
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB.HTTPCookie.name)
  return name_.GetNoArena();
}
inline void LoadBalancerSettings_ConsistentHashLB_HTTPCookie::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB.HTTPCookie.name)
}
#if LANG_CXX11
inline void LoadBalancerSettings_ConsistentHashLB_HTTPCookie::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB.HTTPCookie.name)
}
#endif
inline void LoadBalancerSettings_ConsistentHashLB_HTTPCookie::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB.HTTPCookie.name)
}
inline void LoadBalancerSettings_ConsistentHashLB_HTTPCookie::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB.HTTPCookie.name)
}
inline ::std::string* LoadBalancerSettings_ConsistentHashLB_HTTPCookie::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB.HTTPCookie.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoadBalancerSettings_ConsistentHashLB_HTTPCookie::release_name() {
  // @@protoc_insertion_point(field_release:istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB.HTTPCookie.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoadBalancerSettings_ConsistentHashLB_HTTPCookie::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB.HTTPCookie.name)
}

// string path = 2;
inline void LoadBalancerSettings_ConsistentHashLB_HTTPCookie::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoadBalancerSettings_ConsistentHashLB_HTTPCookie::path() const {
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB.HTTPCookie.path)
  return path_.GetNoArena();
}
inline void LoadBalancerSettings_ConsistentHashLB_HTTPCookie::set_path(const ::std::string& value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB.HTTPCookie.path)
}
#if LANG_CXX11
inline void LoadBalancerSettings_ConsistentHashLB_HTTPCookie::set_path(::std::string&& value) {
  
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB.HTTPCookie.path)
}
#endif
inline void LoadBalancerSettings_ConsistentHashLB_HTTPCookie::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB.HTTPCookie.path)
}
inline void LoadBalancerSettings_ConsistentHashLB_HTTPCookie::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB.HTTPCookie.path)
}
inline ::std::string* LoadBalancerSettings_ConsistentHashLB_HTTPCookie::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB.HTTPCookie.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoadBalancerSettings_ConsistentHashLB_HTTPCookie::release_path() {
  // @@protoc_insertion_point(field_release:istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB.HTTPCookie.path)
  
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoadBalancerSettings_ConsistentHashLB_HTTPCookie::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB.HTTPCookie.path)
}

// .google.protobuf.Duration ttl = 3 [(.gogoproto.stdduration) = true];
inline bool LoadBalancerSettings_ConsistentHashLB_HTTPCookie::has_ttl() const {
  return this != internal_default_instance() && ttl_ != NULL;
}
inline const ::google::protobuf::Duration& LoadBalancerSettings_ConsistentHashLB_HTTPCookie::ttl() const {
  const ::google::protobuf::Duration* p = ttl_;
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB.HTTPCookie.ttl)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Duration*>(
      &::google::protobuf::_Duration_default_instance_);
}
inline ::google::protobuf::Duration* LoadBalancerSettings_ConsistentHashLB_HTTPCookie::release_ttl() {
  // @@protoc_insertion_point(field_release:istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB.HTTPCookie.ttl)
  
  ::google::protobuf::Duration* temp = ttl_;
  ttl_ = NULL;
  return temp;
}
inline ::google::protobuf::Duration* LoadBalancerSettings_ConsistentHashLB_HTTPCookie::mutable_ttl() {
  
  if (ttl_ == NULL) {
    ttl_ = new ::google::protobuf::Duration;
  }
  // @@protoc_insertion_point(field_mutable:istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB.HTTPCookie.ttl)
  return ttl_;
}
inline void LoadBalancerSettings_ConsistentHashLB_HTTPCookie::set_allocated_ttl(::google::protobuf::Duration* ttl) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ttl_);
  }
  if (ttl) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(ttl)->GetArena();
    if (message_arena != submessage_arena) {
      ttl = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ttl, submessage_arena);
    }
    
  } else {
    
  }
  ttl_ = ttl;
  // @@protoc_insertion_point(field_set_allocated:istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB.HTTPCookie.ttl)
}

// -------------------------------------------------------------------

// LoadBalancerSettings_ConsistentHashLB

// string http_header_name = 1;
inline bool LoadBalancerSettings_ConsistentHashLB::has_http_header_name() const {
  return hash_key_case() == kHttpHeaderName;
}
inline void LoadBalancerSettings_ConsistentHashLB::set_has_http_header_name() {
  _oneof_case_[0] = kHttpHeaderName;
}
inline void LoadBalancerSettings_ConsistentHashLB::clear_http_header_name() {
  if (has_http_header_name()) {
    hash_key_.http_header_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_hash_key();
  }
}
inline const ::std::string& LoadBalancerSettings_ConsistentHashLB::http_header_name() const {
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB.http_header_name)
  if (has_http_header_name()) {
    return hash_key_.http_header_name_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void LoadBalancerSettings_ConsistentHashLB::set_http_header_name(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB.http_header_name)
  if (!has_http_header_name()) {
    clear_hash_key();
    set_has_http_header_name();
    hash_key_.http_header_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  hash_key_.http_header_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB.http_header_name)
}
#if LANG_CXX11
inline void LoadBalancerSettings_ConsistentHashLB::set_http_header_name(::std::string&& value) {
  // @@protoc_insertion_point(field_set:istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB.http_header_name)
  if (!has_http_header_name()) {
    clear_hash_key();
    set_has_http_header_name();
    hash_key_.http_header_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  hash_key_.http_header_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB.http_header_name)
}
#endif
inline void LoadBalancerSettings_ConsistentHashLB::set_http_header_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_http_header_name()) {
    clear_hash_key();
    set_has_http_header_name();
    hash_key_.http_header_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  hash_key_.http_header_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB.http_header_name)
}
inline void LoadBalancerSettings_ConsistentHashLB::set_http_header_name(const char* value, size_t size) {
  if (!has_http_header_name()) {
    clear_hash_key();
    set_has_http_header_name();
    hash_key_.http_header_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  hash_key_.http_header_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB.http_header_name)
}
inline ::std::string* LoadBalancerSettings_ConsistentHashLB::mutable_http_header_name() {
  if (!has_http_header_name()) {
    clear_hash_key();
    set_has_http_header_name();
    hash_key_.http_header_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB.http_header_name)
  return hash_key_.http_header_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoadBalancerSettings_ConsistentHashLB::release_http_header_name() {
  // @@protoc_insertion_point(field_release:istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB.http_header_name)
  if (has_http_header_name()) {
    clear_has_hash_key();
    return hash_key_.http_header_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void LoadBalancerSettings_ConsistentHashLB::set_allocated_http_header_name(::std::string* http_header_name) {
  if (!has_http_header_name()) {
    hash_key_.http_header_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_hash_key();
  if (http_header_name != NULL) {
    set_has_http_header_name();
    hash_key_.http_header_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        http_header_name);
  }
  // @@protoc_insertion_point(field_set_allocated:istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB.http_header_name)
}

// .istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB.HTTPCookie http_cookie = 2;
inline bool LoadBalancerSettings_ConsistentHashLB::has_http_cookie() const {
  return hash_key_case() == kHttpCookie;
}
inline void LoadBalancerSettings_ConsistentHashLB::set_has_http_cookie() {
  _oneof_case_[0] = kHttpCookie;
}
inline void LoadBalancerSettings_ConsistentHashLB::clear_http_cookie() {
  if (has_http_cookie()) {
    delete hash_key_.http_cookie_;
    clear_has_hash_key();
  }
}
inline ::istio::networking::v1alpha3::LoadBalancerSettings_ConsistentHashLB_HTTPCookie* LoadBalancerSettings_ConsistentHashLB::release_http_cookie() {
  // @@protoc_insertion_point(field_release:istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB.http_cookie)
  if (has_http_cookie()) {
    clear_has_hash_key();
      ::istio::networking::v1alpha3::LoadBalancerSettings_ConsistentHashLB_HTTPCookie* temp = hash_key_.http_cookie_;
    hash_key_.http_cookie_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::istio::networking::v1alpha3::LoadBalancerSettings_ConsistentHashLB_HTTPCookie& LoadBalancerSettings_ConsistentHashLB::http_cookie() const {
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB.http_cookie)
  return has_http_cookie()
      ? *hash_key_.http_cookie_
      : *reinterpret_cast< ::istio::networking::v1alpha3::LoadBalancerSettings_ConsistentHashLB_HTTPCookie*>(&::istio::networking::v1alpha3::_LoadBalancerSettings_ConsistentHashLB_HTTPCookie_default_instance_);
}
inline ::istio::networking::v1alpha3::LoadBalancerSettings_ConsistentHashLB_HTTPCookie* LoadBalancerSettings_ConsistentHashLB::mutable_http_cookie() {
  if (!has_http_cookie()) {
    clear_hash_key();
    set_has_http_cookie();
    hash_key_.http_cookie_ = new ::istio::networking::v1alpha3::LoadBalancerSettings_ConsistentHashLB_HTTPCookie;
  }
  // @@protoc_insertion_point(field_mutable:istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB.http_cookie)
  return hash_key_.http_cookie_;
}

// bool use_source_ip = 3;
inline bool LoadBalancerSettings_ConsistentHashLB::has_use_source_ip() const {
  return hash_key_case() == kUseSourceIp;
}
inline void LoadBalancerSettings_ConsistentHashLB::set_has_use_source_ip() {
  _oneof_case_[0] = kUseSourceIp;
}
inline void LoadBalancerSettings_ConsistentHashLB::clear_use_source_ip() {
  if (has_use_source_ip()) {
    hash_key_.use_source_ip_ = false;
    clear_has_hash_key();
  }
}
inline bool LoadBalancerSettings_ConsistentHashLB::use_source_ip() const {
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB.use_source_ip)
  if (has_use_source_ip()) {
    return hash_key_.use_source_ip_;
  }
  return false;
}
inline void LoadBalancerSettings_ConsistentHashLB::set_use_source_ip(bool value) {
  if (!has_use_source_ip()) {
    clear_hash_key();
    set_has_use_source_ip();
  }
  hash_key_.use_source_ip_ = value;
  // @@protoc_insertion_point(field_set:istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB.use_source_ip)
}

// uint64 minimum_ring_size = 4;
inline void LoadBalancerSettings_ConsistentHashLB::clear_minimum_ring_size() {
  minimum_ring_size_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 LoadBalancerSettings_ConsistentHashLB::minimum_ring_size() const {
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB.minimum_ring_size)
  return minimum_ring_size_;
}
inline void LoadBalancerSettings_ConsistentHashLB::set_minimum_ring_size(::google::protobuf::uint64 value) {
  
  minimum_ring_size_ = value;
  // @@protoc_insertion_point(field_set:istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB.minimum_ring_size)
}

inline bool LoadBalancerSettings_ConsistentHashLB::has_hash_key() const {
  return hash_key_case() != HASH_KEY_NOT_SET;
}
inline void LoadBalancerSettings_ConsistentHashLB::clear_has_hash_key() {
  _oneof_case_[0] = HASH_KEY_NOT_SET;
}
inline LoadBalancerSettings_ConsistentHashLB::HashKeyCase LoadBalancerSettings_ConsistentHashLB::hash_key_case() const {
  return LoadBalancerSettings_ConsistentHashLB::HashKeyCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// LoadBalancerSettings

// .istio.networking.v1alpha3.LoadBalancerSettings.SimpleLB simple = 1;
inline bool LoadBalancerSettings::has_simple() const {
  return lb_policy_case() == kSimple;
}
inline void LoadBalancerSettings::set_has_simple() {
  _oneof_case_[0] = kSimple;
}
inline void LoadBalancerSettings::clear_simple() {
  if (has_simple()) {
    lb_policy_.simple_ = 0;
    clear_has_lb_policy();
  }
}
inline ::istio::networking::v1alpha3::LoadBalancerSettings_SimpleLB LoadBalancerSettings::simple() const {
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.LoadBalancerSettings.simple)
  if (has_simple()) {
    return static_cast< ::istio::networking::v1alpha3::LoadBalancerSettings_SimpleLB >(lb_policy_.simple_);
  }
  return static_cast< ::istio::networking::v1alpha3::LoadBalancerSettings_SimpleLB >(0);
}
inline void LoadBalancerSettings::set_simple(::istio::networking::v1alpha3::LoadBalancerSettings_SimpleLB value) {
  if (!has_simple()) {
    clear_lb_policy();
    set_has_simple();
  }
  lb_policy_.simple_ = value;
  // @@protoc_insertion_point(field_set:istio.networking.v1alpha3.LoadBalancerSettings.simple)
}

// .istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB consistent_hash = 2;
inline bool LoadBalancerSettings::has_consistent_hash() const {
  return lb_policy_case() == kConsistentHash;
}
inline void LoadBalancerSettings::set_has_consistent_hash() {
  _oneof_case_[0] = kConsistentHash;
}
inline void LoadBalancerSettings::clear_consistent_hash() {
  if (has_consistent_hash()) {
    delete lb_policy_.consistent_hash_;
    clear_has_lb_policy();
  }
}
inline ::istio::networking::v1alpha3::LoadBalancerSettings_ConsistentHashLB* LoadBalancerSettings::release_consistent_hash() {
  // @@protoc_insertion_point(field_release:istio.networking.v1alpha3.LoadBalancerSettings.consistent_hash)
  if (has_consistent_hash()) {
    clear_has_lb_policy();
      ::istio::networking::v1alpha3::LoadBalancerSettings_ConsistentHashLB* temp = lb_policy_.consistent_hash_;
    lb_policy_.consistent_hash_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::istio::networking::v1alpha3::LoadBalancerSettings_ConsistentHashLB& LoadBalancerSettings::consistent_hash() const {
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.LoadBalancerSettings.consistent_hash)
  return has_consistent_hash()
      ? *lb_policy_.consistent_hash_
      : *reinterpret_cast< ::istio::networking::v1alpha3::LoadBalancerSettings_ConsistentHashLB*>(&::istio::networking::v1alpha3::_LoadBalancerSettings_ConsistentHashLB_default_instance_);
}
inline ::istio::networking::v1alpha3::LoadBalancerSettings_ConsistentHashLB* LoadBalancerSettings::mutable_consistent_hash() {
  if (!has_consistent_hash()) {
    clear_lb_policy();
    set_has_consistent_hash();
    lb_policy_.consistent_hash_ = new ::istio::networking::v1alpha3::LoadBalancerSettings_ConsistentHashLB;
  }
  // @@protoc_insertion_point(field_mutable:istio.networking.v1alpha3.LoadBalancerSettings.consistent_hash)
  return lb_policy_.consistent_hash_;
}

inline bool LoadBalancerSettings::has_lb_policy() const {
  return lb_policy_case() != LB_POLICY_NOT_SET;
}
inline void LoadBalancerSettings::clear_has_lb_policy() {
  _oneof_case_[0] = LB_POLICY_NOT_SET;
}
inline LoadBalancerSettings::LbPolicyCase LoadBalancerSettings::lb_policy_case() const {
  return LoadBalancerSettings::LbPolicyCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ConnectionPoolSettings_TCPSettings_TcpKeepalive

// uint32 probes = 1;
inline void ConnectionPoolSettings_TCPSettings_TcpKeepalive::clear_probes() {
  probes_ = 0u;
}
inline ::google::protobuf::uint32 ConnectionPoolSettings_TCPSettings_TcpKeepalive::probes() const {
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.ConnectionPoolSettings.TCPSettings.TcpKeepalive.probes)
  return probes_;
}
inline void ConnectionPoolSettings_TCPSettings_TcpKeepalive::set_probes(::google::protobuf::uint32 value) {
  
  probes_ = value;
  // @@protoc_insertion_point(field_set:istio.networking.v1alpha3.ConnectionPoolSettings.TCPSettings.TcpKeepalive.probes)
}

// .google.protobuf.Duration time = 2;
inline bool ConnectionPoolSettings_TCPSettings_TcpKeepalive::has_time() const {
  return this != internal_default_instance() && time_ != NULL;
}
inline const ::google::protobuf::Duration& ConnectionPoolSettings_TCPSettings_TcpKeepalive::time() const {
  const ::google::protobuf::Duration* p = time_;
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.ConnectionPoolSettings.TCPSettings.TcpKeepalive.time)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Duration*>(
      &::google::protobuf::_Duration_default_instance_);
}
inline ::google::protobuf::Duration* ConnectionPoolSettings_TCPSettings_TcpKeepalive::release_time() {
  // @@protoc_insertion_point(field_release:istio.networking.v1alpha3.ConnectionPoolSettings.TCPSettings.TcpKeepalive.time)
  
  ::google::protobuf::Duration* temp = time_;
  time_ = NULL;
  return temp;
}
inline ::google::protobuf::Duration* ConnectionPoolSettings_TCPSettings_TcpKeepalive::mutable_time() {
  
  if (time_ == NULL) {
    time_ = new ::google::protobuf::Duration;
  }
  // @@protoc_insertion_point(field_mutable:istio.networking.v1alpha3.ConnectionPoolSettings.TCPSettings.TcpKeepalive.time)
  return time_;
}
inline void ConnectionPoolSettings_TCPSettings_TcpKeepalive::set_allocated_time(::google::protobuf::Duration* time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(time_);
  }
  if (time) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(time)->GetArena();
    if (message_arena != submessage_arena) {
      time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, time, submessage_arena);
    }
    
  } else {
    
  }
  time_ = time;
  // @@protoc_insertion_point(field_set_allocated:istio.networking.v1alpha3.ConnectionPoolSettings.TCPSettings.TcpKeepalive.time)
}

// .google.protobuf.Duration interval = 3;
inline bool ConnectionPoolSettings_TCPSettings_TcpKeepalive::has_interval() const {
  return this != internal_default_instance() && interval_ != NULL;
}
inline const ::google::protobuf::Duration& ConnectionPoolSettings_TCPSettings_TcpKeepalive::interval() const {
  const ::google::protobuf::Duration* p = interval_;
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.ConnectionPoolSettings.TCPSettings.TcpKeepalive.interval)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Duration*>(
      &::google::protobuf::_Duration_default_instance_);
}
inline ::google::protobuf::Duration* ConnectionPoolSettings_TCPSettings_TcpKeepalive::release_interval() {
  // @@protoc_insertion_point(field_release:istio.networking.v1alpha3.ConnectionPoolSettings.TCPSettings.TcpKeepalive.interval)
  
  ::google::protobuf::Duration* temp = interval_;
  interval_ = NULL;
  return temp;
}
inline ::google::protobuf::Duration* ConnectionPoolSettings_TCPSettings_TcpKeepalive::mutable_interval() {
  
  if (interval_ == NULL) {
    interval_ = new ::google::protobuf::Duration;
  }
  // @@protoc_insertion_point(field_mutable:istio.networking.v1alpha3.ConnectionPoolSettings.TCPSettings.TcpKeepalive.interval)
  return interval_;
}
inline void ConnectionPoolSettings_TCPSettings_TcpKeepalive::set_allocated_interval(::google::protobuf::Duration* interval) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(interval_);
  }
  if (interval) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(interval)->GetArena();
    if (message_arena != submessage_arena) {
      interval = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, interval, submessage_arena);
    }
    
  } else {
    
  }
  interval_ = interval;
  // @@protoc_insertion_point(field_set_allocated:istio.networking.v1alpha3.ConnectionPoolSettings.TCPSettings.TcpKeepalive.interval)
}

// -------------------------------------------------------------------

// ConnectionPoolSettings_TCPSettings

// int32 max_connections = 1;
inline void ConnectionPoolSettings_TCPSettings::clear_max_connections() {
  max_connections_ = 0;
}
inline ::google::protobuf::int32 ConnectionPoolSettings_TCPSettings::max_connections() const {
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.ConnectionPoolSettings.TCPSettings.max_connections)
  return max_connections_;
}
inline void ConnectionPoolSettings_TCPSettings::set_max_connections(::google::protobuf::int32 value) {
  
  max_connections_ = value;
  // @@protoc_insertion_point(field_set:istio.networking.v1alpha3.ConnectionPoolSettings.TCPSettings.max_connections)
}

// .google.protobuf.Duration connect_timeout = 2;
inline bool ConnectionPoolSettings_TCPSettings::has_connect_timeout() const {
  return this != internal_default_instance() && connect_timeout_ != NULL;
}
inline const ::google::protobuf::Duration& ConnectionPoolSettings_TCPSettings::connect_timeout() const {
  const ::google::protobuf::Duration* p = connect_timeout_;
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.ConnectionPoolSettings.TCPSettings.connect_timeout)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Duration*>(
      &::google::protobuf::_Duration_default_instance_);
}
inline ::google::protobuf::Duration* ConnectionPoolSettings_TCPSettings::release_connect_timeout() {
  // @@protoc_insertion_point(field_release:istio.networking.v1alpha3.ConnectionPoolSettings.TCPSettings.connect_timeout)
  
  ::google::protobuf::Duration* temp = connect_timeout_;
  connect_timeout_ = NULL;
  return temp;
}
inline ::google::protobuf::Duration* ConnectionPoolSettings_TCPSettings::mutable_connect_timeout() {
  
  if (connect_timeout_ == NULL) {
    connect_timeout_ = new ::google::protobuf::Duration;
  }
  // @@protoc_insertion_point(field_mutable:istio.networking.v1alpha3.ConnectionPoolSettings.TCPSettings.connect_timeout)
  return connect_timeout_;
}
inline void ConnectionPoolSettings_TCPSettings::set_allocated_connect_timeout(::google::protobuf::Duration* connect_timeout) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(connect_timeout_);
  }
  if (connect_timeout) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(connect_timeout)->GetArena();
    if (message_arena != submessage_arena) {
      connect_timeout = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, connect_timeout, submessage_arena);
    }
    
  } else {
    
  }
  connect_timeout_ = connect_timeout;
  // @@protoc_insertion_point(field_set_allocated:istio.networking.v1alpha3.ConnectionPoolSettings.TCPSettings.connect_timeout)
}

// .istio.networking.v1alpha3.ConnectionPoolSettings.TCPSettings.TcpKeepalive tcp_keepalive = 3;
inline bool ConnectionPoolSettings_TCPSettings::has_tcp_keepalive() const {
  return this != internal_default_instance() && tcp_keepalive_ != NULL;
}
inline void ConnectionPoolSettings_TCPSettings::clear_tcp_keepalive() {
  if (GetArenaNoVirtual() == NULL && tcp_keepalive_ != NULL) {
    delete tcp_keepalive_;
  }
  tcp_keepalive_ = NULL;
}
inline const ::istio::networking::v1alpha3::ConnectionPoolSettings_TCPSettings_TcpKeepalive& ConnectionPoolSettings_TCPSettings::tcp_keepalive() const {
  const ::istio::networking::v1alpha3::ConnectionPoolSettings_TCPSettings_TcpKeepalive* p = tcp_keepalive_;
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.ConnectionPoolSettings.TCPSettings.tcp_keepalive)
  return p != NULL ? *p : *reinterpret_cast<const ::istio::networking::v1alpha3::ConnectionPoolSettings_TCPSettings_TcpKeepalive*>(
      &::istio::networking::v1alpha3::_ConnectionPoolSettings_TCPSettings_TcpKeepalive_default_instance_);
}
inline ::istio::networking::v1alpha3::ConnectionPoolSettings_TCPSettings_TcpKeepalive* ConnectionPoolSettings_TCPSettings::release_tcp_keepalive() {
  // @@protoc_insertion_point(field_release:istio.networking.v1alpha3.ConnectionPoolSettings.TCPSettings.tcp_keepalive)
  
  ::istio::networking::v1alpha3::ConnectionPoolSettings_TCPSettings_TcpKeepalive* temp = tcp_keepalive_;
  tcp_keepalive_ = NULL;
  return temp;
}
inline ::istio::networking::v1alpha3::ConnectionPoolSettings_TCPSettings_TcpKeepalive* ConnectionPoolSettings_TCPSettings::mutable_tcp_keepalive() {
  
  if (tcp_keepalive_ == NULL) {
    tcp_keepalive_ = new ::istio::networking::v1alpha3::ConnectionPoolSettings_TCPSettings_TcpKeepalive;
  }
  // @@protoc_insertion_point(field_mutable:istio.networking.v1alpha3.ConnectionPoolSettings.TCPSettings.tcp_keepalive)
  return tcp_keepalive_;
}
inline void ConnectionPoolSettings_TCPSettings::set_allocated_tcp_keepalive(::istio::networking::v1alpha3::ConnectionPoolSettings_TCPSettings_TcpKeepalive* tcp_keepalive) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete tcp_keepalive_;
  }
  if (tcp_keepalive) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tcp_keepalive = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tcp_keepalive, submessage_arena);
    }
    
  } else {
    
  }
  tcp_keepalive_ = tcp_keepalive;
  // @@protoc_insertion_point(field_set_allocated:istio.networking.v1alpha3.ConnectionPoolSettings.TCPSettings.tcp_keepalive)
}

// -------------------------------------------------------------------

// ConnectionPoolSettings_HTTPSettings

// int32 http1_max_pending_requests = 1;
inline void ConnectionPoolSettings_HTTPSettings::clear_http1_max_pending_requests() {
  http1_max_pending_requests_ = 0;
}
inline ::google::protobuf::int32 ConnectionPoolSettings_HTTPSettings::http1_max_pending_requests() const {
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.ConnectionPoolSettings.HTTPSettings.http1_max_pending_requests)
  return http1_max_pending_requests_;
}
inline void ConnectionPoolSettings_HTTPSettings::set_http1_max_pending_requests(::google::protobuf::int32 value) {
  
  http1_max_pending_requests_ = value;
  // @@protoc_insertion_point(field_set:istio.networking.v1alpha3.ConnectionPoolSettings.HTTPSettings.http1_max_pending_requests)
}

// int32 http2_max_requests = 2;
inline void ConnectionPoolSettings_HTTPSettings::clear_http2_max_requests() {
  http2_max_requests_ = 0;
}
inline ::google::protobuf::int32 ConnectionPoolSettings_HTTPSettings::http2_max_requests() const {
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.ConnectionPoolSettings.HTTPSettings.http2_max_requests)
  return http2_max_requests_;
}
inline void ConnectionPoolSettings_HTTPSettings::set_http2_max_requests(::google::protobuf::int32 value) {
  
  http2_max_requests_ = value;
  // @@protoc_insertion_point(field_set:istio.networking.v1alpha3.ConnectionPoolSettings.HTTPSettings.http2_max_requests)
}

// int32 max_requests_per_connection = 3;
inline void ConnectionPoolSettings_HTTPSettings::clear_max_requests_per_connection() {
  max_requests_per_connection_ = 0;
}
inline ::google::protobuf::int32 ConnectionPoolSettings_HTTPSettings::max_requests_per_connection() const {
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.ConnectionPoolSettings.HTTPSettings.max_requests_per_connection)
  return max_requests_per_connection_;
}
inline void ConnectionPoolSettings_HTTPSettings::set_max_requests_per_connection(::google::protobuf::int32 value) {
  
  max_requests_per_connection_ = value;
  // @@protoc_insertion_point(field_set:istio.networking.v1alpha3.ConnectionPoolSettings.HTTPSettings.max_requests_per_connection)
}

// int32 max_retries = 4;
inline void ConnectionPoolSettings_HTTPSettings::clear_max_retries() {
  max_retries_ = 0;
}
inline ::google::protobuf::int32 ConnectionPoolSettings_HTTPSettings::max_retries() const {
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.ConnectionPoolSettings.HTTPSettings.max_retries)
  return max_retries_;
}
inline void ConnectionPoolSettings_HTTPSettings::set_max_retries(::google::protobuf::int32 value) {
  
  max_retries_ = value;
  // @@protoc_insertion_point(field_set:istio.networking.v1alpha3.ConnectionPoolSettings.HTTPSettings.max_retries)
}

// -------------------------------------------------------------------

// ConnectionPoolSettings

// .istio.networking.v1alpha3.ConnectionPoolSettings.TCPSettings tcp = 1;
inline bool ConnectionPoolSettings::has_tcp() const {
  return this != internal_default_instance() && tcp_ != NULL;
}
inline void ConnectionPoolSettings::clear_tcp() {
  if (GetArenaNoVirtual() == NULL && tcp_ != NULL) {
    delete tcp_;
  }
  tcp_ = NULL;
}
inline const ::istio::networking::v1alpha3::ConnectionPoolSettings_TCPSettings& ConnectionPoolSettings::tcp() const {
  const ::istio::networking::v1alpha3::ConnectionPoolSettings_TCPSettings* p = tcp_;
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.ConnectionPoolSettings.tcp)
  return p != NULL ? *p : *reinterpret_cast<const ::istio::networking::v1alpha3::ConnectionPoolSettings_TCPSettings*>(
      &::istio::networking::v1alpha3::_ConnectionPoolSettings_TCPSettings_default_instance_);
}
inline ::istio::networking::v1alpha3::ConnectionPoolSettings_TCPSettings* ConnectionPoolSettings::release_tcp() {
  // @@protoc_insertion_point(field_release:istio.networking.v1alpha3.ConnectionPoolSettings.tcp)
  
  ::istio::networking::v1alpha3::ConnectionPoolSettings_TCPSettings* temp = tcp_;
  tcp_ = NULL;
  return temp;
}
inline ::istio::networking::v1alpha3::ConnectionPoolSettings_TCPSettings* ConnectionPoolSettings::mutable_tcp() {
  
  if (tcp_ == NULL) {
    tcp_ = new ::istio::networking::v1alpha3::ConnectionPoolSettings_TCPSettings;
  }
  // @@protoc_insertion_point(field_mutable:istio.networking.v1alpha3.ConnectionPoolSettings.tcp)
  return tcp_;
}
inline void ConnectionPoolSettings::set_allocated_tcp(::istio::networking::v1alpha3::ConnectionPoolSettings_TCPSettings* tcp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete tcp_;
  }
  if (tcp) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tcp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tcp, submessage_arena);
    }
    
  } else {
    
  }
  tcp_ = tcp;
  // @@protoc_insertion_point(field_set_allocated:istio.networking.v1alpha3.ConnectionPoolSettings.tcp)
}

// .istio.networking.v1alpha3.ConnectionPoolSettings.HTTPSettings http = 2;
inline bool ConnectionPoolSettings::has_http() const {
  return this != internal_default_instance() && http_ != NULL;
}
inline void ConnectionPoolSettings::clear_http() {
  if (GetArenaNoVirtual() == NULL && http_ != NULL) {
    delete http_;
  }
  http_ = NULL;
}
inline const ::istio::networking::v1alpha3::ConnectionPoolSettings_HTTPSettings& ConnectionPoolSettings::http() const {
  const ::istio::networking::v1alpha3::ConnectionPoolSettings_HTTPSettings* p = http_;
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.ConnectionPoolSettings.http)
  return p != NULL ? *p : *reinterpret_cast<const ::istio::networking::v1alpha3::ConnectionPoolSettings_HTTPSettings*>(
      &::istio::networking::v1alpha3::_ConnectionPoolSettings_HTTPSettings_default_instance_);
}
inline ::istio::networking::v1alpha3::ConnectionPoolSettings_HTTPSettings* ConnectionPoolSettings::release_http() {
  // @@protoc_insertion_point(field_release:istio.networking.v1alpha3.ConnectionPoolSettings.http)
  
  ::istio::networking::v1alpha3::ConnectionPoolSettings_HTTPSettings* temp = http_;
  http_ = NULL;
  return temp;
}
inline ::istio::networking::v1alpha3::ConnectionPoolSettings_HTTPSettings* ConnectionPoolSettings::mutable_http() {
  
  if (http_ == NULL) {
    http_ = new ::istio::networking::v1alpha3::ConnectionPoolSettings_HTTPSettings;
  }
  // @@protoc_insertion_point(field_mutable:istio.networking.v1alpha3.ConnectionPoolSettings.http)
  return http_;
}
inline void ConnectionPoolSettings::set_allocated_http(::istio::networking::v1alpha3::ConnectionPoolSettings_HTTPSettings* http) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete http_;
  }
  if (http) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      http = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, http, submessage_arena);
    }
    
  } else {
    
  }
  http_ = http;
  // @@protoc_insertion_point(field_set_allocated:istio.networking.v1alpha3.ConnectionPoolSettings.http)
}

// -------------------------------------------------------------------

// OutlierDetection

// int32 consecutive_errors = 1;
inline void OutlierDetection::clear_consecutive_errors() {
  consecutive_errors_ = 0;
}
inline ::google::protobuf::int32 OutlierDetection::consecutive_errors() const {
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.OutlierDetection.consecutive_errors)
  return consecutive_errors_;
}
inline void OutlierDetection::set_consecutive_errors(::google::protobuf::int32 value) {
  
  consecutive_errors_ = value;
  // @@protoc_insertion_point(field_set:istio.networking.v1alpha3.OutlierDetection.consecutive_errors)
}

// .google.protobuf.Duration interval = 2;
inline bool OutlierDetection::has_interval() const {
  return this != internal_default_instance() && interval_ != NULL;
}
inline const ::google::protobuf::Duration& OutlierDetection::interval() const {
  const ::google::protobuf::Duration* p = interval_;
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.OutlierDetection.interval)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Duration*>(
      &::google::protobuf::_Duration_default_instance_);
}
inline ::google::protobuf::Duration* OutlierDetection::release_interval() {
  // @@protoc_insertion_point(field_release:istio.networking.v1alpha3.OutlierDetection.interval)
  
  ::google::protobuf::Duration* temp = interval_;
  interval_ = NULL;
  return temp;
}
inline ::google::protobuf::Duration* OutlierDetection::mutable_interval() {
  
  if (interval_ == NULL) {
    interval_ = new ::google::protobuf::Duration;
  }
  // @@protoc_insertion_point(field_mutable:istio.networking.v1alpha3.OutlierDetection.interval)
  return interval_;
}
inline void OutlierDetection::set_allocated_interval(::google::protobuf::Duration* interval) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(interval_);
  }
  if (interval) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(interval)->GetArena();
    if (message_arena != submessage_arena) {
      interval = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, interval, submessage_arena);
    }
    
  } else {
    
  }
  interval_ = interval;
  // @@protoc_insertion_point(field_set_allocated:istio.networking.v1alpha3.OutlierDetection.interval)
}

// .google.protobuf.Duration base_ejection_time = 3;
inline bool OutlierDetection::has_base_ejection_time() const {
  return this != internal_default_instance() && base_ejection_time_ != NULL;
}
inline const ::google::protobuf::Duration& OutlierDetection::base_ejection_time() const {
  const ::google::protobuf::Duration* p = base_ejection_time_;
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.OutlierDetection.base_ejection_time)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Duration*>(
      &::google::protobuf::_Duration_default_instance_);
}
inline ::google::protobuf::Duration* OutlierDetection::release_base_ejection_time() {
  // @@protoc_insertion_point(field_release:istio.networking.v1alpha3.OutlierDetection.base_ejection_time)
  
  ::google::protobuf::Duration* temp = base_ejection_time_;
  base_ejection_time_ = NULL;
  return temp;
}
inline ::google::protobuf::Duration* OutlierDetection::mutable_base_ejection_time() {
  
  if (base_ejection_time_ == NULL) {
    base_ejection_time_ = new ::google::protobuf::Duration;
  }
  // @@protoc_insertion_point(field_mutable:istio.networking.v1alpha3.OutlierDetection.base_ejection_time)
  return base_ejection_time_;
}
inline void OutlierDetection::set_allocated_base_ejection_time(::google::protobuf::Duration* base_ejection_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(base_ejection_time_);
  }
  if (base_ejection_time) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(base_ejection_time)->GetArena();
    if (message_arena != submessage_arena) {
      base_ejection_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, base_ejection_time, submessage_arena);
    }
    
  } else {
    
  }
  base_ejection_time_ = base_ejection_time;
  // @@protoc_insertion_point(field_set_allocated:istio.networking.v1alpha3.OutlierDetection.base_ejection_time)
}

// int32 max_ejection_percent = 4;
inline void OutlierDetection::clear_max_ejection_percent() {
  max_ejection_percent_ = 0;
}
inline ::google::protobuf::int32 OutlierDetection::max_ejection_percent() const {
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.OutlierDetection.max_ejection_percent)
  return max_ejection_percent_;
}
inline void OutlierDetection::set_max_ejection_percent(::google::protobuf::int32 value) {
  
  max_ejection_percent_ = value;
  // @@protoc_insertion_point(field_set:istio.networking.v1alpha3.OutlierDetection.max_ejection_percent)
}

// int32 min_health_percent = 5;
inline void OutlierDetection::clear_min_health_percent() {
  min_health_percent_ = 0;
}
inline ::google::protobuf::int32 OutlierDetection::min_health_percent() const {
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.OutlierDetection.min_health_percent)
  return min_health_percent_;
}
inline void OutlierDetection::set_min_health_percent(::google::protobuf::int32 value) {
  
  min_health_percent_ = value;
  // @@protoc_insertion_point(field_set:istio.networking.v1alpha3.OutlierDetection.min_health_percent)
}

// -------------------------------------------------------------------

// TLSSettings

// .istio.networking.v1alpha3.TLSSettings.TLSmode mode = 1;
inline void TLSSettings::clear_mode() {
  mode_ = 0;
}
inline ::istio::networking::v1alpha3::TLSSettings_TLSmode TLSSettings::mode() const {
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.TLSSettings.mode)
  return static_cast< ::istio::networking::v1alpha3::TLSSettings_TLSmode >(mode_);
}
inline void TLSSettings::set_mode(::istio::networking::v1alpha3::TLSSettings_TLSmode value) {
  
  mode_ = value;
  // @@protoc_insertion_point(field_set:istio.networking.v1alpha3.TLSSettings.mode)
}

// string client_certificate = 2;
inline void TLSSettings::clear_client_certificate() {
  client_certificate_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TLSSettings::client_certificate() const {
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.TLSSettings.client_certificate)
  return client_certificate_.GetNoArena();
}
inline void TLSSettings::set_client_certificate(const ::std::string& value) {
  
  client_certificate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.networking.v1alpha3.TLSSettings.client_certificate)
}
#if LANG_CXX11
inline void TLSSettings::set_client_certificate(::std::string&& value) {
  
  client_certificate_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.networking.v1alpha3.TLSSettings.client_certificate)
}
#endif
inline void TLSSettings::set_client_certificate(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  client_certificate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.networking.v1alpha3.TLSSettings.client_certificate)
}
inline void TLSSettings::set_client_certificate(const char* value, size_t size) {
  
  client_certificate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.networking.v1alpha3.TLSSettings.client_certificate)
}
inline ::std::string* TLSSettings::mutable_client_certificate() {
  
  // @@protoc_insertion_point(field_mutable:istio.networking.v1alpha3.TLSSettings.client_certificate)
  return client_certificate_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TLSSettings::release_client_certificate() {
  // @@protoc_insertion_point(field_release:istio.networking.v1alpha3.TLSSettings.client_certificate)
  
  return client_certificate_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TLSSettings::set_allocated_client_certificate(::std::string* client_certificate) {
  if (client_certificate != NULL) {
    
  } else {
    
  }
  client_certificate_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_certificate);
  // @@protoc_insertion_point(field_set_allocated:istio.networking.v1alpha3.TLSSettings.client_certificate)
}

// string private_key = 3;
inline void TLSSettings::clear_private_key() {
  private_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TLSSettings::private_key() const {
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.TLSSettings.private_key)
  return private_key_.GetNoArena();
}
inline void TLSSettings::set_private_key(const ::std::string& value) {
  
  private_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.networking.v1alpha3.TLSSettings.private_key)
}
#if LANG_CXX11
inline void TLSSettings::set_private_key(::std::string&& value) {
  
  private_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.networking.v1alpha3.TLSSettings.private_key)
}
#endif
inline void TLSSettings::set_private_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  private_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.networking.v1alpha3.TLSSettings.private_key)
}
inline void TLSSettings::set_private_key(const char* value, size_t size) {
  
  private_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.networking.v1alpha3.TLSSettings.private_key)
}
inline ::std::string* TLSSettings::mutable_private_key() {
  
  // @@protoc_insertion_point(field_mutable:istio.networking.v1alpha3.TLSSettings.private_key)
  return private_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TLSSettings::release_private_key() {
  // @@protoc_insertion_point(field_release:istio.networking.v1alpha3.TLSSettings.private_key)
  
  return private_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TLSSettings::set_allocated_private_key(::std::string* private_key) {
  if (private_key != NULL) {
    
  } else {
    
  }
  private_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), private_key);
  // @@protoc_insertion_point(field_set_allocated:istio.networking.v1alpha3.TLSSettings.private_key)
}

// string ca_certificates = 4;
inline void TLSSettings::clear_ca_certificates() {
  ca_certificates_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TLSSettings::ca_certificates() const {
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.TLSSettings.ca_certificates)
  return ca_certificates_.GetNoArena();
}
inline void TLSSettings::set_ca_certificates(const ::std::string& value) {
  
  ca_certificates_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.networking.v1alpha3.TLSSettings.ca_certificates)
}
#if LANG_CXX11
inline void TLSSettings::set_ca_certificates(::std::string&& value) {
  
  ca_certificates_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.networking.v1alpha3.TLSSettings.ca_certificates)
}
#endif
inline void TLSSettings::set_ca_certificates(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ca_certificates_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.networking.v1alpha3.TLSSettings.ca_certificates)
}
inline void TLSSettings::set_ca_certificates(const char* value, size_t size) {
  
  ca_certificates_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.networking.v1alpha3.TLSSettings.ca_certificates)
}
inline ::std::string* TLSSettings::mutable_ca_certificates() {
  
  // @@protoc_insertion_point(field_mutable:istio.networking.v1alpha3.TLSSettings.ca_certificates)
  return ca_certificates_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TLSSettings::release_ca_certificates() {
  // @@protoc_insertion_point(field_release:istio.networking.v1alpha3.TLSSettings.ca_certificates)
  
  return ca_certificates_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TLSSettings::set_allocated_ca_certificates(::std::string* ca_certificates) {
  if (ca_certificates != NULL) {
    
  } else {
    
  }
  ca_certificates_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ca_certificates);
  // @@protoc_insertion_point(field_set_allocated:istio.networking.v1alpha3.TLSSettings.ca_certificates)
}

// repeated string subject_alt_names = 5;
inline int TLSSettings::subject_alt_names_size() const {
  return subject_alt_names_.size();
}
inline void TLSSettings::clear_subject_alt_names() {
  subject_alt_names_.Clear();
}
inline const ::std::string& TLSSettings::subject_alt_names(int index) const {
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.TLSSettings.subject_alt_names)
  return subject_alt_names_.Get(index);
}
inline ::std::string* TLSSettings::mutable_subject_alt_names(int index) {
  // @@protoc_insertion_point(field_mutable:istio.networking.v1alpha3.TLSSettings.subject_alt_names)
  return subject_alt_names_.Mutable(index);
}
inline void TLSSettings::set_subject_alt_names(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:istio.networking.v1alpha3.TLSSettings.subject_alt_names)
  subject_alt_names_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void TLSSettings::set_subject_alt_names(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:istio.networking.v1alpha3.TLSSettings.subject_alt_names)
  subject_alt_names_.Mutable(index)->assign(std::move(value));
}
#endif
inline void TLSSettings::set_subject_alt_names(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  subject_alt_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:istio.networking.v1alpha3.TLSSettings.subject_alt_names)
}
inline void TLSSettings::set_subject_alt_names(int index, const char* value, size_t size) {
  subject_alt_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:istio.networking.v1alpha3.TLSSettings.subject_alt_names)
}
inline ::std::string* TLSSettings::add_subject_alt_names() {
  // @@protoc_insertion_point(field_add_mutable:istio.networking.v1alpha3.TLSSettings.subject_alt_names)
  return subject_alt_names_.Add();
}
inline void TLSSettings::add_subject_alt_names(const ::std::string& value) {
  subject_alt_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:istio.networking.v1alpha3.TLSSettings.subject_alt_names)
}
#if LANG_CXX11
inline void TLSSettings::add_subject_alt_names(::std::string&& value) {
  subject_alt_names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:istio.networking.v1alpha3.TLSSettings.subject_alt_names)
}
#endif
inline void TLSSettings::add_subject_alt_names(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  subject_alt_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:istio.networking.v1alpha3.TLSSettings.subject_alt_names)
}
inline void TLSSettings::add_subject_alt_names(const char* value, size_t size) {
  subject_alt_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:istio.networking.v1alpha3.TLSSettings.subject_alt_names)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TLSSettings::subject_alt_names() const {
  // @@protoc_insertion_point(field_list:istio.networking.v1alpha3.TLSSettings.subject_alt_names)
  return subject_alt_names_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TLSSettings::mutable_subject_alt_names() {
  // @@protoc_insertion_point(field_mutable_list:istio.networking.v1alpha3.TLSSettings.subject_alt_names)
  return &subject_alt_names_;
}

// string sni = 6;
inline void TLSSettings::clear_sni() {
  sni_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TLSSettings::sni() const {
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.TLSSettings.sni)
  return sni_.GetNoArena();
}
inline void TLSSettings::set_sni(const ::std::string& value) {
  
  sni_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.networking.v1alpha3.TLSSettings.sni)
}
#if LANG_CXX11
inline void TLSSettings::set_sni(::std::string&& value) {
  
  sni_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.networking.v1alpha3.TLSSettings.sni)
}
#endif
inline void TLSSettings::set_sni(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sni_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.networking.v1alpha3.TLSSettings.sni)
}
inline void TLSSettings::set_sni(const char* value, size_t size) {
  
  sni_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.networking.v1alpha3.TLSSettings.sni)
}
inline ::std::string* TLSSettings::mutable_sni() {
  
  // @@protoc_insertion_point(field_mutable:istio.networking.v1alpha3.TLSSettings.sni)
  return sni_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TLSSettings::release_sni() {
  // @@protoc_insertion_point(field_release:istio.networking.v1alpha3.TLSSettings.sni)
  
  return sni_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TLSSettings::set_allocated_sni(::std::string* sni) {
  if (sni != NULL) {
    
  } else {
    
  }
  sni_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sni);
  // @@protoc_insertion_point(field_set_allocated:istio.networking.v1alpha3.TLSSettings.sni)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1alpha3
}  // namespace networking
}  // namespace istio

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::istio::networking::v1alpha3::LoadBalancerSettings_SimpleLB> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::istio::networking::v1alpha3::LoadBalancerSettings_SimpleLB>() {
  return ::istio::networking::v1alpha3::LoadBalancerSettings_SimpleLB_descriptor();
}
template <> struct is_proto_enum< ::istio::networking::v1alpha3::TLSSettings_TLSmode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::istio::networking::v1alpha3::TLSSettings_TLSmode>() {
  return ::istio::networking::v1alpha3::TLSSettings_TLSmode_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_networking_2fv1alpha3_2fdestination_5frule_2eproto__INCLUDED
