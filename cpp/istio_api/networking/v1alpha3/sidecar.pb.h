// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: networking/v1alpha3/sidecar.proto

#ifndef PROTOBUF_networking_2fv1alpha3_2fsidecar_2eproto__INCLUDED
#define PROTOBUF_networking_2fv1alpha3_2fsidecar_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "networking/v1alpha3/gateway.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_networking_2fv1alpha3_2fsidecar_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[5];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsSidecarImpl();
void InitDefaultsSidecar();
void InitDefaultsIstioIngressListenerImpl();
void InitDefaultsIstioIngressListener();
void InitDefaultsIstioEgressListenerImpl();
void InitDefaultsIstioEgressListener();
void InitDefaultsWorkloadSelector_LabelsEntry_DoNotUseImpl();
void InitDefaultsWorkloadSelector_LabelsEntry_DoNotUse();
void InitDefaultsWorkloadSelectorImpl();
void InitDefaultsWorkloadSelector();
inline void InitDefaults() {
  InitDefaultsSidecar();
  InitDefaultsIstioIngressListener();
  InitDefaultsIstioEgressListener();
  InitDefaultsWorkloadSelector_LabelsEntry_DoNotUse();
  InitDefaultsWorkloadSelector();
}
}  // namespace protobuf_networking_2fv1alpha3_2fsidecar_2eproto
namespace istio {
namespace networking {
namespace v1alpha3 {
class IstioEgressListener;
class IstioEgressListenerDefaultTypeInternal;
extern IstioEgressListenerDefaultTypeInternal _IstioEgressListener_default_instance_;
class IstioIngressListener;
class IstioIngressListenerDefaultTypeInternal;
extern IstioIngressListenerDefaultTypeInternal _IstioIngressListener_default_instance_;
class Sidecar;
class SidecarDefaultTypeInternal;
extern SidecarDefaultTypeInternal _Sidecar_default_instance_;
class WorkloadSelector;
class WorkloadSelectorDefaultTypeInternal;
extern WorkloadSelectorDefaultTypeInternal _WorkloadSelector_default_instance_;
class WorkloadSelector_LabelsEntry_DoNotUse;
class WorkloadSelector_LabelsEntry_DoNotUseDefaultTypeInternal;
extern WorkloadSelector_LabelsEntry_DoNotUseDefaultTypeInternal _WorkloadSelector_LabelsEntry_DoNotUse_default_instance_;
}  // namespace v1alpha3
}  // namespace networking
}  // namespace istio
namespace istio {
namespace networking {
namespace v1alpha3 {

enum CaptureMode {
  DEFAULT = 0,
  IPTABLES = 1,
  NONE = 2,
  CaptureMode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  CaptureMode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool CaptureMode_IsValid(int value);
const CaptureMode CaptureMode_MIN = DEFAULT;
const CaptureMode CaptureMode_MAX = NONE;
const int CaptureMode_ARRAYSIZE = CaptureMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* CaptureMode_descriptor();
inline const ::std::string& CaptureMode_Name(CaptureMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    CaptureMode_descriptor(), value);
}
inline bool CaptureMode_Parse(
    const ::std::string& name, CaptureMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CaptureMode>(
    CaptureMode_descriptor(), name, value);
}
// ===================================================================

class Sidecar : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:istio.networking.v1alpha3.Sidecar) */ {
 public:
  Sidecar();
  virtual ~Sidecar();

  Sidecar(const Sidecar& from);

  inline Sidecar& operator=(const Sidecar& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Sidecar(Sidecar&& from) noexcept
    : Sidecar() {
    *this = ::std::move(from);
  }

  inline Sidecar& operator=(Sidecar&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Sidecar& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Sidecar* internal_default_instance() {
    return reinterpret_cast<const Sidecar*>(
               &_Sidecar_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Sidecar* other);
  friend void swap(Sidecar& a, Sidecar& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Sidecar* New() const PROTOBUF_FINAL { return New(NULL); }

  Sidecar* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Sidecar& from);
  void MergeFrom(const Sidecar& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Sidecar* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .istio.networking.v1alpha3.IstioIngressListener ingress = 2;
  int ingress_size() const;
  void clear_ingress();
  static const int kIngressFieldNumber = 2;
  const ::istio::networking::v1alpha3::IstioIngressListener& ingress(int index) const;
  ::istio::networking::v1alpha3::IstioIngressListener* mutable_ingress(int index);
  ::istio::networking::v1alpha3::IstioIngressListener* add_ingress();
  ::google::protobuf::RepeatedPtrField< ::istio::networking::v1alpha3::IstioIngressListener >*
      mutable_ingress();
  const ::google::protobuf::RepeatedPtrField< ::istio::networking::v1alpha3::IstioIngressListener >&
      ingress() const;

  // repeated .istio.networking.v1alpha3.IstioEgressListener egress = 3;
  int egress_size() const;
  void clear_egress();
  static const int kEgressFieldNumber = 3;
  const ::istio::networking::v1alpha3::IstioEgressListener& egress(int index) const;
  ::istio::networking::v1alpha3::IstioEgressListener* mutable_egress(int index);
  ::istio::networking::v1alpha3::IstioEgressListener* add_egress();
  ::google::protobuf::RepeatedPtrField< ::istio::networking::v1alpha3::IstioEgressListener >*
      mutable_egress();
  const ::google::protobuf::RepeatedPtrField< ::istio::networking::v1alpha3::IstioEgressListener >&
      egress() const;

  // .istio.networking.v1alpha3.WorkloadSelector workload_selector = 1;
  bool has_workload_selector() const;
  void clear_workload_selector();
  static const int kWorkloadSelectorFieldNumber = 1;
  const ::istio::networking::v1alpha3::WorkloadSelector& workload_selector() const;
  ::istio::networking::v1alpha3::WorkloadSelector* release_workload_selector();
  ::istio::networking::v1alpha3::WorkloadSelector* mutable_workload_selector();
  void set_allocated_workload_selector(::istio::networking::v1alpha3::WorkloadSelector* workload_selector);

  // @@protoc_insertion_point(class_scope:istio.networking.v1alpha3.Sidecar)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::istio::networking::v1alpha3::IstioIngressListener > ingress_;
  ::google::protobuf::RepeatedPtrField< ::istio::networking::v1alpha3::IstioEgressListener > egress_;
  ::istio::networking::v1alpha3::WorkloadSelector* workload_selector_;
  mutable int _cached_size_;
  friend struct ::protobuf_networking_2fv1alpha3_2fsidecar_2eproto::TableStruct;
  friend void ::protobuf_networking_2fv1alpha3_2fsidecar_2eproto::InitDefaultsSidecarImpl();
};
// -------------------------------------------------------------------

class IstioIngressListener : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:istio.networking.v1alpha3.IstioIngressListener) */ {
 public:
  IstioIngressListener();
  virtual ~IstioIngressListener();

  IstioIngressListener(const IstioIngressListener& from);

  inline IstioIngressListener& operator=(const IstioIngressListener& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IstioIngressListener(IstioIngressListener&& from) noexcept
    : IstioIngressListener() {
    *this = ::std::move(from);
  }

  inline IstioIngressListener& operator=(IstioIngressListener&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const IstioIngressListener& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IstioIngressListener* internal_default_instance() {
    return reinterpret_cast<const IstioIngressListener*>(
               &_IstioIngressListener_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(IstioIngressListener* other);
  friend void swap(IstioIngressListener& a, IstioIngressListener& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IstioIngressListener* New() const PROTOBUF_FINAL { return New(NULL); }

  IstioIngressListener* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const IstioIngressListener& from);
  void MergeFrom(const IstioIngressListener& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(IstioIngressListener* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string bind = 2;
  void clear_bind();
  static const int kBindFieldNumber = 2;
  const ::std::string& bind() const;
  void set_bind(const ::std::string& value);
  #if LANG_CXX11
  void set_bind(::std::string&& value);
  #endif
  void set_bind(const char* value);
  void set_bind(const char* value, size_t size);
  ::std::string* mutable_bind();
  ::std::string* release_bind();
  void set_allocated_bind(::std::string* bind);

  // string default_endpoint = 4;
  void clear_default_endpoint();
  static const int kDefaultEndpointFieldNumber = 4;
  const ::std::string& default_endpoint() const;
  void set_default_endpoint(const ::std::string& value);
  #if LANG_CXX11
  void set_default_endpoint(::std::string&& value);
  #endif
  void set_default_endpoint(const char* value);
  void set_default_endpoint(const char* value, size_t size);
  ::std::string* mutable_default_endpoint();
  ::std::string* release_default_endpoint();
  void set_allocated_default_endpoint(::std::string* default_endpoint);

  // .istio.networking.v1alpha3.Port port = 1;
  bool has_port() const;
  void clear_port();
  static const int kPortFieldNumber = 1;
  const ::istio::networking::v1alpha3::Port& port() const;
  ::istio::networking::v1alpha3::Port* release_port();
  ::istio::networking::v1alpha3::Port* mutable_port();
  void set_allocated_port(::istio::networking::v1alpha3::Port* port);

  // .istio.networking.v1alpha3.CaptureMode capture_mode = 3;
  void clear_capture_mode();
  static const int kCaptureModeFieldNumber = 3;
  ::istio::networking::v1alpha3::CaptureMode capture_mode() const;
  void set_capture_mode(::istio::networking::v1alpha3::CaptureMode value);

  // @@protoc_insertion_point(class_scope:istio.networking.v1alpha3.IstioIngressListener)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr bind_;
  ::google::protobuf::internal::ArenaStringPtr default_endpoint_;
  ::istio::networking::v1alpha3::Port* port_;
  int capture_mode_;
  mutable int _cached_size_;
  friend struct ::protobuf_networking_2fv1alpha3_2fsidecar_2eproto::TableStruct;
  friend void ::protobuf_networking_2fv1alpha3_2fsidecar_2eproto::InitDefaultsIstioIngressListenerImpl();
};
// -------------------------------------------------------------------

class IstioEgressListener : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:istio.networking.v1alpha3.IstioEgressListener) */ {
 public:
  IstioEgressListener();
  virtual ~IstioEgressListener();

  IstioEgressListener(const IstioEgressListener& from);

  inline IstioEgressListener& operator=(const IstioEgressListener& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IstioEgressListener(IstioEgressListener&& from) noexcept
    : IstioEgressListener() {
    *this = ::std::move(from);
  }

  inline IstioEgressListener& operator=(IstioEgressListener&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const IstioEgressListener& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IstioEgressListener* internal_default_instance() {
    return reinterpret_cast<const IstioEgressListener*>(
               &_IstioEgressListener_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(IstioEgressListener* other);
  friend void swap(IstioEgressListener& a, IstioEgressListener& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IstioEgressListener* New() const PROTOBUF_FINAL { return New(NULL); }

  IstioEgressListener* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const IstioEgressListener& from);
  void MergeFrom(const IstioEgressListener& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(IstioEgressListener* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string hosts = 4;
  int hosts_size() const;
  void clear_hosts();
  static const int kHostsFieldNumber = 4;
  const ::std::string& hosts(int index) const;
  ::std::string* mutable_hosts(int index);
  void set_hosts(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_hosts(int index, ::std::string&& value);
  #endif
  void set_hosts(int index, const char* value);
  void set_hosts(int index, const char* value, size_t size);
  ::std::string* add_hosts();
  void add_hosts(const ::std::string& value);
  #if LANG_CXX11
  void add_hosts(::std::string&& value);
  #endif
  void add_hosts(const char* value);
  void add_hosts(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& hosts() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_hosts();

  // string bind = 2;
  void clear_bind();
  static const int kBindFieldNumber = 2;
  const ::std::string& bind() const;
  void set_bind(const ::std::string& value);
  #if LANG_CXX11
  void set_bind(::std::string&& value);
  #endif
  void set_bind(const char* value);
  void set_bind(const char* value, size_t size);
  ::std::string* mutable_bind();
  ::std::string* release_bind();
  void set_allocated_bind(::std::string* bind);

  // .istio.networking.v1alpha3.Port port = 1;
  bool has_port() const;
  void clear_port();
  static const int kPortFieldNumber = 1;
  const ::istio::networking::v1alpha3::Port& port() const;
  ::istio::networking::v1alpha3::Port* release_port();
  ::istio::networking::v1alpha3::Port* mutable_port();
  void set_allocated_port(::istio::networking::v1alpha3::Port* port);

  // .istio.networking.v1alpha3.CaptureMode capture_mode = 3;
  void clear_capture_mode();
  static const int kCaptureModeFieldNumber = 3;
  ::istio::networking::v1alpha3::CaptureMode capture_mode() const;
  void set_capture_mode(::istio::networking::v1alpha3::CaptureMode value);

  // @@protoc_insertion_point(class_scope:istio.networking.v1alpha3.IstioEgressListener)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> hosts_;
  ::google::protobuf::internal::ArenaStringPtr bind_;
  ::istio::networking::v1alpha3::Port* port_;
  int capture_mode_;
  mutable int _cached_size_;
  friend struct ::protobuf_networking_2fv1alpha3_2fsidecar_2eproto::TableStruct;
  friend void ::protobuf_networking_2fv1alpha3_2fsidecar_2eproto::InitDefaultsIstioEgressListenerImpl();
};
// -------------------------------------------------------------------

class WorkloadSelector_LabelsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<WorkloadSelector_LabelsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<WorkloadSelector_LabelsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  WorkloadSelector_LabelsEntry_DoNotUse();
  WorkloadSelector_LabelsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const WorkloadSelector_LabelsEntry_DoNotUse& other);
  static const WorkloadSelector_LabelsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const WorkloadSelector_LabelsEntry_DoNotUse*>(&_WorkloadSelector_LabelsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class WorkloadSelector : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:istio.networking.v1alpha3.WorkloadSelector) */ {
 public:
  WorkloadSelector();
  virtual ~WorkloadSelector();

  WorkloadSelector(const WorkloadSelector& from);

  inline WorkloadSelector& operator=(const WorkloadSelector& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WorkloadSelector(WorkloadSelector&& from) noexcept
    : WorkloadSelector() {
    *this = ::std::move(from);
  }

  inline WorkloadSelector& operator=(WorkloadSelector&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WorkloadSelector& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WorkloadSelector* internal_default_instance() {
    return reinterpret_cast<const WorkloadSelector*>(
               &_WorkloadSelector_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(WorkloadSelector* other);
  friend void swap(WorkloadSelector& a, WorkloadSelector& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WorkloadSelector* New() const PROTOBUF_FINAL { return New(NULL); }

  WorkloadSelector* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const WorkloadSelector& from);
  void MergeFrom(const WorkloadSelector& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(WorkloadSelector* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> labels = 1;
  int labels_size() const;
  void clear_labels();
  static const int kLabelsFieldNumber = 1;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      labels() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_labels();

  // @@protoc_insertion_point(class_scope:istio.networking.v1alpha3.WorkloadSelector)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      WorkloadSelector_LabelsEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > labels_;
  mutable int _cached_size_;
  friend struct ::protobuf_networking_2fv1alpha3_2fsidecar_2eproto::TableStruct;
  friend void ::protobuf_networking_2fv1alpha3_2fsidecar_2eproto::InitDefaultsWorkloadSelectorImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Sidecar

// .istio.networking.v1alpha3.WorkloadSelector workload_selector = 1;
inline bool Sidecar::has_workload_selector() const {
  return this != internal_default_instance() && workload_selector_ != NULL;
}
inline void Sidecar::clear_workload_selector() {
  if (GetArenaNoVirtual() == NULL && workload_selector_ != NULL) {
    delete workload_selector_;
  }
  workload_selector_ = NULL;
}
inline const ::istio::networking::v1alpha3::WorkloadSelector& Sidecar::workload_selector() const {
  const ::istio::networking::v1alpha3::WorkloadSelector* p = workload_selector_;
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.Sidecar.workload_selector)
  return p != NULL ? *p : *reinterpret_cast<const ::istio::networking::v1alpha3::WorkloadSelector*>(
      &::istio::networking::v1alpha3::_WorkloadSelector_default_instance_);
}
inline ::istio::networking::v1alpha3::WorkloadSelector* Sidecar::release_workload_selector() {
  // @@protoc_insertion_point(field_release:istio.networking.v1alpha3.Sidecar.workload_selector)
  
  ::istio::networking::v1alpha3::WorkloadSelector* temp = workload_selector_;
  workload_selector_ = NULL;
  return temp;
}
inline ::istio::networking::v1alpha3::WorkloadSelector* Sidecar::mutable_workload_selector() {
  
  if (workload_selector_ == NULL) {
    workload_selector_ = new ::istio::networking::v1alpha3::WorkloadSelector;
  }
  // @@protoc_insertion_point(field_mutable:istio.networking.v1alpha3.Sidecar.workload_selector)
  return workload_selector_;
}
inline void Sidecar::set_allocated_workload_selector(::istio::networking::v1alpha3::WorkloadSelector* workload_selector) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete workload_selector_;
  }
  if (workload_selector) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      workload_selector = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, workload_selector, submessage_arena);
    }
    
  } else {
    
  }
  workload_selector_ = workload_selector;
  // @@protoc_insertion_point(field_set_allocated:istio.networking.v1alpha3.Sidecar.workload_selector)
}

// repeated .istio.networking.v1alpha3.IstioIngressListener ingress = 2;
inline int Sidecar::ingress_size() const {
  return ingress_.size();
}
inline void Sidecar::clear_ingress() {
  ingress_.Clear();
}
inline const ::istio::networking::v1alpha3::IstioIngressListener& Sidecar::ingress(int index) const {
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.Sidecar.ingress)
  return ingress_.Get(index);
}
inline ::istio::networking::v1alpha3::IstioIngressListener* Sidecar::mutable_ingress(int index) {
  // @@protoc_insertion_point(field_mutable:istio.networking.v1alpha3.Sidecar.ingress)
  return ingress_.Mutable(index);
}
inline ::istio::networking::v1alpha3::IstioIngressListener* Sidecar::add_ingress() {
  // @@protoc_insertion_point(field_add:istio.networking.v1alpha3.Sidecar.ingress)
  return ingress_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::istio::networking::v1alpha3::IstioIngressListener >*
Sidecar::mutable_ingress() {
  // @@protoc_insertion_point(field_mutable_list:istio.networking.v1alpha3.Sidecar.ingress)
  return &ingress_;
}
inline const ::google::protobuf::RepeatedPtrField< ::istio::networking::v1alpha3::IstioIngressListener >&
Sidecar::ingress() const {
  // @@protoc_insertion_point(field_list:istio.networking.v1alpha3.Sidecar.ingress)
  return ingress_;
}

// repeated .istio.networking.v1alpha3.IstioEgressListener egress = 3;
inline int Sidecar::egress_size() const {
  return egress_.size();
}
inline void Sidecar::clear_egress() {
  egress_.Clear();
}
inline const ::istio::networking::v1alpha3::IstioEgressListener& Sidecar::egress(int index) const {
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.Sidecar.egress)
  return egress_.Get(index);
}
inline ::istio::networking::v1alpha3::IstioEgressListener* Sidecar::mutable_egress(int index) {
  // @@protoc_insertion_point(field_mutable:istio.networking.v1alpha3.Sidecar.egress)
  return egress_.Mutable(index);
}
inline ::istio::networking::v1alpha3::IstioEgressListener* Sidecar::add_egress() {
  // @@protoc_insertion_point(field_add:istio.networking.v1alpha3.Sidecar.egress)
  return egress_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::istio::networking::v1alpha3::IstioEgressListener >*
Sidecar::mutable_egress() {
  // @@protoc_insertion_point(field_mutable_list:istio.networking.v1alpha3.Sidecar.egress)
  return &egress_;
}
inline const ::google::protobuf::RepeatedPtrField< ::istio::networking::v1alpha3::IstioEgressListener >&
Sidecar::egress() const {
  // @@protoc_insertion_point(field_list:istio.networking.v1alpha3.Sidecar.egress)
  return egress_;
}

// -------------------------------------------------------------------

// IstioIngressListener

// .istio.networking.v1alpha3.Port port = 1;
inline bool IstioIngressListener::has_port() const {
  return this != internal_default_instance() && port_ != NULL;
}
inline const ::istio::networking::v1alpha3::Port& IstioIngressListener::port() const {
  const ::istio::networking::v1alpha3::Port* p = port_;
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.IstioIngressListener.port)
  return p != NULL ? *p : *reinterpret_cast<const ::istio::networking::v1alpha3::Port*>(
      &::istio::networking::v1alpha3::_Port_default_instance_);
}
inline ::istio::networking::v1alpha3::Port* IstioIngressListener::release_port() {
  // @@protoc_insertion_point(field_release:istio.networking.v1alpha3.IstioIngressListener.port)
  
  ::istio::networking::v1alpha3::Port* temp = port_;
  port_ = NULL;
  return temp;
}
inline ::istio::networking::v1alpha3::Port* IstioIngressListener::mutable_port() {
  
  if (port_ == NULL) {
    port_ = new ::istio::networking::v1alpha3::Port;
  }
  // @@protoc_insertion_point(field_mutable:istio.networking.v1alpha3.IstioIngressListener.port)
  return port_;
}
inline void IstioIngressListener::set_allocated_port(::istio::networking::v1alpha3::Port* port) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(port_);
  }
  if (port) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      port = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, port, submessage_arena);
    }
    
  } else {
    
  }
  port_ = port;
  // @@protoc_insertion_point(field_set_allocated:istio.networking.v1alpha3.IstioIngressListener.port)
}

// string bind = 2;
inline void IstioIngressListener::clear_bind() {
  bind_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& IstioIngressListener::bind() const {
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.IstioIngressListener.bind)
  return bind_.GetNoArena();
}
inline void IstioIngressListener::set_bind(const ::std::string& value) {
  
  bind_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.networking.v1alpha3.IstioIngressListener.bind)
}
#if LANG_CXX11
inline void IstioIngressListener::set_bind(::std::string&& value) {
  
  bind_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.networking.v1alpha3.IstioIngressListener.bind)
}
#endif
inline void IstioIngressListener::set_bind(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  bind_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.networking.v1alpha3.IstioIngressListener.bind)
}
inline void IstioIngressListener::set_bind(const char* value, size_t size) {
  
  bind_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.networking.v1alpha3.IstioIngressListener.bind)
}
inline ::std::string* IstioIngressListener::mutable_bind() {
  
  // @@protoc_insertion_point(field_mutable:istio.networking.v1alpha3.IstioIngressListener.bind)
  return bind_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IstioIngressListener::release_bind() {
  // @@protoc_insertion_point(field_release:istio.networking.v1alpha3.IstioIngressListener.bind)
  
  return bind_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IstioIngressListener::set_allocated_bind(::std::string* bind) {
  if (bind != NULL) {
    
  } else {
    
  }
  bind_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bind);
  // @@protoc_insertion_point(field_set_allocated:istio.networking.v1alpha3.IstioIngressListener.bind)
}

// .istio.networking.v1alpha3.CaptureMode capture_mode = 3;
inline void IstioIngressListener::clear_capture_mode() {
  capture_mode_ = 0;
}
inline ::istio::networking::v1alpha3::CaptureMode IstioIngressListener::capture_mode() const {
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.IstioIngressListener.capture_mode)
  return static_cast< ::istio::networking::v1alpha3::CaptureMode >(capture_mode_);
}
inline void IstioIngressListener::set_capture_mode(::istio::networking::v1alpha3::CaptureMode value) {
  
  capture_mode_ = value;
  // @@protoc_insertion_point(field_set:istio.networking.v1alpha3.IstioIngressListener.capture_mode)
}

// string default_endpoint = 4;
inline void IstioIngressListener::clear_default_endpoint() {
  default_endpoint_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& IstioIngressListener::default_endpoint() const {
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.IstioIngressListener.default_endpoint)
  return default_endpoint_.GetNoArena();
}
inline void IstioIngressListener::set_default_endpoint(const ::std::string& value) {
  
  default_endpoint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.networking.v1alpha3.IstioIngressListener.default_endpoint)
}
#if LANG_CXX11
inline void IstioIngressListener::set_default_endpoint(::std::string&& value) {
  
  default_endpoint_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.networking.v1alpha3.IstioIngressListener.default_endpoint)
}
#endif
inline void IstioIngressListener::set_default_endpoint(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  default_endpoint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.networking.v1alpha3.IstioIngressListener.default_endpoint)
}
inline void IstioIngressListener::set_default_endpoint(const char* value, size_t size) {
  
  default_endpoint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.networking.v1alpha3.IstioIngressListener.default_endpoint)
}
inline ::std::string* IstioIngressListener::mutable_default_endpoint() {
  
  // @@protoc_insertion_point(field_mutable:istio.networking.v1alpha3.IstioIngressListener.default_endpoint)
  return default_endpoint_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IstioIngressListener::release_default_endpoint() {
  // @@protoc_insertion_point(field_release:istio.networking.v1alpha3.IstioIngressListener.default_endpoint)
  
  return default_endpoint_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IstioIngressListener::set_allocated_default_endpoint(::std::string* default_endpoint) {
  if (default_endpoint != NULL) {
    
  } else {
    
  }
  default_endpoint_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), default_endpoint);
  // @@protoc_insertion_point(field_set_allocated:istio.networking.v1alpha3.IstioIngressListener.default_endpoint)
}

// -------------------------------------------------------------------

// IstioEgressListener

// .istio.networking.v1alpha3.Port port = 1;
inline bool IstioEgressListener::has_port() const {
  return this != internal_default_instance() && port_ != NULL;
}
inline const ::istio::networking::v1alpha3::Port& IstioEgressListener::port() const {
  const ::istio::networking::v1alpha3::Port* p = port_;
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.IstioEgressListener.port)
  return p != NULL ? *p : *reinterpret_cast<const ::istio::networking::v1alpha3::Port*>(
      &::istio::networking::v1alpha3::_Port_default_instance_);
}
inline ::istio::networking::v1alpha3::Port* IstioEgressListener::release_port() {
  // @@protoc_insertion_point(field_release:istio.networking.v1alpha3.IstioEgressListener.port)
  
  ::istio::networking::v1alpha3::Port* temp = port_;
  port_ = NULL;
  return temp;
}
inline ::istio::networking::v1alpha3::Port* IstioEgressListener::mutable_port() {
  
  if (port_ == NULL) {
    port_ = new ::istio::networking::v1alpha3::Port;
  }
  // @@protoc_insertion_point(field_mutable:istio.networking.v1alpha3.IstioEgressListener.port)
  return port_;
}
inline void IstioEgressListener::set_allocated_port(::istio::networking::v1alpha3::Port* port) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(port_);
  }
  if (port) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      port = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, port, submessage_arena);
    }
    
  } else {
    
  }
  port_ = port;
  // @@protoc_insertion_point(field_set_allocated:istio.networking.v1alpha3.IstioEgressListener.port)
}

// string bind = 2;
inline void IstioEgressListener::clear_bind() {
  bind_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& IstioEgressListener::bind() const {
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.IstioEgressListener.bind)
  return bind_.GetNoArena();
}
inline void IstioEgressListener::set_bind(const ::std::string& value) {
  
  bind_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.networking.v1alpha3.IstioEgressListener.bind)
}
#if LANG_CXX11
inline void IstioEgressListener::set_bind(::std::string&& value) {
  
  bind_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.networking.v1alpha3.IstioEgressListener.bind)
}
#endif
inline void IstioEgressListener::set_bind(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  bind_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.networking.v1alpha3.IstioEgressListener.bind)
}
inline void IstioEgressListener::set_bind(const char* value, size_t size) {
  
  bind_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.networking.v1alpha3.IstioEgressListener.bind)
}
inline ::std::string* IstioEgressListener::mutable_bind() {
  
  // @@protoc_insertion_point(field_mutable:istio.networking.v1alpha3.IstioEgressListener.bind)
  return bind_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IstioEgressListener::release_bind() {
  // @@protoc_insertion_point(field_release:istio.networking.v1alpha3.IstioEgressListener.bind)
  
  return bind_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IstioEgressListener::set_allocated_bind(::std::string* bind) {
  if (bind != NULL) {
    
  } else {
    
  }
  bind_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bind);
  // @@protoc_insertion_point(field_set_allocated:istio.networking.v1alpha3.IstioEgressListener.bind)
}

// .istio.networking.v1alpha3.CaptureMode capture_mode = 3;
inline void IstioEgressListener::clear_capture_mode() {
  capture_mode_ = 0;
}
inline ::istio::networking::v1alpha3::CaptureMode IstioEgressListener::capture_mode() const {
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.IstioEgressListener.capture_mode)
  return static_cast< ::istio::networking::v1alpha3::CaptureMode >(capture_mode_);
}
inline void IstioEgressListener::set_capture_mode(::istio::networking::v1alpha3::CaptureMode value) {
  
  capture_mode_ = value;
  // @@protoc_insertion_point(field_set:istio.networking.v1alpha3.IstioEgressListener.capture_mode)
}

// repeated string hosts = 4;
inline int IstioEgressListener::hosts_size() const {
  return hosts_.size();
}
inline void IstioEgressListener::clear_hosts() {
  hosts_.Clear();
}
inline const ::std::string& IstioEgressListener::hosts(int index) const {
  // @@protoc_insertion_point(field_get:istio.networking.v1alpha3.IstioEgressListener.hosts)
  return hosts_.Get(index);
}
inline ::std::string* IstioEgressListener::mutable_hosts(int index) {
  // @@protoc_insertion_point(field_mutable:istio.networking.v1alpha3.IstioEgressListener.hosts)
  return hosts_.Mutable(index);
}
inline void IstioEgressListener::set_hosts(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:istio.networking.v1alpha3.IstioEgressListener.hosts)
  hosts_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void IstioEgressListener::set_hosts(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:istio.networking.v1alpha3.IstioEgressListener.hosts)
  hosts_.Mutable(index)->assign(std::move(value));
}
#endif
inline void IstioEgressListener::set_hosts(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  hosts_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:istio.networking.v1alpha3.IstioEgressListener.hosts)
}
inline void IstioEgressListener::set_hosts(int index, const char* value, size_t size) {
  hosts_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:istio.networking.v1alpha3.IstioEgressListener.hosts)
}
inline ::std::string* IstioEgressListener::add_hosts() {
  // @@protoc_insertion_point(field_add_mutable:istio.networking.v1alpha3.IstioEgressListener.hosts)
  return hosts_.Add();
}
inline void IstioEgressListener::add_hosts(const ::std::string& value) {
  hosts_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:istio.networking.v1alpha3.IstioEgressListener.hosts)
}
#if LANG_CXX11
inline void IstioEgressListener::add_hosts(::std::string&& value) {
  hosts_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:istio.networking.v1alpha3.IstioEgressListener.hosts)
}
#endif
inline void IstioEgressListener::add_hosts(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  hosts_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:istio.networking.v1alpha3.IstioEgressListener.hosts)
}
inline void IstioEgressListener::add_hosts(const char* value, size_t size) {
  hosts_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:istio.networking.v1alpha3.IstioEgressListener.hosts)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
IstioEgressListener::hosts() const {
  // @@protoc_insertion_point(field_list:istio.networking.v1alpha3.IstioEgressListener.hosts)
  return hosts_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
IstioEgressListener::mutable_hosts() {
  // @@protoc_insertion_point(field_mutable_list:istio.networking.v1alpha3.IstioEgressListener.hosts)
  return &hosts_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// WorkloadSelector

// map<string, string> labels = 1;
inline int WorkloadSelector::labels_size() const {
  return labels_.size();
}
inline void WorkloadSelector::clear_labels() {
  labels_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
WorkloadSelector::labels() const {
  // @@protoc_insertion_point(field_map:istio.networking.v1alpha3.WorkloadSelector.labels)
  return labels_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
WorkloadSelector::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_map:istio.networking.v1alpha3.WorkloadSelector.labels)
  return labels_.MutableMap();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1alpha3
}  // namespace networking
}  // namespace istio

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::istio::networking::v1alpha3::CaptureMode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::istio::networking::v1alpha3::CaptureMode>() {
  return ::istio::networking::v1alpha3::CaptureMode_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_networking_2fv1alpha3_2fsidecar_2eproto__INCLUDED
