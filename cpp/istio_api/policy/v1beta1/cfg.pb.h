// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: policy/v1beta1/cfg.proto

#ifndef PROTOBUF_policy_2fv1beta1_2fcfg_2eproto__INCLUDED
#define PROTOBUF_policy_2fv1beta1_2fcfg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "gogoproto/gogo.pb.h"
#include <google/protobuf/struct.pb.h>
#include <google/protobuf/duration.pb.h>
#include "policy/v1beta1/value_type.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_policy_2fv1beta1_2fcfg_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[19];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsAttributeManifest_AttributeInfoImpl();
void InitDefaultsAttributeManifest_AttributeInfo();
void InitDefaultsAttributeManifest_AttributesEntry_DoNotUseImpl();
void InitDefaultsAttributeManifest_AttributesEntry_DoNotUse();
void InitDefaultsAttributeManifestImpl();
void InitDefaultsAttributeManifest();
void InitDefaultsRule_HeaderOperationTemplateImpl();
void InitDefaultsRule_HeaderOperationTemplate();
void InitDefaultsRuleImpl();
void InitDefaultsRule();
void InitDefaultsActionImpl();
void InitDefaultsAction();
void InitDefaultsInstance_AttributeBindingsEntry_DoNotUseImpl();
void InitDefaultsInstance_AttributeBindingsEntry_DoNotUse();
void InitDefaultsInstanceImpl();
void InitDefaultsInstance();
void InitDefaultsHandlerImpl();
void InitDefaultsHandler();
void InitDefaultsConnectionImpl();
void InitDefaultsConnection();
void InitDefaultsSamplingImpl();
void InitDefaultsSampling();
void InitDefaultsRandomSamplingImpl();
void InitDefaultsRandomSampling();
void InitDefaultsRateLimitSamplingImpl();
void InitDefaultsRateLimitSampling();
void InitDefaultsFractionalPercentImpl();
void InitDefaultsFractionalPercent();
void InitDefaultsAuthenticationImpl();
void InitDefaultsAuthentication();
void InitDefaultsTlsImpl();
void InitDefaultsTls();
void InitDefaultsOAuth_EndpointParamsEntry_DoNotUseImpl();
void InitDefaultsOAuth_EndpointParamsEntry_DoNotUse();
void InitDefaultsOAuthImpl();
void InitDefaultsOAuth();
void InitDefaultsMutualImpl();
void InitDefaultsMutual();
inline void InitDefaults() {
  InitDefaultsAttributeManifest_AttributeInfo();
  InitDefaultsAttributeManifest_AttributesEntry_DoNotUse();
  InitDefaultsAttributeManifest();
  InitDefaultsRule_HeaderOperationTemplate();
  InitDefaultsRule();
  InitDefaultsAction();
  InitDefaultsInstance_AttributeBindingsEntry_DoNotUse();
  InitDefaultsInstance();
  InitDefaultsHandler();
  InitDefaultsConnection();
  InitDefaultsSampling();
  InitDefaultsRandomSampling();
  InitDefaultsRateLimitSampling();
  InitDefaultsFractionalPercent();
  InitDefaultsAuthentication();
  InitDefaultsTls();
  InitDefaultsOAuth_EndpointParamsEntry_DoNotUse();
  InitDefaultsOAuth();
  InitDefaultsMutual();
}
}  // namespace protobuf_policy_2fv1beta1_2fcfg_2eproto
namespace istio {
namespace policy {
namespace v1beta1 {
class Action;
class ActionDefaultTypeInternal;
extern ActionDefaultTypeInternal _Action_default_instance_;
class AttributeManifest;
class AttributeManifestDefaultTypeInternal;
extern AttributeManifestDefaultTypeInternal _AttributeManifest_default_instance_;
class AttributeManifest_AttributeInfo;
class AttributeManifest_AttributeInfoDefaultTypeInternal;
extern AttributeManifest_AttributeInfoDefaultTypeInternal _AttributeManifest_AttributeInfo_default_instance_;
class AttributeManifest_AttributesEntry_DoNotUse;
class AttributeManifest_AttributesEntry_DoNotUseDefaultTypeInternal;
extern AttributeManifest_AttributesEntry_DoNotUseDefaultTypeInternal _AttributeManifest_AttributesEntry_DoNotUse_default_instance_;
class Authentication;
class AuthenticationDefaultTypeInternal;
extern AuthenticationDefaultTypeInternal _Authentication_default_instance_;
class Connection;
class ConnectionDefaultTypeInternal;
extern ConnectionDefaultTypeInternal _Connection_default_instance_;
class FractionalPercent;
class FractionalPercentDefaultTypeInternal;
extern FractionalPercentDefaultTypeInternal _FractionalPercent_default_instance_;
class Handler;
class HandlerDefaultTypeInternal;
extern HandlerDefaultTypeInternal _Handler_default_instance_;
class Instance;
class InstanceDefaultTypeInternal;
extern InstanceDefaultTypeInternal _Instance_default_instance_;
class Instance_AttributeBindingsEntry_DoNotUse;
class Instance_AttributeBindingsEntry_DoNotUseDefaultTypeInternal;
extern Instance_AttributeBindingsEntry_DoNotUseDefaultTypeInternal _Instance_AttributeBindingsEntry_DoNotUse_default_instance_;
class Mutual;
class MutualDefaultTypeInternal;
extern MutualDefaultTypeInternal _Mutual_default_instance_;
class OAuth;
class OAuthDefaultTypeInternal;
extern OAuthDefaultTypeInternal _OAuth_default_instance_;
class OAuth_EndpointParamsEntry_DoNotUse;
class OAuth_EndpointParamsEntry_DoNotUseDefaultTypeInternal;
extern OAuth_EndpointParamsEntry_DoNotUseDefaultTypeInternal _OAuth_EndpointParamsEntry_DoNotUse_default_instance_;
class RandomSampling;
class RandomSamplingDefaultTypeInternal;
extern RandomSamplingDefaultTypeInternal _RandomSampling_default_instance_;
class RateLimitSampling;
class RateLimitSamplingDefaultTypeInternal;
extern RateLimitSamplingDefaultTypeInternal _RateLimitSampling_default_instance_;
class Rule;
class RuleDefaultTypeInternal;
extern RuleDefaultTypeInternal _Rule_default_instance_;
class Rule_HeaderOperationTemplate;
class Rule_HeaderOperationTemplateDefaultTypeInternal;
extern Rule_HeaderOperationTemplateDefaultTypeInternal _Rule_HeaderOperationTemplate_default_instance_;
class Sampling;
class SamplingDefaultTypeInternal;
extern SamplingDefaultTypeInternal _Sampling_default_instance_;
class Tls;
class TlsDefaultTypeInternal;
extern TlsDefaultTypeInternal _Tls_default_instance_;
}  // namespace v1beta1
}  // namespace policy
}  // namespace istio
namespace istio {
namespace policy {
namespace v1beta1 {

enum Rule_HeaderOperationTemplate_Operation {
  Rule_HeaderOperationTemplate_Operation_REPLACE = 0,
  Rule_HeaderOperationTemplate_Operation_REMOVE = 1,
  Rule_HeaderOperationTemplate_Operation_APPEND = 2,
  Rule_HeaderOperationTemplate_Operation_Rule_HeaderOperationTemplate_Operation_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Rule_HeaderOperationTemplate_Operation_Rule_HeaderOperationTemplate_Operation_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Rule_HeaderOperationTemplate_Operation_IsValid(int value);
const Rule_HeaderOperationTemplate_Operation Rule_HeaderOperationTemplate_Operation_Operation_MIN = Rule_HeaderOperationTemplate_Operation_REPLACE;
const Rule_HeaderOperationTemplate_Operation Rule_HeaderOperationTemplate_Operation_Operation_MAX = Rule_HeaderOperationTemplate_Operation_APPEND;
const int Rule_HeaderOperationTemplate_Operation_Operation_ARRAYSIZE = Rule_HeaderOperationTemplate_Operation_Operation_MAX + 1;

const ::google::protobuf::EnumDescriptor* Rule_HeaderOperationTemplate_Operation_descriptor();
inline const ::std::string& Rule_HeaderOperationTemplate_Operation_Name(Rule_HeaderOperationTemplate_Operation value) {
  return ::google::protobuf::internal::NameOfEnum(
    Rule_HeaderOperationTemplate_Operation_descriptor(), value);
}
inline bool Rule_HeaderOperationTemplate_Operation_Parse(
    const ::std::string& name, Rule_HeaderOperationTemplate_Operation* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Rule_HeaderOperationTemplate_Operation>(
    Rule_HeaderOperationTemplate_Operation_descriptor(), name, value);
}
enum FractionalPercent_DenominatorType {
  FractionalPercent_DenominatorType_HUNDRED = 0,
  FractionalPercent_DenominatorType_TEN_THOUSAND = 1,
  FractionalPercent_DenominatorType_FractionalPercent_DenominatorType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  FractionalPercent_DenominatorType_FractionalPercent_DenominatorType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool FractionalPercent_DenominatorType_IsValid(int value);
const FractionalPercent_DenominatorType FractionalPercent_DenominatorType_DenominatorType_MIN = FractionalPercent_DenominatorType_HUNDRED;
const FractionalPercent_DenominatorType FractionalPercent_DenominatorType_DenominatorType_MAX = FractionalPercent_DenominatorType_TEN_THOUSAND;
const int FractionalPercent_DenominatorType_DenominatorType_ARRAYSIZE = FractionalPercent_DenominatorType_DenominatorType_MAX + 1;

const ::google::protobuf::EnumDescriptor* FractionalPercent_DenominatorType_descriptor();
inline const ::std::string& FractionalPercent_DenominatorType_Name(FractionalPercent_DenominatorType value) {
  return ::google::protobuf::internal::NameOfEnum(
    FractionalPercent_DenominatorType_descriptor(), value);
}
inline bool FractionalPercent_DenominatorType_Parse(
    const ::std::string& name, FractionalPercent_DenominatorType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FractionalPercent_DenominatorType>(
    FractionalPercent_DenominatorType_descriptor(), name, value);
}
enum Tls_AuthHeader {
  Tls_AuthHeader_PLAIN = 0,
  Tls_AuthHeader_BEARER = 1,
  Tls_AuthHeader_Tls_AuthHeader_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Tls_AuthHeader_Tls_AuthHeader_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Tls_AuthHeader_IsValid(int value);
const Tls_AuthHeader Tls_AuthHeader_AuthHeader_MIN = Tls_AuthHeader_PLAIN;
const Tls_AuthHeader Tls_AuthHeader_AuthHeader_MAX = Tls_AuthHeader_BEARER;
const int Tls_AuthHeader_AuthHeader_ARRAYSIZE = Tls_AuthHeader_AuthHeader_MAX + 1;

const ::google::protobuf::EnumDescriptor* Tls_AuthHeader_descriptor();
inline const ::std::string& Tls_AuthHeader_Name(Tls_AuthHeader value) {
  return ::google::protobuf::internal::NameOfEnum(
    Tls_AuthHeader_descriptor(), value);
}
inline bool Tls_AuthHeader_Parse(
    const ::std::string& name, Tls_AuthHeader* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Tls_AuthHeader>(
    Tls_AuthHeader_descriptor(), name, value);
}
// ===================================================================

class AttributeManifest_AttributeInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:istio.policy.v1beta1.AttributeManifest.AttributeInfo) */ {
 public:
  AttributeManifest_AttributeInfo();
  virtual ~AttributeManifest_AttributeInfo();

  AttributeManifest_AttributeInfo(const AttributeManifest_AttributeInfo& from);

  inline AttributeManifest_AttributeInfo& operator=(const AttributeManifest_AttributeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AttributeManifest_AttributeInfo(AttributeManifest_AttributeInfo&& from) noexcept
    : AttributeManifest_AttributeInfo() {
    *this = ::std::move(from);
  }

  inline AttributeManifest_AttributeInfo& operator=(AttributeManifest_AttributeInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AttributeManifest_AttributeInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AttributeManifest_AttributeInfo* internal_default_instance() {
    return reinterpret_cast<const AttributeManifest_AttributeInfo*>(
               &_AttributeManifest_AttributeInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(AttributeManifest_AttributeInfo* other);
  friend void swap(AttributeManifest_AttributeInfo& a, AttributeManifest_AttributeInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AttributeManifest_AttributeInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  AttributeManifest_AttributeInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AttributeManifest_AttributeInfo& from);
  void MergeFrom(const AttributeManifest_AttributeInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AttributeManifest_AttributeInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string description = 1;
  void clear_description();
  static const int kDescriptionFieldNumber = 1;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // .istio.policy.v1beta1.ValueType value_type = 2;
  void clear_value_type();
  static const int kValueTypeFieldNumber = 2;
  ::istio::policy::v1beta1::ValueType value_type() const;
  void set_value_type(::istio::policy::v1beta1::ValueType value);

  // @@protoc_insertion_point(class_scope:istio.policy.v1beta1.AttributeManifest.AttributeInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  int value_type_;
  mutable int _cached_size_;
  friend struct ::protobuf_policy_2fv1beta1_2fcfg_2eproto::TableStruct;
  friend void ::protobuf_policy_2fv1beta1_2fcfg_2eproto::InitDefaultsAttributeManifest_AttributeInfoImpl();
};
// -------------------------------------------------------------------

class AttributeManifest_AttributesEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<AttributeManifest_AttributesEntry_DoNotUse, 
    ::std::string, ::istio::policy::v1beta1::AttributeManifest_AttributeInfo,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<AttributeManifest_AttributesEntry_DoNotUse, 
    ::std::string, ::istio::policy::v1beta1::AttributeManifest_AttributeInfo,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  AttributeManifest_AttributesEntry_DoNotUse();
  AttributeManifest_AttributesEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const AttributeManifest_AttributesEntry_DoNotUse& other);
  static const AttributeManifest_AttributesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const AttributeManifest_AttributesEntry_DoNotUse*>(&_AttributeManifest_AttributesEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class AttributeManifest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:istio.policy.v1beta1.AttributeManifest) */ {
 public:
  AttributeManifest();
  virtual ~AttributeManifest();

  AttributeManifest(const AttributeManifest& from);

  inline AttributeManifest& operator=(const AttributeManifest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AttributeManifest(AttributeManifest&& from) noexcept
    : AttributeManifest() {
    *this = ::std::move(from);
  }

  inline AttributeManifest& operator=(AttributeManifest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AttributeManifest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AttributeManifest* internal_default_instance() {
    return reinterpret_cast<const AttributeManifest*>(
               &_AttributeManifest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(AttributeManifest* other);
  friend void swap(AttributeManifest& a, AttributeManifest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AttributeManifest* New() const PROTOBUF_FINAL { return New(NULL); }

  AttributeManifest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AttributeManifest& from);
  void MergeFrom(const AttributeManifest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AttributeManifest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef AttributeManifest_AttributeInfo AttributeInfo;

  // accessors -------------------------------------------------------

  // map<string, .istio.policy.v1beta1.AttributeManifest.AttributeInfo> attributes = 3;
  int attributes_size() const;
  void clear_attributes();
  static const int kAttributesFieldNumber = 3;
  const ::google::protobuf::Map< ::std::string, ::istio::policy::v1beta1::AttributeManifest_AttributeInfo >&
      attributes() const;
  ::google::protobuf::Map< ::std::string, ::istio::policy::v1beta1::AttributeManifest_AttributeInfo >*
      mutable_attributes();

  // string revision = 1;
  void clear_revision();
  static const int kRevisionFieldNumber = 1;
  const ::std::string& revision() const;
  void set_revision(const ::std::string& value);
  #if LANG_CXX11
  void set_revision(::std::string&& value);
  #endif
  void set_revision(const char* value);
  void set_revision(const char* value, size_t size);
  ::std::string* mutable_revision();
  ::std::string* release_revision();
  void set_allocated_revision(::std::string* revision);

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:istio.policy.v1beta1.AttributeManifest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      AttributeManifest_AttributesEntry_DoNotUse,
      ::std::string, ::istio::policy::v1beta1::AttributeManifest_AttributeInfo,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > attributes_;
  ::google::protobuf::internal::ArenaStringPtr revision_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable int _cached_size_;
  friend struct ::protobuf_policy_2fv1beta1_2fcfg_2eproto::TableStruct;
  friend void ::protobuf_policy_2fv1beta1_2fcfg_2eproto::InitDefaultsAttributeManifestImpl();
};
// -------------------------------------------------------------------

class Rule_HeaderOperationTemplate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:istio.policy.v1beta1.Rule.HeaderOperationTemplate) */ {
 public:
  Rule_HeaderOperationTemplate();
  virtual ~Rule_HeaderOperationTemplate();

  Rule_HeaderOperationTemplate(const Rule_HeaderOperationTemplate& from);

  inline Rule_HeaderOperationTemplate& operator=(const Rule_HeaderOperationTemplate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Rule_HeaderOperationTemplate(Rule_HeaderOperationTemplate&& from) noexcept
    : Rule_HeaderOperationTemplate() {
    *this = ::std::move(from);
  }

  inline Rule_HeaderOperationTemplate& operator=(Rule_HeaderOperationTemplate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Rule_HeaderOperationTemplate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Rule_HeaderOperationTemplate* internal_default_instance() {
    return reinterpret_cast<const Rule_HeaderOperationTemplate*>(
               &_Rule_HeaderOperationTemplate_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(Rule_HeaderOperationTemplate* other);
  friend void swap(Rule_HeaderOperationTemplate& a, Rule_HeaderOperationTemplate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Rule_HeaderOperationTemplate* New() const PROTOBUF_FINAL { return New(NULL); }

  Rule_HeaderOperationTemplate* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Rule_HeaderOperationTemplate& from);
  void MergeFrom(const Rule_HeaderOperationTemplate& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Rule_HeaderOperationTemplate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Rule_HeaderOperationTemplate_Operation Operation;
  static const Operation REPLACE =
    Rule_HeaderOperationTemplate_Operation_REPLACE;
  static const Operation REMOVE =
    Rule_HeaderOperationTemplate_Operation_REMOVE;
  static const Operation APPEND =
    Rule_HeaderOperationTemplate_Operation_APPEND;
  static inline bool Operation_IsValid(int value) {
    return Rule_HeaderOperationTemplate_Operation_IsValid(value);
  }
  static const Operation Operation_MIN =
    Rule_HeaderOperationTemplate_Operation_Operation_MIN;
  static const Operation Operation_MAX =
    Rule_HeaderOperationTemplate_Operation_Operation_MAX;
  static const int Operation_ARRAYSIZE =
    Rule_HeaderOperationTemplate_Operation_Operation_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Operation_descriptor() {
    return Rule_HeaderOperationTemplate_Operation_descriptor();
  }
  static inline const ::std::string& Operation_Name(Operation value) {
    return Rule_HeaderOperationTemplate_Operation_Name(value);
  }
  static inline bool Operation_Parse(const ::std::string& name,
      Operation* value) {
    return Rule_HeaderOperationTemplate_Operation_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated string values = 2;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 2;
  const ::std::string& values(int index) const;
  ::std::string* mutable_values(int index);
  void set_values(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_values(int index, ::std::string&& value);
  #endif
  void set_values(int index, const char* value);
  void set_values(int index, const char* value, size_t size);
  ::std::string* add_values();
  void add_values(const ::std::string& value);
  #if LANG_CXX11
  void add_values(::std::string&& value);
  #endif
  void add_values(const char* value);
  void add_values(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& values() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_values();

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .istio.policy.v1beta1.Rule.HeaderOperationTemplate.Operation operation = 3;
  void clear_operation();
  static const int kOperationFieldNumber = 3;
  ::istio::policy::v1beta1::Rule_HeaderOperationTemplate_Operation operation() const;
  void set_operation(::istio::policy::v1beta1::Rule_HeaderOperationTemplate_Operation value);

  // @@protoc_insertion_point(class_scope:istio.policy.v1beta1.Rule.HeaderOperationTemplate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> values_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  int operation_;
  mutable int _cached_size_;
  friend struct ::protobuf_policy_2fv1beta1_2fcfg_2eproto::TableStruct;
  friend void ::protobuf_policy_2fv1beta1_2fcfg_2eproto::InitDefaultsRule_HeaderOperationTemplateImpl();
};
// -------------------------------------------------------------------

class Rule : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:istio.policy.v1beta1.Rule) */ {
 public:
  Rule();
  virtual ~Rule();

  Rule(const Rule& from);

  inline Rule& operator=(const Rule& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Rule(Rule&& from) noexcept
    : Rule() {
    *this = ::std::move(from);
  }

  inline Rule& operator=(Rule&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Rule& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Rule* internal_default_instance() {
    return reinterpret_cast<const Rule*>(
               &_Rule_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Rule* other);
  friend void swap(Rule& a, Rule& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Rule* New() const PROTOBUF_FINAL { return New(NULL); }

  Rule* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Rule& from);
  void MergeFrom(const Rule& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Rule* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Rule_HeaderOperationTemplate HeaderOperationTemplate;

  // accessors -------------------------------------------------------

  // repeated .istio.policy.v1beta1.Action actions = 2;
  int actions_size() const;
  void clear_actions();
  static const int kActionsFieldNumber = 2;
  const ::istio::policy::v1beta1::Action& actions(int index) const;
  ::istio::policy::v1beta1::Action* mutable_actions(int index);
  ::istio::policy::v1beta1::Action* add_actions();
  ::google::protobuf::RepeatedPtrField< ::istio::policy::v1beta1::Action >*
      mutable_actions();
  const ::google::protobuf::RepeatedPtrField< ::istio::policy::v1beta1::Action >&
      actions() const;

  // repeated .istio.policy.v1beta1.Rule.HeaderOperationTemplate request_header_operations = 3;
  int request_header_operations_size() const;
  void clear_request_header_operations();
  static const int kRequestHeaderOperationsFieldNumber = 3;
  const ::istio::policy::v1beta1::Rule_HeaderOperationTemplate& request_header_operations(int index) const;
  ::istio::policy::v1beta1::Rule_HeaderOperationTemplate* mutable_request_header_operations(int index);
  ::istio::policy::v1beta1::Rule_HeaderOperationTemplate* add_request_header_operations();
  ::google::protobuf::RepeatedPtrField< ::istio::policy::v1beta1::Rule_HeaderOperationTemplate >*
      mutable_request_header_operations();
  const ::google::protobuf::RepeatedPtrField< ::istio::policy::v1beta1::Rule_HeaderOperationTemplate >&
      request_header_operations() const;

  // repeated .istio.policy.v1beta1.Rule.HeaderOperationTemplate response_header_operations = 4;
  int response_header_operations_size() const;
  void clear_response_header_operations();
  static const int kResponseHeaderOperationsFieldNumber = 4;
  const ::istio::policy::v1beta1::Rule_HeaderOperationTemplate& response_header_operations(int index) const;
  ::istio::policy::v1beta1::Rule_HeaderOperationTemplate* mutable_response_header_operations(int index);
  ::istio::policy::v1beta1::Rule_HeaderOperationTemplate* add_response_header_operations();
  ::google::protobuf::RepeatedPtrField< ::istio::policy::v1beta1::Rule_HeaderOperationTemplate >*
      mutable_response_header_operations();
  const ::google::protobuf::RepeatedPtrField< ::istio::policy::v1beta1::Rule_HeaderOperationTemplate >&
      response_header_operations() const;

  // string match = 1;
  void clear_match();
  static const int kMatchFieldNumber = 1;
  const ::std::string& match() const;
  void set_match(const ::std::string& value);
  #if LANG_CXX11
  void set_match(::std::string&& value);
  #endif
  void set_match(const char* value);
  void set_match(const char* value, size_t size);
  ::std::string* mutable_match();
  ::std::string* release_match();
  void set_allocated_match(::std::string* match);

  // .istio.policy.v1beta1.Sampling sampling = 5;
  bool has_sampling() const;
  void clear_sampling();
  static const int kSamplingFieldNumber = 5;
  const ::istio::policy::v1beta1::Sampling& sampling() const;
  ::istio::policy::v1beta1::Sampling* release_sampling();
  ::istio::policy::v1beta1::Sampling* mutable_sampling();
  void set_allocated_sampling(::istio::policy::v1beta1::Sampling* sampling);

  // @@protoc_insertion_point(class_scope:istio.policy.v1beta1.Rule)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::istio::policy::v1beta1::Action > actions_;
  ::google::protobuf::RepeatedPtrField< ::istio::policy::v1beta1::Rule_HeaderOperationTemplate > request_header_operations_;
  ::google::protobuf::RepeatedPtrField< ::istio::policy::v1beta1::Rule_HeaderOperationTemplate > response_header_operations_;
  ::google::protobuf::internal::ArenaStringPtr match_;
  ::istio::policy::v1beta1::Sampling* sampling_;
  mutable int _cached_size_;
  friend struct ::protobuf_policy_2fv1beta1_2fcfg_2eproto::TableStruct;
  friend void ::protobuf_policy_2fv1beta1_2fcfg_2eproto::InitDefaultsRuleImpl();
};
// -------------------------------------------------------------------

class Action : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:istio.policy.v1beta1.Action) */ {
 public:
  Action();
  virtual ~Action();

  Action(const Action& from);

  inline Action& operator=(const Action& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Action(Action&& from) noexcept
    : Action() {
    *this = ::std::move(from);
  }

  inline Action& operator=(Action&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Action& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Action* internal_default_instance() {
    return reinterpret_cast<const Action*>(
               &_Action_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(Action* other);
  friend void swap(Action& a, Action& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Action* New() const PROTOBUF_FINAL { return New(NULL); }

  Action* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Action& from);
  void MergeFrom(const Action& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Action* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string instances = 3;
  int instances_size() const;
  void clear_instances();
  static const int kInstancesFieldNumber = 3;
  const ::std::string& instances(int index) const;
  ::std::string* mutable_instances(int index);
  void set_instances(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_instances(int index, ::std::string&& value);
  #endif
  void set_instances(int index, const char* value);
  void set_instances(int index, const char* value, size_t size);
  ::std::string* add_instances();
  void add_instances(const ::std::string& value);
  #if LANG_CXX11
  void add_instances(::std::string&& value);
  #endif
  void add_instances(const char* value);
  void add_instances(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& instances() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_instances();

  // string handler = 2;
  void clear_handler();
  static const int kHandlerFieldNumber = 2;
  const ::std::string& handler() const;
  void set_handler(const ::std::string& value);
  #if LANG_CXX11
  void set_handler(::std::string&& value);
  #endif
  void set_handler(const char* value);
  void set_handler(const char* value, size_t size);
  ::std::string* mutable_handler();
  ::std::string* release_handler();
  void set_allocated_handler(::std::string* handler);

  // string name = 4;
  void clear_name();
  static const int kNameFieldNumber = 4;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:istio.policy.v1beta1.Action)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> instances_;
  ::google::protobuf::internal::ArenaStringPtr handler_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable int _cached_size_;
  friend struct ::protobuf_policy_2fv1beta1_2fcfg_2eproto::TableStruct;
  friend void ::protobuf_policy_2fv1beta1_2fcfg_2eproto::InitDefaultsActionImpl();
};
// -------------------------------------------------------------------

class Instance_AttributeBindingsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<Instance_AttributeBindingsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<Instance_AttributeBindingsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  Instance_AttributeBindingsEntry_DoNotUse();
  Instance_AttributeBindingsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const Instance_AttributeBindingsEntry_DoNotUse& other);
  static const Instance_AttributeBindingsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Instance_AttributeBindingsEntry_DoNotUse*>(&_Instance_AttributeBindingsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class Instance : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:istio.policy.v1beta1.Instance) */ {
 public:
  Instance();
  virtual ~Instance();

  Instance(const Instance& from);

  inline Instance& operator=(const Instance& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Instance(Instance&& from) noexcept
    : Instance() {
    *this = ::std::move(from);
  }

  inline Instance& operator=(Instance&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Instance& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Instance* internal_default_instance() {
    return reinterpret_cast<const Instance*>(
               &_Instance_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(Instance* other);
  friend void swap(Instance& a, Instance& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Instance* New() const PROTOBUF_FINAL { return New(NULL); }

  Instance* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Instance& from);
  void MergeFrom(const Instance& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Instance* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> attribute_bindings = 4;
  int attribute_bindings_size() const;
  void clear_attribute_bindings();
  static const int kAttributeBindingsFieldNumber = 4;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      attribute_bindings() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_attribute_bindings();

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string template = 2;
  void clear_template_();
  static const int kTemplateFieldNumber = 2;
  const ::std::string& template_() const;
  void set_template_(const ::std::string& value);
  #if LANG_CXX11
  void set_template_(::std::string&& value);
  #endif
  void set_template_(const char* value);
  void set_template_(const char* value, size_t size);
  ::std::string* mutable_template_();
  ::std::string* release_template_();
  void set_allocated_template_(::std::string* template_);

  // string compiled_template = 67794676;
  void clear_compiled_template();
  static const int kCompiledTemplateFieldNumber = 67794676;
  const ::std::string& compiled_template() const;
  void set_compiled_template(const ::std::string& value);
  #if LANG_CXX11
  void set_compiled_template(::std::string&& value);
  #endif
  void set_compiled_template(const char* value);
  void set_compiled_template(const char* value, size_t size);
  ::std::string* mutable_compiled_template();
  ::std::string* release_compiled_template();
  void set_allocated_compiled_template(::std::string* compiled_template);

  // .google.protobuf.Struct params = 3;
  bool has_params() const;
  void clear_params();
  static const int kParamsFieldNumber = 3;
  const ::google::protobuf::Struct& params() const;
  ::google::protobuf::Struct* release_params();
  ::google::protobuf::Struct* mutable_params();
  void set_allocated_params(::google::protobuf::Struct* params);

  // @@protoc_insertion_point(class_scope:istio.policy.v1beta1.Instance)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      Instance_AttributeBindingsEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > attribute_bindings_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr template__;
  ::google::protobuf::internal::ArenaStringPtr compiled_template_;
  ::google::protobuf::Struct* params_;
  mutable int _cached_size_;
  friend struct ::protobuf_policy_2fv1beta1_2fcfg_2eproto::TableStruct;
  friend void ::protobuf_policy_2fv1beta1_2fcfg_2eproto::InitDefaultsInstanceImpl();
};
// -------------------------------------------------------------------

class Handler : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:istio.policy.v1beta1.Handler) */ {
 public:
  Handler();
  virtual ~Handler();

  Handler(const Handler& from);

  inline Handler& operator=(const Handler& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Handler(Handler&& from) noexcept
    : Handler() {
    *this = ::std::move(from);
  }

  inline Handler& operator=(Handler&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Handler& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Handler* internal_default_instance() {
    return reinterpret_cast<const Handler*>(
               &_Handler_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(Handler* other);
  friend void swap(Handler& a, Handler& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Handler* New() const PROTOBUF_FINAL { return New(NULL); }

  Handler* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Handler& from);
  void MergeFrom(const Handler& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Handler* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string adapter = 2;
  void clear_adapter();
  static const int kAdapterFieldNumber = 2;
  const ::std::string& adapter() const;
  void set_adapter(const ::std::string& value);
  #if LANG_CXX11
  void set_adapter(::std::string&& value);
  #endif
  void set_adapter(const char* value);
  void set_adapter(const char* value, size_t size);
  ::std::string* mutable_adapter();
  ::std::string* release_adapter();
  void set_allocated_adapter(::std::string* adapter);

  // string compiled_adapter = 67794676;
  void clear_compiled_adapter();
  static const int kCompiledAdapterFieldNumber = 67794676;
  const ::std::string& compiled_adapter() const;
  void set_compiled_adapter(const ::std::string& value);
  #if LANG_CXX11
  void set_compiled_adapter(::std::string&& value);
  #endif
  void set_compiled_adapter(const char* value);
  void set_compiled_adapter(const char* value, size_t size);
  ::std::string* mutable_compiled_adapter();
  ::std::string* release_compiled_adapter();
  void set_allocated_compiled_adapter(::std::string* compiled_adapter);

  // .google.protobuf.Struct params = 3;
  bool has_params() const;
  void clear_params();
  static const int kParamsFieldNumber = 3;
  const ::google::protobuf::Struct& params() const;
  ::google::protobuf::Struct* release_params();
  ::google::protobuf::Struct* mutable_params();
  void set_allocated_params(::google::protobuf::Struct* params);

  // .istio.policy.v1beta1.Connection connection = 4;
  bool has_connection() const;
  void clear_connection();
  static const int kConnectionFieldNumber = 4;
  const ::istio::policy::v1beta1::Connection& connection() const;
  ::istio::policy::v1beta1::Connection* release_connection();
  ::istio::policy::v1beta1::Connection* mutable_connection();
  void set_allocated_connection(::istio::policy::v1beta1::Connection* connection);

  // @@protoc_insertion_point(class_scope:istio.policy.v1beta1.Handler)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr adapter_;
  ::google::protobuf::internal::ArenaStringPtr compiled_adapter_;
  ::google::protobuf::Struct* params_;
  ::istio::policy::v1beta1::Connection* connection_;
  mutable int _cached_size_;
  friend struct ::protobuf_policy_2fv1beta1_2fcfg_2eproto::TableStruct;
  friend void ::protobuf_policy_2fv1beta1_2fcfg_2eproto::InitDefaultsHandlerImpl();
};
// -------------------------------------------------------------------

class Connection : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:istio.policy.v1beta1.Connection) */ {
 public:
  Connection();
  virtual ~Connection();

  Connection(const Connection& from);

  inline Connection& operator=(const Connection& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Connection(Connection&& from) noexcept
    : Connection() {
    *this = ::std::move(from);
  }

  inline Connection& operator=(Connection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Connection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Connection* internal_default_instance() {
    return reinterpret_cast<const Connection*>(
               &_Connection_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(Connection* other);
  friend void swap(Connection& a, Connection& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Connection* New() const PROTOBUF_FINAL { return New(NULL); }

  Connection* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Connection& from);
  void MergeFrom(const Connection& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Connection* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string address = 2;
  void clear_address();
  static const int kAddressFieldNumber = 2;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // .google.protobuf.Duration timeout = 3 [(.gogoproto.stdduration) = true];
  bool has_timeout() const;
  void clear_timeout();
  static const int kTimeoutFieldNumber = 3;
  const ::google::protobuf::Duration& timeout() const;
  ::google::protobuf::Duration* release_timeout();
  ::google::protobuf::Duration* mutable_timeout();
  void set_allocated_timeout(::google::protobuf::Duration* timeout);

  // .istio.policy.v1beta1.Authentication authentication = 4;
  bool has_authentication() const;
  void clear_authentication();
  static const int kAuthenticationFieldNumber = 4;
  const ::istio::policy::v1beta1::Authentication& authentication() const;
  ::istio::policy::v1beta1::Authentication* release_authentication();
  ::istio::policy::v1beta1::Authentication* mutable_authentication();
  void set_allocated_authentication(::istio::policy::v1beta1::Authentication* authentication);

  // @@protoc_insertion_point(class_scope:istio.policy.v1beta1.Connection)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::google::protobuf::Duration* timeout_;
  ::istio::policy::v1beta1::Authentication* authentication_;
  mutable int _cached_size_;
  friend struct ::protobuf_policy_2fv1beta1_2fcfg_2eproto::TableStruct;
  friend void ::protobuf_policy_2fv1beta1_2fcfg_2eproto::InitDefaultsConnectionImpl();
};
// -------------------------------------------------------------------

class Sampling : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:istio.policy.v1beta1.Sampling) */ {
 public:
  Sampling();
  virtual ~Sampling();

  Sampling(const Sampling& from);

  inline Sampling& operator=(const Sampling& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Sampling(Sampling&& from) noexcept
    : Sampling() {
    *this = ::std::move(from);
  }

  inline Sampling& operator=(Sampling&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Sampling& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Sampling* internal_default_instance() {
    return reinterpret_cast<const Sampling*>(
               &_Sampling_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(Sampling* other);
  friend void swap(Sampling& a, Sampling& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Sampling* New() const PROTOBUF_FINAL { return New(NULL); }

  Sampling* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Sampling& from);
  void MergeFrom(const Sampling& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Sampling* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .istio.policy.v1beta1.RandomSampling random = 1;
  bool has_random() const;
  void clear_random();
  static const int kRandomFieldNumber = 1;
  const ::istio::policy::v1beta1::RandomSampling& random() const;
  ::istio::policy::v1beta1::RandomSampling* release_random();
  ::istio::policy::v1beta1::RandomSampling* mutable_random();
  void set_allocated_random(::istio::policy::v1beta1::RandomSampling* random);

  // .istio.policy.v1beta1.RateLimitSampling rate_limit = 2;
  bool has_rate_limit() const;
  void clear_rate_limit();
  static const int kRateLimitFieldNumber = 2;
  const ::istio::policy::v1beta1::RateLimitSampling& rate_limit() const;
  ::istio::policy::v1beta1::RateLimitSampling* release_rate_limit();
  ::istio::policy::v1beta1::RateLimitSampling* mutable_rate_limit();
  void set_allocated_rate_limit(::istio::policy::v1beta1::RateLimitSampling* rate_limit);

  // @@protoc_insertion_point(class_scope:istio.policy.v1beta1.Sampling)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::istio::policy::v1beta1::RandomSampling* random_;
  ::istio::policy::v1beta1::RateLimitSampling* rate_limit_;
  mutable int _cached_size_;
  friend struct ::protobuf_policy_2fv1beta1_2fcfg_2eproto::TableStruct;
  friend void ::protobuf_policy_2fv1beta1_2fcfg_2eproto::InitDefaultsSamplingImpl();
};
// -------------------------------------------------------------------

class RandomSampling : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:istio.policy.v1beta1.RandomSampling) */ {
 public:
  RandomSampling();
  virtual ~RandomSampling();

  RandomSampling(const RandomSampling& from);

  inline RandomSampling& operator=(const RandomSampling& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RandomSampling(RandomSampling&& from) noexcept
    : RandomSampling() {
    *this = ::std::move(from);
  }

  inline RandomSampling& operator=(RandomSampling&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RandomSampling& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RandomSampling* internal_default_instance() {
    return reinterpret_cast<const RandomSampling*>(
               &_RandomSampling_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(RandomSampling* other);
  friend void swap(RandomSampling& a, RandomSampling& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RandomSampling* New() const PROTOBUF_FINAL { return New(NULL); }

  RandomSampling* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RandomSampling& from);
  void MergeFrom(const RandomSampling& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RandomSampling* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string attribute_expression = 1;
  void clear_attribute_expression();
  static const int kAttributeExpressionFieldNumber = 1;
  const ::std::string& attribute_expression() const;
  void set_attribute_expression(const ::std::string& value);
  #if LANG_CXX11
  void set_attribute_expression(::std::string&& value);
  #endif
  void set_attribute_expression(const char* value);
  void set_attribute_expression(const char* value, size_t size);
  ::std::string* mutable_attribute_expression();
  ::std::string* release_attribute_expression();
  void set_allocated_attribute_expression(::std::string* attribute_expression);

  // .istio.policy.v1beta1.FractionalPercent percent_sampled = 2;
  bool has_percent_sampled() const;
  void clear_percent_sampled();
  static const int kPercentSampledFieldNumber = 2;
  const ::istio::policy::v1beta1::FractionalPercent& percent_sampled() const;
  ::istio::policy::v1beta1::FractionalPercent* release_percent_sampled();
  ::istio::policy::v1beta1::FractionalPercent* mutable_percent_sampled();
  void set_allocated_percent_sampled(::istio::policy::v1beta1::FractionalPercent* percent_sampled);

  // bool use_independent_randomness = 3;
  void clear_use_independent_randomness();
  static const int kUseIndependentRandomnessFieldNumber = 3;
  bool use_independent_randomness() const;
  void set_use_independent_randomness(bool value);

  // @@protoc_insertion_point(class_scope:istio.policy.v1beta1.RandomSampling)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr attribute_expression_;
  ::istio::policy::v1beta1::FractionalPercent* percent_sampled_;
  bool use_independent_randomness_;
  mutable int _cached_size_;
  friend struct ::protobuf_policy_2fv1beta1_2fcfg_2eproto::TableStruct;
  friend void ::protobuf_policy_2fv1beta1_2fcfg_2eproto::InitDefaultsRandomSamplingImpl();
};
// -------------------------------------------------------------------

class RateLimitSampling : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:istio.policy.v1beta1.RateLimitSampling) */ {
 public:
  RateLimitSampling();
  virtual ~RateLimitSampling();

  RateLimitSampling(const RateLimitSampling& from);

  inline RateLimitSampling& operator=(const RateLimitSampling& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RateLimitSampling(RateLimitSampling&& from) noexcept
    : RateLimitSampling() {
    *this = ::std::move(from);
  }

  inline RateLimitSampling& operator=(RateLimitSampling&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RateLimitSampling& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RateLimitSampling* internal_default_instance() {
    return reinterpret_cast<const RateLimitSampling*>(
               &_RateLimitSampling_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(RateLimitSampling* other);
  friend void swap(RateLimitSampling& a, RateLimitSampling& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RateLimitSampling* New() const PROTOBUF_FINAL { return New(NULL); }

  RateLimitSampling* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RateLimitSampling& from);
  void MergeFrom(const RateLimitSampling& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RateLimitSampling* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.protobuf.Duration sampling_duration = 1 [(.gogoproto.nullable) = false, (.gogoproto.stdduration) = true];
  bool has_sampling_duration() const;
  void clear_sampling_duration();
  static const int kSamplingDurationFieldNumber = 1;
  const ::google::protobuf::Duration& sampling_duration() const;
  ::google::protobuf::Duration* release_sampling_duration();
  ::google::protobuf::Duration* mutable_sampling_duration();
  void set_allocated_sampling_duration(::google::protobuf::Duration* sampling_duration);

  // int64 max_unsampled_entries = 2;
  void clear_max_unsampled_entries();
  static const int kMaxUnsampledEntriesFieldNumber = 2;
  ::google::protobuf::int64 max_unsampled_entries() const;
  void set_max_unsampled_entries(::google::protobuf::int64 value);

  // int64 sampling_rate = 3;
  void clear_sampling_rate();
  static const int kSamplingRateFieldNumber = 3;
  ::google::protobuf::int64 sampling_rate() const;
  void set_sampling_rate(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:istio.policy.v1beta1.RateLimitSampling)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::Duration* sampling_duration_;
  ::google::protobuf::int64 max_unsampled_entries_;
  ::google::protobuf::int64 sampling_rate_;
  mutable int _cached_size_;
  friend struct ::protobuf_policy_2fv1beta1_2fcfg_2eproto::TableStruct;
  friend void ::protobuf_policy_2fv1beta1_2fcfg_2eproto::InitDefaultsRateLimitSamplingImpl();
};
// -------------------------------------------------------------------

class FractionalPercent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:istio.policy.v1beta1.FractionalPercent) */ {
 public:
  FractionalPercent();
  virtual ~FractionalPercent();

  FractionalPercent(const FractionalPercent& from);

  inline FractionalPercent& operator=(const FractionalPercent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FractionalPercent(FractionalPercent&& from) noexcept
    : FractionalPercent() {
    *this = ::std::move(from);
  }

  inline FractionalPercent& operator=(FractionalPercent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FractionalPercent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FractionalPercent* internal_default_instance() {
    return reinterpret_cast<const FractionalPercent*>(
               &_FractionalPercent_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(FractionalPercent* other);
  friend void swap(FractionalPercent& a, FractionalPercent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FractionalPercent* New() const PROTOBUF_FINAL { return New(NULL); }

  FractionalPercent* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FractionalPercent& from);
  void MergeFrom(const FractionalPercent& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FractionalPercent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef FractionalPercent_DenominatorType DenominatorType;
  static const DenominatorType HUNDRED =
    FractionalPercent_DenominatorType_HUNDRED;
  static const DenominatorType TEN_THOUSAND =
    FractionalPercent_DenominatorType_TEN_THOUSAND;
  static inline bool DenominatorType_IsValid(int value) {
    return FractionalPercent_DenominatorType_IsValid(value);
  }
  static const DenominatorType DenominatorType_MIN =
    FractionalPercent_DenominatorType_DenominatorType_MIN;
  static const DenominatorType DenominatorType_MAX =
    FractionalPercent_DenominatorType_DenominatorType_MAX;
  static const int DenominatorType_ARRAYSIZE =
    FractionalPercent_DenominatorType_DenominatorType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DenominatorType_descriptor() {
    return FractionalPercent_DenominatorType_descriptor();
  }
  static inline const ::std::string& DenominatorType_Name(DenominatorType value) {
    return FractionalPercent_DenominatorType_Name(value);
  }
  static inline bool DenominatorType_Parse(const ::std::string& name,
      DenominatorType* value) {
    return FractionalPercent_DenominatorType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // uint32 numerator = 1;
  void clear_numerator();
  static const int kNumeratorFieldNumber = 1;
  ::google::protobuf::uint32 numerator() const;
  void set_numerator(::google::protobuf::uint32 value);

  // .istio.policy.v1beta1.FractionalPercent.DenominatorType denominator = 2;
  void clear_denominator();
  static const int kDenominatorFieldNumber = 2;
  ::istio::policy::v1beta1::FractionalPercent_DenominatorType denominator() const;
  void set_denominator(::istio::policy::v1beta1::FractionalPercent_DenominatorType value);

  // @@protoc_insertion_point(class_scope:istio.policy.v1beta1.FractionalPercent)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 numerator_;
  int denominator_;
  mutable int _cached_size_;
  friend struct ::protobuf_policy_2fv1beta1_2fcfg_2eproto::TableStruct;
  friend void ::protobuf_policy_2fv1beta1_2fcfg_2eproto::InitDefaultsFractionalPercentImpl();
};
// -------------------------------------------------------------------

class Authentication : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:istio.policy.v1beta1.Authentication) */ {
 public:
  Authentication();
  virtual ~Authentication();

  Authentication(const Authentication& from);

  inline Authentication& operator=(const Authentication& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Authentication(Authentication&& from) noexcept
    : Authentication() {
    *this = ::std::move(from);
  }

  inline Authentication& operator=(Authentication&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Authentication& default_instance();

  enum AuthTypeCase {
    kTls = 1,
    kMutual = 2,
    AUTH_TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Authentication* internal_default_instance() {
    return reinterpret_cast<const Authentication*>(
               &_Authentication_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(Authentication* other);
  friend void swap(Authentication& a, Authentication& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Authentication* New() const PROTOBUF_FINAL { return New(NULL); }

  Authentication* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Authentication& from);
  void MergeFrom(const Authentication& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Authentication* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .istio.policy.v1beta1.Tls tls = 1;
  bool has_tls() const;
  void clear_tls();
  static const int kTlsFieldNumber = 1;
  const ::istio::policy::v1beta1::Tls& tls() const;
  ::istio::policy::v1beta1::Tls* release_tls();
  ::istio::policy::v1beta1::Tls* mutable_tls();
  void set_allocated_tls(::istio::policy::v1beta1::Tls* tls);

  // .istio.policy.v1beta1.Mutual mutual = 2;
  bool has_mutual() const;
  void clear_mutual();
  static const int kMutualFieldNumber = 2;
  const ::istio::policy::v1beta1::Mutual& mutual() const;
  ::istio::policy::v1beta1::Mutual* release_mutual();
  ::istio::policy::v1beta1::Mutual* mutable_mutual();
  void set_allocated_mutual(::istio::policy::v1beta1::Mutual* mutual);

  AuthTypeCase auth_type_case() const;
  // @@protoc_insertion_point(class_scope:istio.policy.v1beta1.Authentication)
 private:
  void set_has_tls();
  void set_has_mutual();

  inline bool has_auth_type() const;
  void clear_auth_type();
  inline void clear_has_auth_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union AuthTypeUnion {
    AuthTypeUnion() {}
    ::istio::policy::v1beta1::Tls* tls_;
    ::istio::policy::v1beta1::Mutual* mutual_;
  } auth_type_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_policy_2fv1beta1_2fcfg_2eproto::TableStruct;
  friend void ::protobuf_policy_2fv1beta1_2fcfg_2eproto::InitDefaultsAuthenticationImpl();
};
// -------------------------------------------------------------------

class Tls : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:istio.policy.v1beta1.Tls) */ {
 public:
  Tls();
  virtual ~Tls();

  Tls(const Tls& from);

  inline Tls& operator=(const Tls& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Tls(Tls&& from) noexcept
    : Tls() {
    *this = ::std::move(from);
  }

  inline Tls& operator=(Tls&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Tls& default_instance();

  enum TokenSourceCase {
    kTokenPath = 2,
    kOauth = 3,
    TOKEN_SOURCE_NOT_SET = 0,
  };

  enum TokenTypeCase {
    kAuthHeader = 4,
    kCustomHeader = 5,
    TOKEN_TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Tls* internal_default_instance() {
    return reinterpret_cast<const Tls*>(
               &_Tls_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(Tls* other);
  friend void swap(Tls& a, Tls& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Tls* New() const PROTOBUF_FINAL { return New(NULL); }

  Tls* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Tls& from);
  void MergeFrom(const Tls& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Tls* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Tls_AuthHeader AuthHeader;
  static const AuthHeader PLAIN =
    Tls_AuthHeader_PLAIN;
  static const AuthHeader BEARER =
    Tls_AuthHeader_BEARER;
  static inline bool AuthHeader_IsValid(int value) {
    return Tls_AuthHeader_IsValid(value);
  }
  static const AuthHeader AuthHeader_MIN =
    Tls_AuthHeader_AuthHeader_MIN;
  static const AuthHeader AuthHeader_MAX =
    Tls_AuthHeader_AuthHeader_MAX;
  static const int AuthHeader_ARRAYSIZE =
    Tls_AuthHeader_AuthHeader_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  AuthHeader_descriptor() {
    return Tls_AuthHeader_descriptor();
  }
  static inline const ::std::string& AuthHeader_Name(AuthHeader value) {
    return Tls_AuthHeader_Name(value);
  }
  static inline bool AuthHeader_Parse(const ::std::string& name,
      AuthHeader* value) {
    return Tls_AuthHeader_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string ca_certificates = 1;
  void clear_ca_certificates();
  static const int kCaCertificatesFieldNumber = 1;
  const ::std::string& ca_certificates() const;
  void set_ca_certificates(const ::std::string& value);
  #if LANG_CXX11
  void set_ca_certificates(::std::string&& value);
  #endif
  void set_ca_certificates(const char* value);
  void set_ca_certificates(const char* value, size_t size);
  ::std::string* mutable_ca_certificates();
  ::std::string* release_ca_certificates();
  void set_allocated_ca_certificates(::std::string* ca_certificates);

  // string server_name = 6;
  void clear_server_name();
  static const int kServerNameFieldNumber = 6;
  const ::std::string& server_name() const;
  void set_server_name(const ::std::string& value);
  #if LANG_CXX11
  void set_server_name(::std::string&& value);
  #endif
  void set_server_name(const char* value);
  void set_server_name(const char* value, size_t size);
  ::std::string* mutable_server_name();
  ::std::string* release_server_name();
  void set_allocated_server_name(::std::string* server_name);

  // string token_path = 2;
  private:
  bool has_token_path() const;
  public:
  void clear_token_path();
  static const int kTokenPathFieldNumber = 2;
  const ::std::string& token_path() const;
  void set_token_path(const ::std::string& value);
  #if LANG_CXX11
  void set_token_path(::std::string&& value);
  #endif
  void set_token_path(const char* value);
  void set_token_path(const char* value, size_t size);
  ::std::string* mutable_token_path();
  ::std::string* release_token_path();
  void set_allocated_token_path(::std::string* token_path);

  // .istio.policy.v1beta1.OAuth oauth = 3;
  bool has_oauth() const;
  void clear_oauth();
  static const int kOauthFieldNumber = 3;
  const ::istio::policy::v1beta1::OAuth& oauth() const;
  ::istio::policy::v1beta1::OAuth* release_oauth();
  ::istio::policy::v1beta1::OAuth* mutable_oauth();
  void set_allocated_oauth(::istio::policy::v1beta1::OAuth* oauth);

  // .istio.policy.v1beta1.Tls.AuthHeader auth_header = 4;
  private:
  bool has_auth_header() const;
  public:
  void clear_auth_header();
  static const int kAuthHeaderFieldNumber = 4;
  ::istio::policy::v1beta1::Tls_AuthHeader auth_header() const;
  void set_auth_header(::istio::policy::v1beta1::Tls_AuthHeader value);

  // string custom_header = 5;
  private:
  bool has_custom_header() const;
  public:
  void clear_custom_header();
  static const int kCustomHeaderFieldNumber = 5;
  const ::std::string& custom_header() const;
  void set_custom_header(const ::std::string& value);
  #if LANG_CXX11
  void set_custom_header(::std::string&& value);
  #endif
  void set_custom_header(const char* value);
  void set_custom_header(const char* value, size_t size);
  ::std::string* mutable_custom_header();
  ::std::string* release_custom_header();
  void set_allocated_custom_header(::std::string* custom_header);

  TokenSourceCase token_source_case() const;
  TokenTypeCase token_type_case() const;
  // @@protoc_insertion_point(class_scope:istio.policy.v1beta1.Tls)
 private:
  void set_has_token_path();
  void set_has_oauth();
  void set_has_auth_header();
  void set_has_custom_header();

  inline bool has_token_source() const;
  void clear_token_source();
  inline void clear_has_token_source();

  inline bool has_token_type() const;
  void clear_token_type();
  inline void clear_has_token_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr ca_certificates_;
  ::google::protobuf::internal::ArenaStringPtr server_name_;
  union TokenSourceUnion {
    TokenSourceUnion() {}
    ::google::protobuf::internal::ArenaStringPtr token_path_;
    ::istio::policy::v1beta1::OAuth* oauth_;
  } token_source_;
  union TokenTypeUnion {
    TokenTypeUnion() {}
    int auth_header_;
    ::google::protobuf::internal::ArenaStringPtr custom_header_;
  } token_type_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[2];

  friend struct ::protobuf_policy_2fv1beta1_2fcfg_2eproto::TableStruct;
  friend void ::protobuf_policy_2fv1beta1_2fcfg_2eproto::InitDefaultsTlsImpl();
};
// -------------------------------------------------------------------

class OAuth_EndpointParamsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<OAuth_EndpointParamsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<OAuth_EndpointParamsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  OAuth_EndpointParamsEntry_DoNotUse();
  OAuth_EndpointParamsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const OAuth_EndpointParamsEntry_DoNotUse& other);
  static const OAuth_EndpointParamsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const OAuth_EndpointParamsEntry_DoNotUse*>(&_OAuth_EndpointParamsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class OAuth : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:istio.policy.v1beta1.OAuth) */ {
 public:
  OAuth();
  virtual ~OAuth();

  OAuth(const OAuth& from);

  inline OAuth& operator=(const OAuth& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OAuth(OAuth&& from) noexcept
    : OAuth() {
    *this = ::std::move(from);
  }

  inline OAuth& operator=(OAuth&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OAuth& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OAuth* internal_default_instance() {
    return reinterpret_cast<const OAuth*>(
               &_OAuth_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(OAuth* other);
  friend void swap(OAuth& a, OAuth& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OAuth* New() const PROTOBUF_FINAL { return New(NULL); }

  OAuth* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OAuth& from);
  void MergeFrom(const OAuth& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OAuth* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // repeated string scopes = 4;
  int scopes_size() const;
  void clear_scopes();
  static const int kScopesFieldNumber = 4;
  const ::std::string& scopes(int index) const;
  ::std::string* mutable_scopes(int index);
  void set_scopes(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_scopes(int index, ::std::string&& value);
  #endif
  void set_scopes(int index, const char* value);
  void set_scopes(int index, const char* value, size_t size);
  ::std::string* add_scopes();
  void add_scopes(const ::std::string& value);
  #if LANG_CXX11
  void add_scopes(::std::string&& value);
  #endif
  void add_scopes(const char* value);
  void add_scopes(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& scopes() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_scopes();

  // map<string, string> endpoint_params = 5;
  int endpoint_params_size() const;
  void clear_endpoint_params();
  static const int kEndpointParamsFieldNumber = 5;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      endpoint_params() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_endpoint_params();

  // string client_id = 1;
  void clear_client_id();
  static const int kClientIdFieldNumber = 1;
  const ::std::string& client_id() const;
  void set_client_id(const ::std::string& value);
  #if LANG_CXX11
  void set_client_id(::std::string&& value);
  #endif
  void set_client_id(const char* value);
  void set_client_id(const char* value, size_t size);
  ::std::string* mutable_client_id();
  ::std::string* release_client_id();
  void set_allocated_client_id(::std::string* client_id);

  // string client_secret = 2;
  void clear_client_secret();
  static const int kClientSecretFieldNumber = 2;
  const ::std::string& client_secret() const;
  void set_client_secret(const ::std::string& value);
  #if LANG_CXX11
  void set_client_secret(::std::string&& value);
  #endif
  void set_client_secret(const char* value);
  void set_client_secret(const char* value, size_t size);
  ::std::string* mutable_client_secret();
  ::std::string* release_client_secret();
  void set_allocated_client_secret(::std::string* client_secret);

  // string token_url = 3;
  void clear_token_url();
  static const int kTokenUrlFieldNumber = 3;
  const ::std::string& token_url() const;
  void set_token_url(const ::std::string& value);
  #if LANG_CXX11
  void set_token_url(::std::string&& value);
  #endif
  void set_token_url(const char* value);
  void set_token_url(const char* value, size_t size);
  ::std::string* mutable_token_url();
  ::std::string* release_token_url();
  void set_allocated_token_url(::std::string* token_url);

  // @@protoc_insertion_point(class_scope:istio.policy.v1beta1.OAuth)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> scopes_;
  ::google::protobuf::internal::MapField<
      OAuth_EndpointParamsEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > endpoint_params_;
  ::google::protobuf::internal::ArenaStringPtr client_id_;
  ::google::protobuf::internal::ArenaStringPtr client_secret_;
  ::google::protobuf::internal::ArenaStringPtr token_url_;
  mutable int _cached_size_;
  friend struct ::protobuf_policy_2fv1beta1_2fcfg_2eproto::TableStruct;
  friend void ::protobuf_policy_2fv1beta1_2fcfg_2eproto::InitDefaultsOAuthImpl();
};
// -------------------------------------------------------------------

class Mutual : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:istio.policy.v1beta1.Mutual) */ {
 public:
  Mutual();
  virtual ~Mutual();

  Mutual(const Mutual& from);

  inline Mutual& operator=(const Mutual& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Mutual(Mutual&& from) noexcept
    : Mutual() {
    *this = ::std::move(from);
  }

  inline Mutual& operator=(Mutual&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Mutual& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Mutual* internal_default_instance() {
    return reinterpret_cast<const Mutual*>(
               &_Mutual_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(Mutual* other);
  friend void swap(Mutual& a, Mutual& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Mutual* New() const PROTOBUF_FINAL { return New(NULL); }

  Mutual* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Mutual& from);
  void MergeFrom(const Mutual& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Mutual* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string private_key = 1;
  void clear_private_key();
  static const int kPrivateKeyFieldNumber = 1;
  const ::std::string& private_key() const;
  void set_private_key(const ::std::string& value);
  #if LANG_CXX11
  void set_private_key(::std::string&& value);
  #endif
  void set_private_key(const char* value);
  void set_private_key(const char* value, size_t size);
  ::std::string* mutable_private_key();
  ::std::string* release_private_key();
  void set_allocated_private_key(::std::string* private_key);

  // string client_certificate = 2;
  void clear_client_certificate();
  static const int kClientCertificateFieldNumber = 2;
  const ::std::string& client_certificate() const;
  void set_client_certificate(const ::std::string& value);
  #if LANG_CXX11
  void set_client_certificate(::std::string&& value);
  #endif
  void set_client_certificate(const char* value);
  void set_client_certificate(const char* value, size_t size);
  ::std::string* mutable_client_certificate();
  ::std::string* release_client_certificate();
  void set_allocated_client_certificate(::std::string* client_certificate);

  // string ca_certificates = 3;
  void clear_ca_certificates();
  static const int kCaCertificatesFieldNumber = 3;
  const ::std::string& ca_certificates() const;
  void set_ca_certificates(const ::std::string& value);
  #if LANG_CXX11
  void set_ca_certificates(::std::string&& value);
  #endif
  void set_ca_certificates(const char* value);
  void set_ca_certificates(const char* value, size_t size);
  ::std::string* mutable_ca_certificates();
  ::std::string* release_ca_certificates();
  void set_allocated_ca_certificates(::std::string* ca_certificates);

  // string server_name = 4;
  void clear_server_name();
  static const int kServerNameFieldNumber = 4;
  const ::std::string& server_name() const;
  void set_server_name(const ::std::string& value);
  #if LANG_CXX11
  void set_server_name(::std::string&& value);
  #endif
  void set_server_name(const char* value);
  void set_server_name(const char* value, size_t size);
  ::std::string* mutable_server_name();
  ::std::string* release_server_name();
  void set_allocated_server_name(::std::string* server_name);

  // @@protoc_insertion_point(class_scope:istio.policy.v1beta1.Mutual)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr private_key_;
  ::google::protobuf::internal::ArenaStringPtr client_certificate_;
  ::google::protobuf::internal::ArenaStringPtr ca_certificates_;
  ::google::protobuf::internal::ArenaStringPtr server_name_;
  mutable int _cached_size_;
  friend struct ::protobuf_policy_2fv1beta1_2fcfg_2eproto::TableStruct;
  friend void ::protobuf_policy_2fv1beta1_2fcfg_2eproto::InitDefaultsMutualImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AttributeManifest_AttributeInfo

// string description = 1;
inline void AttributeManifest_AttributeInfo::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AttributeManifest_AttributeInfo::description() const {
  // @@protoc_insertion_point(field_get:istio.policy.v1beta1.AttributeManifest.AttributeInfo.description)
  return description_.GetNoArena();
}
inline void AttributeManifest_AttributeInfo::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.policy.v1beta1.AttributeManifest.AttributeInfo.description)
}
#if LANG_CXX11
inline void AttributeManifest_AttributeInfo::set_description(::std::string&& value) {
  
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.policy.v1beta1.AttributeManifest.AttributeInfo.description)
}
#endif
inline void AttributeManifest_AttributeInfo::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.policy.v1beta1.AttributeManifest.AttributeInfo.description)
}
inline void AttributeManifest_AttributeInfo::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.policy.v1beta1.AttributeManifest.AttributeInfo.description)
}
inline ::std::string* AttributeManifest_AttributeInfo::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:istio.policy.v1beta1.AttributeManifest.AttributeInfo.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AttributeManifest_AttributeInfo::release_description() {
  // @@protoc_insertion_point(field_release:istio.policy.v1beta1.AttributeManifest.AttributeInfo.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AttributeManifest_AttributeInfo::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:istio.policy.v1beta1.AttributeManifest.AttributeInfo.description)
}

// .istio.policy.v1beta1.ValueType value_type = 2;
inline void AttributeManifest_AttributeInfo::clear_value_type() {
  value_type_ = 0;
}
inline ::istio::policy::v1beta1::ValueType AttributeManifest_AttributeInfo::value_type() const {
  // @@protoc_insertion_point(field_get:istio.policy.v1beta1.AttributeManifest.AttributeInfo.value_type)
  return static_cast< ::istio::policy::v1beta1::ValueType >(value_type_);
}
inline void AttributeManifest_AttributeInfo::set_value_type(::istio::policy::v1beta1::ValueType value) {
  
  value_type_ = value;
  // @@protoc_insertion_point(field_set:istio.policy.v1beta1.AttributeManifest.AttributeInfo.value_type)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// AttributeManifest

// string revision = 1;
inline void AttributeManifest::clear_revision() {
  revision_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AttributeManifest::revision() const {
  // @@protoc_insertion_point(field_get:istio.policy.v1beta1.AttributeManifest.revision)
  return revision_.GetNoArena();
}
inline void AttributeManifest::set_revision(const ::std::string& value) {
  
  revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.policy.v1beta1.AttributeManifest.revision)
}
#if LANG_CXX11
inline void AttributeManifest::set_revision(::std::string&& value) {
  
  revision_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.policy.v1beta1.AttributeManifest.revision)
}
#endif
inline void AttributeManifest::set_revision(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.policy.v1beta1.AttributeManifest.revision)
}
inline void AttributeManifest::set_revision(const char* value, size_t size) {
  
  revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.policy.v1beta1.AttributeManifest.revision)
}
inline ::std::string* AttributeManifest::mutable_revision() {
  
  // @@protoc_insertion_point(field_mutable:istio.policy.v1beta1.AttributeManifest.revision)
  return revision_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AttributeManifest::release_revision() {
  // @@protoc_insertion_point(field_release:istio.policy.v1beta1.AttributeManifest.revision)
  
  return revision_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AttributeManifest::set_allocated_revision(::std::string* revision) {
  if (revision != NULL) {
    
  } else {
    
  }
  revision_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), revision);
  // @@protoc_insertion_point(field_set_allocated:istio.policy.v1beta1.AttributeManifest.revision)
}

// string name = 2;
inline void AttributeManifest::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AttributeManifest::name() const {
  // @@protoc_insertion_point(field_get:istio.policy.v1beta1.AttributeManifest.name)
  return name_.GetNoArena();
}
inline void AttributeManifest::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.policy.v1beta1.AttributeManifest.name)
}
#if LANG_CXX11
inline void AttributeManifest::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.policy.v1beta1.AttributeManifest.name)
}
#endif
inline void AttributeManifest::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.policy.v1beta1.AttributeManifest.name)
}
inline void AttributeManifest::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.policy.v1beta1.AttributeManifest.name)
}
inline ::std::string* AttributeManifest::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:istio.policy.v1beta1.AttributeManifest.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AttributeManifest::release_name() {
  // @@protoc_insertion_point(field_release:istio.policy.v1beta1.AttributeManifest.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AttributeManifest::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:istio.policy.v1beta1.AttributeManifest.name)
}

// map<string, .istio.policy.v1beta1.AttributeManifest.AttributeInfo> attributes = 3;
inline int AttributeManifest::attributes_size() const {
  return attributes_.size();
}
inline void AttributeManifest::clear_attributes() {
  attributes_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::istio::policy::v1beta1::AttributeManifest_AttributeInfo >&
AttributeManifest::attributes() const {
  // @@protoc_insertion_point(field_map:istio.policy.v1beta1.AttributeManifest.attributes)
  return attributes_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::istio::policy::v1beta1::AttributeManifest_AttributeInfo >*
AttributeManifest::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_map:istio.policy.v1beta1.AttributeManifest.attributes)
  return attributes_.MutableMap();
}

// -------------------------------------------------------------------

// Rule_HeaderOperationTemplate

// string name = 1;
inline void Rule_HeaderOperationTemplate::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Rule_HeaderOperationTemplate::name() const {
  // @@protoc_insertion_point(field_get:istio.policy.v1beta1.Rule.HeaderOperationTemplate.name)
  return name_.GetNoArena();
}
inline void Rule_HeaderOperationTemplate::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.policy.v1beta1.Rule.HeaderOperationTemplate.name)
}
#if LANG_CXX11
inline void Rule_HeaderOperationTemplate::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.policy.v1beta1.Rule.HeaderOperationTemplate.name)
}
#endif
inline void Rule_HeaderOperationTemplate::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.policy.v1beta1.Rule.HeaderOperationTemplate.name)
}
inline void Rule_HeaderOperationTemplate::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.policy.v1beta1.Rule.HeaderOperationTemplate.name)
}
inline ::std::string* Rule_HeaderOperationTemplate::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:istio.policy.v1beta1.Rule.HeaderOperationTemplate.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Rule_HeaderOperationTemplate::release_name() {
  // @@protoc_insertion_point(field_release:istio.policy.v1beta1.Rule.HeaderOperationTemplate.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Rule_HeaderOperationTemplate::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:istio.policy.v1beta1.Rule.HeaderOperationTemplate.name)
}

// repeated string values = 2;
inline int Rule_HeaderOperationTemplate::values_size() const {
  return values_.size();
}
inline void Rule_HeaderOperationTemplate::clear_values() {
  values_.Clear();
}
inline const ::std::string& Rule_HeaderOperationTemplate::values(int index) const {
  // @@protoc_insertion_point(field_get:istio.policy.v1beta1.Rule.HeaderOperationTemplate.values)
  return values_.Get(index);
}
inline ::std::string* Rule_HeaderOperationTemplate::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:istio.policy.v1beta1.Rule.HeaderOperationTemplate.values)
  return values_.Mutable(index);
}
inline void Rule_HeaderOperationTemplate::set_values(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:istio.policy.v1beta1.Rule.HeaderOperationTemplate.values)
  values_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Rule_HeaderOperationTemplate::set_values(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:istio.policy.v1beta1.Rule.HeaderOperationTemplate.values)
  values_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Rule_HeaderOperationTemplate::set_values(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:istio.policy.v1beta1.Rule.HeaderOperationTemplate.values)
}
inline void Rule_HeaderOperationTemplate::set_values(int index, const char* value, size_t size) {
  values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:istio.policy.v1beta1.Rule.HeaderOperationTemplate.values)
}
inline ::std::string* Rule_HeaderOperationTemplate::add_values() {
  // @@protoc_insertion_point(field_add_mutable:istio.policy.v1beta1.Rule.HeaderOperationTemplate.values)
  return values_.Add();
}
inline void Rule_HeaderOperationTemplate::add_values(const ::std::string& value) {
  values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:istio.policy.v1beta1.Rule.HeaderOperationTemplate.values)
}
#if LANG_CXX11
inline void Rule_HeaderOperationTemplate::add_values(::std::string&& value) {
  values_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:istio.policy.v1beta1.Rule.HeaderOperationTemplate.values)
}
#endif
inline void Rule_HeaderOperationTemplate::add_values(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:istio.policy.v1beta1.Rule.HeaderOperationTemplate.values)
}
inline void Rule_HeaderOperationTemplate::add_values(const char* value, size_t size) {
  values_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:istio.policy.v1beta1.Rule.HeaderOperationTemplate.values)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Rule_HeaderOperationTemplate::values() const {
  // @@protoc_insertion_point(field_list:istio.policy.v1beta1.Rule.HeaderOperationTemplate.values)
  return values_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Rule_HeaderOperationTemplate::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:istio.policy.v1beta1.Rule.HeaderOperationTemplate.values)
  return &values_;
}

// .istio.policy.v1beta1.Rule.HeaderOperationTemplate.Operation operation = 3;
inline void Rule_HeaderOperationTemplate::clear_operation() {
  operation_ = 0;
}
inline ::istio::policy::v1beta1::Rule_HeaderOperationTemplate_Operation Rule_HeaderOperationTemplate::operation() const {
  // @@protoc_insertion_point(field_get:istio.policy.v1beta1.Rule.HeaderOperationTemplate.operation)
  return static_cast< ::istio::policy::v1beta1::Rule_HeaderOperationTemplate_Operation >(operation_);
}
inline void Rule_HeaderOperationTemplate::set_operation(::istio::policy::v1beta1::Rule_HeaderOperationTemplate_Operation value) {
  
  operation_ = value;
  // @@protoc_insertion_point(field_set:istio.policy.v1beta1.Rule.HeaderOperationTemplate.operation)
}

// -------------------------------------------------------------------

// Rule

// string match = 1;
inline void Rule::clear_match() {
  match_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Rule::match() const {
  // @@protoc_insertion_point(field_get:istio.policy.v1beta1.Rule.match)
  return match_.GetNoArena();
}
inline void Rule::set_match(const ::std::string& value) {
  
  match_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.policy.v1beta1.Rule.match)
}
#if LANG_CXX11
inline void Rule::set_match(::std::string&& value) {
  
  match_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.policy.v1beta1.Rule.match)
}
#endif
inline void Rule::set_match(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  match_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.policy.v1beta1.Rule.match)
}
inline void Rule::set_match(const char* value, size_t size) {
  
  match_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.policy.v1beta1.Rule.match)
}
inline ::std::string* Rule::mutable_match() {
  
  // @@protoc_insertion_point(field_mutable:istio.policy.v1beta1.Rule.match)
  return match_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Rule::release_match() {
  // @@protoc_insertion_point(field_release:istio.policy.v1beta1.Rule.match)
  
  return match_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Rule::set_allocated_match(::std::string* match) {
  if (match != NULL) {
    
  } else {
    
  }
  match_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), match);
  // @@protoc_insertion_point(field_set_allocated:istio.policy.v1beta1.Rule.match)
}

// repeated .istio.policy.v1beta1.Action actions = 2;
inline int Rule::actions_size() const {
  return actions_.size();
}
inline void Rule::clear_actions() {
  actions_.Clear();
}
inline const ::istio::policy::v1beta1::Action& Rule::actions(int index) const {
  // @@protoc_insertion_point(field_get:istio.policy.v1beta1.Rule.actions)
  return actions_.Get(index);
}
inline ::istio::policy::v1beta1::Action* Rule::mutable_actions(int index) {
  // @@protoc_insertion_point(field_mutable:istio.policy.v1beta1.Rule.actions)
  return actions_.Mutable(index);
}
inline ::istio::policy::v1beta1::Action* Rule::add_actions() {
  // @@protoc_insertion_point(field_add:istio.policy.v1beta1.Rule.actions)
  return actions_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::istio::policy::v1beta1::Action >*
Rule::mutable_actions() {
  // @@protoc_insertion_point(field_mutable_list:istio.policy.v1beta1.Rule.actions)
  return &actions_;
}
inline const ::google::protobuf::RepeatedPtrField< ::istio::policy::v1beta1::Action >&
Rule::actions() const {
  // @@protoc_insertion_point(field_list:istio.policy.v1beta1.Rule.actions)
  return actions_;
}

// repeated .istio.policy.v1beta1.Rule.HeaderOperationTemplate request_header_operations = 3;
inline int Rule::request_header_operations_size() const {
  return request_header_operations_.size();
}
inline void Rule::clear_request_header_operations() {
  request_header_operations_.Clear();
}
inline const ::istio::policy::v1beta1::Rule_HeaderOperationTemplate& Rule::request_header_operations(int index) const {
  // @@protoc_insertion_point(field_get:istio.policy.v1beta1.Rule.request_header_operations)
  return request_header_operations_.Get(index);
}
inline ::istio::policy::v1beta1::Rule_HeaderOperationTemplate* Rule::mutable_request_header_operations(int index) {
  // @@protoc_insertion_point(field_mutable:istio.policy.v1beta1.Rule.request_header_operations)
  return request_header_operations_.Mutable(index);
}
inline ::istio::policy::v1beta1::Rule_HeaderOperationTemplate* Rule::add_request_header_operations() {
  // @@protoc_insertion_point(field_add:istio.policy.v1beta1.Rule.request_header_operations)
  return request_header_operations_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::istio::policy::v1beta1::Rule_HeaderOperationTemplate >*
Rule::mutable_request_header_operations() {
  // @@protoc_insertion_point(field_mutable_list:istio.policy.v1beta1.Rule.request_header_operations)
  return &request_header_operations_;
}
inline const ::google::protobuf::RepeatedPtrField< ::istio::policy::v1beta1::Rule_HeaderOperationTemplate >&
Rule::request_header_operations() const {
  // @@protoc_insertion_point(field_list:istio.policy.v1beta1.Rule.request_header_operations)
  return request_header_operations_;
}

// repeated .istio.policy.v1beta1.Rule.HeaderOperationTemplate response_header_operations = 4;
inline int Rule::response_header_operations_size() const {
  return response_header_operations_.size();
}
inline void Rule::clear_response_header_operations() {
  response_header_operations_.Clear();
}
inline const ::istio::policy::v1beta1::Rule_HeaderOperationTemplate& Rule::response_header_operations(int index) const {
  // @@protoc_insertion_point(field_get:istio.policy.v1beta1.Rule.response_header_operations)
  return response_header_operations_.Get(index);
}
inline ::istio::policy::v1beta1::Rule_HeaderOperationTemplate* Rule::mutable_response_header_operations(int index) {
  // @@protoc_insertion_point(field_mutable:istio.policy.v1beta1.Rule.response_header_operations)
  return response_header_operations_.Mutable(index);
}
inline ::istio::policy::v1beta1::Rule_HeaderOperationTemplate* Rule::add_response_header_operations() {
  // @@protoc_insertion_point(field_add:istio.policy.v1beta1.Rule.response_header_operations)
  return response_header_operations_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::istio::policy::v1beta1::Rule_HeaderOperationTemplate >*
Rule::mutable_response_header_operations() {
  // @@protoc_insertion_point(field_mutable_list:istio.policy.v1beta1.Rule.response_header_operations)
  return &response_header_operations_;
}
inline const ::google::protobuf::RepeatedPtrField< ::istio::policy::v1beta1::Rule_HeaderOperationTemplate >&
Rule::response_header_operations() const {
  // @@protoc_insertion_point(field_list:istio.policy.v1beta1.Rule.response_header_operations)
  return response_header_operations_;
}

// .istio.policy.v1beta1.Sampling sampling = 5;
inline bool Rule::has_sampling() const {
  return this != internal_default_instance() && sampling_ != NULL;
}
inline void Rule::clear_sampling() {
  if (GetArenaNoVirtual() == NULL && sampling_ != NULL) {
    delete sampling_;
  }
  sampling_ = NULL;
}
inline const ::istio::policy::v1beta1::Sampling& Rule::sampling() const {
  const ::istio::policy::v1beta1::Sampling* p = sampling_;
  // @@protoc_insertion_point(field_get:istio.policy.v1beta1.Rule.sampling)
  return p != NULL ? *p : *reinterpret_cast<const ::istio::policy::v1beta1::Sampling*>(
      &::istio::policy::v1beta1::_Sampling_default_instance_);
}
inline ::istio::policy::v1beta1::Sampling* Rule::release_sampling() {
  // @@protoc_insertion_point(field_release:istio.policy.v1beta1.Rule.sampling)
  
  ::istio::policy::v1beta1::Sampling* temp = sampling_;
  sampling_ = NULL;
  return temp;
}
inline ::istio::policy::v1beta1::Sampling* Rule::mutable_sampling() {
  
  if (sampling_ == NULL) {
    sampling_ = new ::istio::policy::v1beta1::Sampling;
  }
  // @@protoc_insertion_point(field_mutable:istio.policy.v1beta1.Rule.sampling)
  return sampling_;
}
inline void Rule::set_allocated_sampling(::istio::policy::v1beta1::Sampling* sampling) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sampling_;
  }
  if (sampling) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sampling = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sampling, submessage_arena);
    }
    
  } else {
    
  }
  sampling_ = sampling;
  // @@protoc_insertion_point(field_set_allocated:istio.policy.v1beta1.Rule.sampling)
}

// -------------------------------------------------------------------

// Action

// string handler = 2;
inline void Action::clear_handler() {
  handler_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Action::handler() const {
  // @@protoc_insertion_point(field_get:istio.policy.v1beta1.Action.handler)
  return handler_.GetNoArena();
}
inline void Action::set_handler(const ::std::string& value) {
  
  handler_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.policy.v1beta1.Action.handler)
}
#if LANG_CXX11
inline void Action::set_handler(::std::string&& value) {
  
  handler_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.policy.v1beta1.Action.handler)
}
#endif
inline void Action::set_handler(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  handler_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.policy.v1beta1.Action.handler)
}
inline void Action::set_handler(const char* value, size_t size) {
  
  handler_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.policy.v1beta1.Action.handler)
}
inline ::std::string* Action::mutable_handler() {
  
  // @@protoc_insertion_point(field_mutable:istio.policy.v1beta1.Action.handler)
  return handler_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Action::release_handler() {
  // @@protoc_insertion_point(field_release:istio.policy.v1beta1.Action.handler)
  
  return handler_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Action::set_allocated_handler(::std::string* handler) {
  if (handler != NULL) {
    
  } else {
    
  }
  handler_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), handler);
  // @@protoc_insertion_point(field_set_allocated:istio.policy.v1beta1.Action.handler)
}

// repeated string instances = 3;
inline int Action::instances_size() const {
  return instances_.size();
}
inline void Action::clear_instances() {
  instances_.Clear();
}
inline const ::std::string& Action::instances(int index) const {
  // @@protoc_insertion_point(field_get:istio.policy.v1beta1.Action.instances)
  return instances_.Get(index);
}
inline ::std::string* Action::mutable_instances(int index) {
  // @@protoc_insertion_point(field_mutable:istio.policy.v1beta1.Action.instances)
  return instances_.Mutable(index);
}
inline void Action::set_instances(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:istio.policy.v1beta1.Action.instances)
  instances_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Action::set_instances(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:istio.policy.v1beta1.Action.instances)
  instances_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Action::set_instances(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  instances_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:istio.policy.v1beta1.Action.instances)
}
inline void Action::set_instances(int index, const char* value, size_t size) {
  instances_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:istio.policy.v1beta1.Action.instances)
}
inline ::std::string* Action::add_instances() {
  // @@protoc_insertion_point(field_add_mutable:istio.policy.v1beta1.Action.instances)
  return instances_.Add();
}
inline void Action::add_instances(const ::std::string& value) {
  instances_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:istio.policy.v1beta1.Action.instances)
}
#if LANG_CXX11
inline void Action::add_instances(::std::string&& value) {
  instances_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:istio.policy.v1beta1.Action.instances)
}
#endif
inline void Action::add_instances(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  instances_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:istio.policy.v1beta1.Action.instances)
}
inline void Action::add_instances(const char* value, size_t size) {
  instances_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:istio.policy.v1beta1.Action.instances)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Action::instances() const {
  // @@protoc_insertion_point(field_list:istio.policy.v1beta1.Action.instances)
  return instances_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Action::mutable_instances() {
  // @@protoc_insertion_point(field_mutable_list:istio.policy.v1beta1.Action.instances)
  return &instances_;
}

// string name = 4;
inline void Action::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Action::name() const {
  // @@protoc_insertion_point(field_get:istio.policy.v1beta1.Action.name)
  return name_.GetNoArena();
}
inline void Action::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.policy.v1beta1.Action.name)
}
#if LANG_CXX11
inline void Action::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.policy.v1beta1.Action.name)
}
#endif
inline void Action::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.policy.v1beta1.Action.name)
}
inline void Action::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.policy.v1beta1.Action.name)
}
inline ::std::string* Action::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:istio.policy.v1beta1.Action.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Action::release_name() {
  // @@protoc_insertion_point(field_release:istio.policy.v1beta1.Action.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Action::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:istio.policy.v1beta1.Action.name)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Instance

// string name = 1;
inline void Instance::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Instance::name() const {
  // @@protoc_insertion_point(field_get:istio.policy.v1beta1.Instance.name)
  return name_.GetNoArena();
}
inline void Instance::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.policy.v1beta1.Instance.name)
}
#if LANG_CXX11
inline void Instance::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.policy.v1beta1.Instance.name)
}
#endif
inline void Instance::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.policy.v1beta1.Instance.name)
}
inline void Instance::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.policy.v1beta1.Instance.name)
}
inline ::std::string* Instance::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:istio.policy.v1beta1.Instance.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Instance::release_name() {
  // @@protoc_insertion_point(field_release:istio.policy.v1beta1.Instance.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Instance::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:istio.policy.v1beta1.Instance.name)
}

// string compiled_template = 67794676;
inline void Instance::clear_compiled_template() {
  compiled_template_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Instance::compiled_template() const {
  // @@protoc_insertion_point(field_get:istio.policy.v1beta1.Instance.compiled_template)
  return compiled_template_.GetNoArena();
}
inline void Instance::set_compiled_template(const ::std::string& value) {
  
  compiled_template_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.policy.v1beta1.Instance.compiled_template)
}
#if LANG_CXX11
inline void Instance::set_compiled_template(::std::string&& value) {
  
  compiled_template_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.policy.v1beta1.Instance.compiled_template)
}
#endif
inline void Instance::set_compiled_template(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  compiled_template_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.policy.v1beta1.Instance.compiled_template)
}
inline void Instance::set_compiled_template(const char* value, size_t size) {
  
  compiled_template_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.policy.v1beta1.Instance.compiled_template)
}
inline ::std::string* Instance::mutable_compiled_template() {
  
  // @@protoc_insertion_point(field_mutable:istio.policy.v1beta1.Instance.compiled_template)
  return compiled_template_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Instance::release_compiled_template() {
  // @@protoc_insertion_point(field_release:istio.policy.v1beta1.Instance.compiled_template)
  
  return compiled_template_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Instance::set_allocated_compiled_template(::std::string* compiled_template) {
  if (compiled_template != NULL) {
    
  } else {
    
  }
  compiled_template_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), compiled_template);
  // @@protoc_insertion_point(field_set_allocated:istio.policy.v1beta1.Instance.compiled_template)
}

// string template = 2;
inline void Instance::clear_template_() {
  template__.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Instance::template_() const {
  // @@protoc_insertion_point(field_get:istio.policy.v1beta1.Instance.template)
  return template__.GetNoArena();
}
inline void Instance::set_template_(const ::std::string& value) {
  
  template__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.policy.v1beta1.Instance.template)
}
#if LANG_CXX11
inline void Instance::set_template_(::std::string&& value) {
  
  template__.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.policy.v1beta1.Instance.template)
}
#endif
inline void Instance::set_template_(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  template__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.policy.v1beta1.Instance.template)
}
inline void Instance::set_template_(const char* value, size_t size) {
  
  template__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.policy.v1beta1.Instance.template)
}
inline ::std::string* Instance::mutable_template_() {
  
  // @@protoc_insertion_point(field_mutable:istio.policy.v1beta1.Instance.template)
  return template__.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Instance::release_template_() {
  // @@protoc_insertion_point(field_release:istio.policy.v1beta1.Instance.template)
  
  return template__.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Instance::set_allocated_template_(::std::string* template_) {
  if (template_ != NULL) {
    
  } else {
    
  }
  template__.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), template_);
  // @@protoc_insertion_point(field_set_allocated:istio.policy.v1beta1.Instance.template)
}

// .google.protobuf.Struct params = 3;
inline bool Instance::has_params() const {
  return this != internal_default_instance() && params_ != NULL;
}
inline const ::google::protobuf::Struct& Instance::params() const {
  const ::google::protobuf::Struct* p = params_;
  // @@protoc_insertion_point(field_get:istio.policy.v1beta1.Instance.params)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Struct*>(
      &::google::protobuf::_Struct_default_instance_);
}
inline ::google::protobuf::Struct* Instance::release_params() {
  // @@protoc_insertion_point(field_release:istio.policy.v1beta1.Instance.params)
  
  ::google::protobuf::Struct* temp = params_;
  params_ = NULL;
  return temp;
}
inline ::google::protobuf::Struct* Instance::mutable_params() {
  
  if (params_ == NULL) {
    params_ = new ::google::protobuf::Struct;
  }
  // @@protoc_insertion_point(field_mutable:istio.policy.v1beta1.Instance.params)
  return params_;
}
inline void Instance::set_allocated_params(::google::protobuf::Struct* params) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(params_);
  }
  if (params) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(params)->GetArena();
    if (message_arena != submessage_arena) {
      params = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, params, submessage_arena);
    }
    
  } else {
    
  }
  params_ = params;
  // @@protoc_insertion_point(field_set_allocated:istio.policy.v1beta1.Instance.params)
}

// map<string, string> attribute_bindings = 4;
inline int Instance::attribute_bindings_size() const {
  return attribute_bindings_.size();
}
inline void Instance::clear_attribute_bindings() {
  attribute_bindings_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
Instance::attribute_bindings() const {
  // @@protoc_insertion_point(field_map:istio.policy.v1beta1.Instance.attribute_bindings)
  return attribute_bindings_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
Instance::mutable_attribute_bindings() {
  // @@protoc_insertion_point(field_mutable_map:istio.policy.v1beta1.Instance.attribute_bindings)
  return attribute_bindings_.MutableMap();
}

// -------------------------------------------------------------------

// Handler

// string name = 1;
inline void Handler::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Handler::name() const {
  // @@protoc_insertion_point(field_get:istio.policy.v1beta1.Handler.name)
  return name_.GetNoArena();
}
inline void Handler::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.policy.v1beta1.Handler.name)
}
#if LANG_CXX11
inline void Handler::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.policy.v1beta1.Handler.name)
}
#endif
inline void Handler::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.policy.v1beta1.Handler.name)
}
inline void Handler::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.policy.v1beta1.Handler.name)
}
inline ::std::string* Handler::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:istio.policy.v1beta1.Handler.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Handler::release_name() {
  // @@protoc_insertion_point(field_release:istio.policy.v1beta1.Handler.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Handler::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:istio.policy.v1beta1.Handler.name)
}

// string compiled_adapter = 67794676;
inline void Handler::clear_compiled_adapter() {
  compiled_adapter_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Handler::compiled_adapter() const {
  // @@protoc_insertion_point(field_get:istio.policy.v1beta1.Handler.compiled_adapter)
  return compiled_adapter_.GetNoArena();
}
inline void Handler::set_compiled_adapter(const ::std::string& value) {
  
  compiled_adapter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.policy.v1beta1.Handler.compiled_adapter)
}
#if LANG_CXX11
inline void Handler::set_compiled_adapter(::std::string&& value) {
  
  compiled_adapter_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.policy.v1beta1.Handler.compiled_adapter)
}
#endif
inline void Handler::set_compiled_adapter(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  compiled_adapter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.policy.v1beta1.Handler.compiled_adapter)
}
inline void Handler::set_compiled_adapter(const char* value, size_t size) {
  
  compiled_adapter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.policy.v1beta1.Handler.compiled_adapter)
}
inline ::std::string* Handler::mutable_compiled_adapter() {
  
  // @@protoc_insertion_point(field_mutable:istio.policy.v1beta1.Handler.compiled_adapter)
  return compiled_adapter_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Handler::release_compiled_adapter() {
  // @@protoc_insertion_point(field_release:istio.policy.v1beta1.Handler.compiled_adapter)
  
  return compiled_adapter_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Handler::set_allocated_compiled_adapter(::std::string* compiled_adapter) {
  if (compiled_adapter != NULL) {
    
  } else {
    
  }
  compiled_adapter_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), compiled_adapter);
  // @@protoc_insertion_point(field_set_allocated:istio.policy.v1beta1.Handler.compiled_adapter)
}

// string adapter = 2;
inline void Handler::clear_adapter() {
  adapter_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Handler::adapter() const {
  // @@protoc_insertion_point(field_get:istio.policy.v1beta1.Handler.adapter)
  return adapter_.GetNoArena();
}
inline void Handler::set_adapter(const ::std::string& value) {
  
  adapter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.policy.v1beta1.Handler.adapter)
}
#if LANG_CXX11
inline void Handler::set_adapter(::std::string&& value) {
  
  adapter_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.policy.v1beta1.Handler.adapter)
}
#endif
inline void Handler::set_adapter(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  adapter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.policy.v1beta1.Handler.adapter)
}
inline void Handler::set_adapter(const char* value, size_t size) {
  
  adapter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.policy.v1beta1.Handler.adapter)
}
inline ::std::string* Handler::mutable_adapter() {
  
  // @@protoc_insertion_point(field_mutable:istio.policy.v1beta1.Handler.adapter)
  return adapter_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Handler::release_adapter() {
  // @@protoc_insertion_point(field_release:istio.policy.v1beta1.Handler.adapter)
  
  return adapter_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Handler::set_allocated_adapter(::std::string* adapter) {
  if (adapter != NULL) {
    
  } else {
    
  }
  adapter_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), adapter);
  // @@protoc_insertion_point(field_set_allocated:istio.policy.v1beta1.Handler.adapter)
}

// .google.protobuf.Struct params = 3;
inline bool Handler::has_params() const {
  return this != internal_default_instance() && params_ != NULL;
}
inline const ::google::protobuf::Struct& Handler::params() const {
  const ::google::protobuf::Struct* p = params_;
  // @@protoc_insertion_point(field_get:istio.policy.v1beta1.Handler.params)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Struct*>(
      &::google::protobuf::_Struct_default_instance_);
}
inline ::google::protobuf::Struct* Handler::release_params() {
  // @@protoc_insertion_point(field_release:istio.policy.v1beta1.Handler.params)
  
  ::google::protobuf::Struct* temp = params_;
  params_ = NULL;
  return temp;
}
inline ::google::protobuf::Struct* Handler::mutable_params() {
  
  if (params_ == NULL) {
    params_ = new ::google::protobuf::Struct;
  }
  // @@protoc_insertion_point(field_mutable:istio.policy.v1beta1.Handler.params)
  return params_;
}
inline void Handler::set_allocated_params(::google::protobuf::Struct* params) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(params_);
  }
  if (params) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(params)->GetArena();
    if (message_arena != submessage_arena) {
      params = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, params, submessage_arena);
    }
    
  } else {
    
  }
  params_ = params;
  // @@protoc_insertion_point(field_set_allocated:istio.policy.v1beta1.Handler.params)
}

// .istio.policy.v1beta1.Connection connection = 4;
inline bool Handler::has_connection() const {
  return this != internal_default_instance() && connection_ != NULL;
}
inline void Handler::clear_connection() {
  if (GetArenaNoVirtual() == NULL && connection_ != NULL) {
    delete connection_;
  }
  connection_ = NULL;
}
inline const ::istio::policy::v1beta1::Connection& Handler::connection() const {
  const ::istio::policy::v1beta1::Connection* p = connection_;
  // @@protoc_insertion_point(field_get:istio.policy.v1beta1.Handler.connection)
  return p != NULL ? *p : *reinterpret_cast<const ::istio::policy::v1beta1::Connection*>(
      &::istio::policy::v1beta1::_Connection_default_instance_);
}
inline ::istio::policy::v1beta1::Connection* Handler::release_connection() {
  // @@protoc_insertion_point(field_release:istio.policy.v1beta1.Handler.connection)
  
  ::istio::policy::v1beta1::Connection* temp = connection_;
  connection_ = NULL;
  return temp;
}
inline ::istio::policy::v1beta1::Connection* Handler::mutable_connection() {
  
  if (connection_ == NULL) {
    connection_ = new ::istio::policy::v1beta1::Connection;
  }
  // @@protoc_insertion_point(field_mutable:istio.policy.v1beta1.Handler.connection)
  return connection_;
}
inline void Handler::set_allocated_connection(::istio::policy::v1beta1::Connection* connection) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete connection_;
  }
  if (connection) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      connection = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, connection, submessage_arena);
    }
    
  } else {
    
  }
  connection_ = connection;
  // @@protoc_insertion_point(field_set_allocated:istio.policy.v1beta1.Handler.connection)
}

// -------------------------------------------------------------------

// Connection

// string address = 2;
inline void Connection::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Connection::address() const {
  // @@protoc_insertion_point(field_get:istio.policy.v1beta1.Connection.address)
  return address_.GetNoArena();
}
inline void Connection::set_address(const ::std::string& value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.policy.v1beta1.Connection.address)
}
#if LANG_CXX11
inline void Connection::set_address(::std::string&& value) {
  
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.policy.v1beta1.Connection.address)
}
#endif
inline void Connection::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.policy.v1beta1.Connection.address)
}
inline void Connection::set_address(const char* value, size_t size) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.policy.v1beta1.Connection.address)
}
inline ::std::string* Connection::mutable_address() {
  
  // @@protoc_insertion_point(field_mutable:istio.policy.v1beta1.Connection.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Connection::release_address() {
  // @@protoc_insertion_point(field_release:istio.policy.v1beta1.Connection.address)
  
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Connection::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    
  } else {
    
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:istio.policy.v1beta1.Connection.address)
}

// .google.protobuf.Duration timeout = 3 [(.gogoproto.stdduration) = true];
inline bool Connection::has_timeout() const {
  return this != internal_default_instance() && timeout_ != NULL;
}
inline const ::google::protobuf::Duration& Connection::timeout() const {
  const ::google::protobuf::Duration* p = timeout_;
  // @@protoc_insertion_point(field_get:istio.policy.v1beta1.Connection.timeout)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Duration*>(
      &::google::protobuf::_Duration_default_instance_);
}
inline ::google::protobuf::Duration* Connection::release_timeout() {
  // @@protoc_insertion_point(field_release:istio.policy.v1beta1.Connection.timeout)
  
  ::google::protobuf::Duration* temp = timeout_;
  timeout_ = NULL;
  return temp;
}
inline ::google::protobuf::Duration* Connection::mutable_timeout() {
  
  if (timeout_ == NULL) {
    timeout_ = new ::google::protobuf::Duration;
  }
  // @@protoc_insertion_point(field_mutable:istio.policy.v1beta1.Connection.timeout)
  return timeout_;
}
inline void Connection::set_allocated_timeout(::google::protobuf::Duration* timeout) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(timeout_);
  }
  if (timeout) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(timeout)->GetArena();
    if (message_arena != submessage_arena) {
      timeout = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, timeout, submessage_arena);
    }
    
  } else {
    
  }
  timeout_ = timeout;
  // @@protoc_insertion_point(field_set_allocated:istio.policy.v1beta1.Connection.timeout)
}

// .istio.policy.v1beta1.Authentication authentication = 4;
inline bool Connection::has_authentication() const {
  return this != internal_default_instance() && authentication_ != NULL;
}
inline void Connection::clear_authentication() {
  if (GetArenaNoVirtual() == NULL && authentication_ != NULL) {
    delete authentication_;
  }
  authentication_ = NULL;
}
inline const ::istio::policy::v1beta1::Authentication& Connection::authentication() const {
  const ::istio::policy::v1beta1::Authentication* p = authentication_;
  // @@protoc_insertion_point(field_get:istio.policy.v1beta1.Connection.authentication)
  return p != NULL ? *p : *reinterpret_cast<const ::istio::policy::v1beta1::Authentication*>(
      &::istio::policy::v1beta1::_Authentication_default_instance_);
}
inline ::istio::policy::v1beta1::Authentication* Connection::release_authentication() {
  // @@protoc_insertion_point(field_release:istio.policy.v1beta1.Connection.authentication)
  
  ::istio::policy::v1beta1::Authentication* temp = authentication_;
  authentication_ = NULL;
  return temp;
}
inline ::istio::policy::v1beta1::Authentication* Connection::mutable_authentication() {
  
  if (authentication_ == NULL) {
    authentication_ = new ::istio::policy::v1beta1::Authentication;
  }
  // @@protoc_insertion_point(field_mutable:istio.policy.v1beta1.Connection.authentication)
  return authentication_;
}
inline void Connection::set_allocated_authentication(::istio::policy::v1beta1::Authentication* authentication) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete authentication_;
  }
  if (authentication) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      authentication = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, authentication, submessage_arena);
    }
    
  } else {
    
  }
  authentication_ = authentication;
  // @@protoc_insertion_point(field_set_allocated:istio.policy.v1beta1.Connection.authentication)
}

// -------------------------------------------------------------------

// Sampling

// .istio.policy.v1beta1.RandomSampling random = 1;
inline bool Sampling::has_random() const {
  return this != internal_default_instance() && random_ != NULL;
}
inline void Sampling::clear_random() {
  if (GetArenaNoVirtual() == NULL && random_ != NULL) {
    delete random_;
  }
  random_ = NULL;
}
inline const ::istio::policy::v1beta1::RandomSampling& Sampling::random() const {
  const ::istio::policy::v1beta1::RandomSampling* p = random_;
  // @@protoc_insertion_point(field_get:istio.policy.v1beta1.Sampling.random)
  return p != NULL ? *p : *reinterpret_cast<const ::istio::policy::v1beta1::RandomSampling*>(
      &::istio::policy::v1beta1::_RandomSampling_default_instance_);
}
inline ::istio::policy::v1beta1::RandomSampling* Sampling::release_random() {
  // @@protoc_insertion_point(field_release:istio.policy.v1beta1.Sampling.random)
  
  ::istio::policy::v1beta1::RandomSampling* temp = random_;
  random_ = NULL;
  return temp;
}
inline ::istio::policy::v1beta1::RandomSampling* Sampling::mutable_random() {
  
  if (random_ == NULL) {
    random_ = new ::istio::policy::v1beta1::RandomSampling;
  }
  // @@protoc_insertion_point(field_mutable:istio.policy.v1beta1.Sampling.random)
  return random_;
}
inline void Sampling::set_allocated_random(::istio::policy::v1beta1::RandomSampling* random) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete random_;
  }
  if (random) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      random = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, random, submessage_arena);
    }
    
  } else {
    
  }
  random_ = random;
  // @@protoc_insertion_point(field_set_allocated:istio.policy.v1beta1.Sampling.random)
}

// .istio.policy.v1beta1.RateLimitSampling rate_limit = 2;
inline bool Sampling::has_rate_limit() const {
  return this != internal_default_instance() && rate_limit_ != NULL;
}
inline void Sampling::clear_rate_limit() {
  if (GetArenaNoVirtual() == NULL && rate_limit_ != NULL) {
    delete rate_limit_;
  }
  rate_limit_ = NULL;
}
inline const ::istio::policy::v1beta1::RateLimitSampling& Sampling::rate_limit() const {
  const ::istio::policy::v1beta1::RateLimitSampling* p = rate_limit_;
  // @@protoc_insertion_point(field_get:istio.policy.v1beta1.Sampling.rate_limit)
  return p != NULL ? *p : *reinterpret_cast<const ::istio::policy::v1beta1::RateLimitSampling*>(
      &::istio::policy::v1beta1::_RateLimitSampling_default_instance_);
}
inline ::istio::policy::v1beta1::RateLimitSampling* Sampling::release_rate_limit() {
  // @@protoc_insertion_point(field_release:istio.policy.v1beta1.Sampling.rate_limit)
  
  ::istio::policy::v1beta1::RateLimitSampling* temp = rate_limit_;
  rate_limit_ = NULL;
  return temp;
}
inline ::istio::policy::v1beta1::RateLimitSampling* Sampling::mutable_rate_limit() {
  
  if (rate_limit_ == NULL) {
    rate_limit_ = new ::istio::policy::v1beta1::RateLimitSampling;
  }
  // @@protoc_insertion_point(field_mutable:istio.policy.v1beta1.Sampling.rate_limit)
  return rate_limit_;
}
inline void Sampling::set_allocated_rate_limit(::istio::policy::v1beta1::RateLimitSampling* rate_limit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete rate_limit_;
  }
  if (rate_limit) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      rate_limit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rate_limit, submessage_arena);
    }
    
  } else {
    
  }
  rate_limit_ = rate_limit;
  // @@protoc_insertion_point(field_set_allocated:istio.policy.v1beta1.Sampling.rate_limit)
}

// -------------------------------------------------------------------

// RandomSampling

// string attribute_expression = 1;
inline void RandomSampling::clear_attribute_expression() {
  attribute_expression_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RandomSampling::attribute_expression() const {
  // @@protoc_insertion_point(field_get:istio.policy.v1beta1.RandomSampling.attribute_expression)
  return attribute_expression_.GetNoArena();
}
inline void RandomSampling::set_attribute_expression(const ::std::string& value) {
  
  attribute_expression_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.policy.v1beta1.RandomSampling.attribute_expression)
}
#if LANG_CXX11
inline void RandomSampling::set_attribute_expression(::std::string&& value) {
  
  attribute_expression_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.policy.v1beta1.RandomSampling.attribute_expression)
}
#endif
inline void RandomSampling::set_attribute_expression(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  attribute_expression_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.policy.v1beta1.RandomSampling.attribute_expression)
}
inline void RandomSampling::set_attribute_expression(const char* value, size_t size) {
  
  attribute_expression_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.policy.v1beta1.RandomSampling.attribute_expression)
}
inline ::std::string* RandomSampling::mutable_attribute_expression() {
  
  // @@protoc_insertion_point(field_mutable:istio.policy.v1beta1.RandomSampling.attribute_expression)
  return attribute_expression_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RandomSampling::release_attribute_expression() {
  // @@protoc_insertion_point(field_release:istio.policy.v1beta1.RandomSampling.attribute_expression)
  
  return attribute_expression_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RandomSampling::set_allocated_attribute_expression(::std::string* attribute_expression) {
  if (attribute_expression != NULL) {
    
  } else {
    
  }
  attribute_expression_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), attribute_expression);
  // @@protoc_insertion_point(field_set_allocated:istio.policy.v1beta1.RandomSampling.attribute_expression)
}

// .istio.policy.v1beta1.FractionalPercent percent_sampled = 2;
inline bool RandomSampling::has_percent_sampled() const {
  return this != internal_default_instance() && percent_sampled_ != NULL;
}
inline void RandomSampling::clear_percent_sampled() {
  if (GetArenaNoVirtual() == NULL && percent_sampled_ != NULL) {
    delete percent_sampled_;
  }
  percent_sampled_ = NULL;
}
inline const ::istio::policy::v1beta1::FractionalPercent& RandomSampling::percent_sampled() const {
  const ::istio::policy::v1beta1::FractionalPercent* p = percent_sampled_;
  // @@protoc_insertion_point(field_get:istio.policy.v1beta1.RandomSampling.percent_sampled)
  return p != NULL ? *p : *reinterpret_cast<const ::istio::policy::v1beta1::FractionalPercent*>(
      &::istio::policy::v1beta1::_FractionalPercent_default_instance_);
}
inline ::istio::policy::v1beta1::FractionalPercent* RandomSampling::release_percent_sampled() {
  // @@protoc_insertion_point(field_release:istio.policy.v1beta1.RandomSampling.percent_sampled)
  
  ::istio::policy::v1beta1::FractionalPercent* temp = percent_sampled_;
  percent_sampled_ = NULL;
  return temp;
}
inline ::istio::policy::v1beta1::FractionalPercent* RandomSampling::mutable_percent_sampled() {
  
  if (percent_sampled_ == NULL) {
    percent_sampled_ = new ::istio::policy::v1beta1::FractionalPercent;
  }
  // @@protoc_insertion_point(field_mutable:istio.policy.v1beta1.RandomSampling.percent_sampled)
  return percent_sampled_;
}
inline void RandomSampling::set_allocated_percent_sampled(::istio::policy::v1beta1::FractionalPercent* percent_sampled) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete percent_sampled_;
  }
  if (percent_sampled) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      percent_sampled = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, percent_sampled, submessage_arena);
    }
    
  } else {
    
  }
  percent_sampled_ = percent_sampled;
  // @@protoc_insertion_point(field_set_allocated:istio.policy.v1beta1.RandomSampling.percent_sampled)
}

// bool use_independent_randomness = 3;
inline void RandomSampling::clear_use_independent_randomness() {
  use_independent_randomness_ = false;
}
inline bool RandomSampling::use_independent_randomness() const {
  // @@protoc_insertion_point(field_get:istio.policy.v1beta1.RandomSampling.use_independent_randomness)
  return use_independent_randomness_;
}
inline void RandomSampling::set_use_independent_randomness(bool value) {
  
  use_independent_randomness_ = value;
  // @@protoc_insertion_point(field_set:istio.policy.v1beta1.RandomSampling.use_independent_randomness)
}

// -------------------------------------------------------------------

// RateLimitSampling

// .google.protobuf.Duration sampling_duration = 1 [(.gogoproto.nullable) = false, (.gogoproto.stdduration) = true];
inline bool RateLimitSampling::has_sampling_duration() const {
  return this != internal_default_instance() && sampling_duration_ != NULL;
}
inline const ::google::protobuf::Duration& RateLimitSampling::sampling_duration() const {
  const ::google::protobuf::Duration* p = sampling_duration_;
  // @@protoc_insertion_point(field_get:istio.policy.v1beta1.RateLimitSampling.sampling_duration)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Duration*>(
      &::google::protobuf::_Duration_default_instance_);
}
inline ::google::protobuf::Duration* RateLimitSampling::release_sampling_duration() {
  // @@protoc_insertion_point(field_release:istio.policy.v1beta1.RateLimitSampling.sampling_duration)
  
  ::google::protobuf::Duration* temp = sampling_duration_;
  sampling_duration_ = NULL;
  return temp;
}
inline ::google::protobuf::Duration* RateLimitSampling::mutable_sampling_duration() {
  
  if (sampling_duration_ == NULL) {
    sampling_duration_ = new ::google::protobuf::Duration;
  }
  // @@protoc_insertion_point(field_mutable:istio.policy.v1beta1.RateLimitSampling.sampling_duration)
  return sampling_duration_;
}
inline void RateLimitSampling::set_allocated_sampling_duration(::google::protobuf::Duration* sampling_duration) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(sampling_duration_);
  }
  if (sampling_duration) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(sampling_duration)->GetArena();
    if (message_arena != submessage_arena) {
      sampling_duration = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sampling_duration, submessage_arena);
    }
    
  } else {
    
  }
  sampling_duration_ = sampling_duration;
  // @@protoc_insertion_point(field_set_allocated:istio.policy.v1beta1.RateLimitSampling.sampling_duration)
}

// int64 max_unsampled_entries = 2;
inline void RateLimitSampling::clear_max_unsampled_entries() {
  max_unsampled_entries_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 RateLimitSampling::max_unsampled_entries() const {
  // @@protoc_insertion_point(field_get:istio.policy.v1beta1.RateLimitSampling.max_unsampled_entries)
  return max_unsampled_entries_;
}
inline void RateLimitSampling::set_max_unsampled_entries(::google::protobuf::int64 value) {
  
  max_unsampled_entries_ = value;
  // @@protoc_insertion_point(field_set:istio.policy.v1beta1.RateLimitSampling.max_unsampled_entries)
}

// int64 sampling_rate = 3;
inline void RateLimitSampling::clear_sampling_rate() {
  sampling_rate_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 RateLimitSampling::sampling_rate() const {
  // @@protoc_insertion_point(field_get:istio.policy.v1beta1.RateLimitSampling.sampling_rate)
  return sampling_rate_;
}
inline void RateLimitSampling::set_sampling_rate(::google::protobuf::int64 value) {
  
  sampling_rate_ = value;
  // @@protoc_insertion_point(field_set:istio.policy.v1beta1.RateLimitSampling.sampling_rate)
}

// -------------------------------------------------------------------

// FractionalPercent

// uint32 numerator = 1;
inline void FractionalPercent::clear_numerator() {
  numerator_ = 0u;
}
inline ::google::protobuf::uint32 FractionalPercent::numerator() const {
  // @@protoc_insertion_point(field_get:istio.policy.v1beta1.FractionalPercent.numerator)
  return numerator_;
}
inline void FractionalPercent::set_numerator(::google::protobuf::uint32 value) {
  
  numerator_ = value;
  // @@protoc_insertion_point(field_set:istio.policy.v1beta1.FractionalPercent.numerator)
}

// .istio.policy.v1beta1.FractionalPercent.DenominatorType denominator = 2;
inline void FractionalPercent::clear_denominator() {
  denominator_ = 0;
}
inline ::istio::policy::v1beta1::FractionalPercent_DenominatorType FractionalPercent::denominator() const {
  // @@protoc_insertion_point(field_get:istio.policy.v1beta1.FractionalPercent.denominator)
  return static_cast< ::istio::policy::v1beta1::FractionalPercent_DenominatorType >(denominator_);
}
inline void FractionalPercent::set_denominator(::istio::policy::v1beta1::FractionalPercent_DenominatorType value) {
  
  denominator_ = value;
  // @@protoc_insertion_point(field_set:istio.policy.v1beta1.FractionalPercent.denominator)
}

// -------------------------------------------------------------------

// Authentication

// .istio.policy.v1beta1.Tls tls = 1;
inline bool Authentication::has_tls() const {
  return auth_type_case() == kTls;
}
inline void Authentication::set_has_tls() {
  _oneof_case_[0] = kTls;
}
inline void Authentication::clear_tls() {
  if (has_tls()) {
    delete auth_type_.tls_;
    clear_has_auth_type();
  }
}
inline ::istio::policy::v1beta1::Tls* Authentication::release_tls() {
  // @@protoc_insertion_point(field_release:istio.policy.v1beta1.Authentication.tls)
  if (has_tls()) {
    clear_has_auth_type();
      ::istio::policy::v1beta1::Tls* temp = auth_type_.tls_;
    auth_type_.tls_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::istio::policy::v1beta1::Tls& Authentication::tls() const {
  // @@protoc_insertion_point(field_get:istio.policy.v1beta1.Authentication.tls)
  return has_tls()
      ? *auth_type_.tls_
      : *reinterpret_cast< ::istio::policy::v1beta1::Tls*>(&::istio::policy::v1beta1::_Tls_default_instance_);
}
inline ::istio::policy::v1beta1::Tls* Authentication::mutable_tls() {
  if (!has_tls()) {
    clear_auth_type();
    set_has_tls();
    auth_type_.tls_ = new ::istio::policy::v1beta1::Tls;
  }
  // @@protoc_insertion_point(field_mutable:istio.policy.v1beta1.Authentication.tls)
  return auth_type_.tls_;
}

// .istio.policy.v1beta1.Mutual mutual = 2;
inline bool Authentication::has_mutual() const {
  return auth_type_case() == kMutual;
}
inline void Authentication::set_has_mutual() {
  _oneof_case_[0] = kMutual;
}
inline void Authentication::clear_mutual() {
  if (has_mutual()) {
    delete auth_type_.mutual_;
    clear_has_auth_type();
  }
}
inline ::istio::policy::v1beta1::Mutual* Authentication::release_mutual() {
  // @@protoc_insertion_point(field_release:istio.policy.v1beta1.Authentication.mutual)
  if (has_mutual()) {
    clear_has_auth_type();
      ::istio::policy::v1beta1::Mutual* temp = auth_type_.mutual_;
    auth_type_.mutual_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::istio::policy::v1beta1::Mutual& Authentication::mutual() const {
  // @@protoc_insertion_point(field_get:istio.policy.v1beta1.Authentication.mutual)
  return has_mutual()
      ? *auth_type_.mutual_
      : *reinterpret_cast< ::istio::policy::v1beta1::Mutual*>(&::istio::policy::v1beta1::_Mutual_default_instance_);
}
inline ::istio::policy::v1beta1::Mutual* Authentication::mutable_mutual() {
  if (!has_mutual()) {
    clear_auth_type();
    set_has_mutual();
    auth_type_.mutual_ = new ::istio::policy::v1beta1::Mutual;
  }
  // @@protoc_insertion_point(field_mutable:istio.policy.v1beta1.Authentication.mutual)
  return auth_type_.mutual_;
}

inline bool Authentication::has_auth_type() const {
  return auth_type_case() != AUTH_TYPE_NOT_SET;
}
inline void Authentication::clear_has_auth_type() {
  _oneof_case_[0] = AUTH_TYPE_NOT_SET;
}
inline Authentication::AuthTypeCase Authentication::auth_type_case() const {
  return Authentication::AuthTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Tls

// string ca_certificates = 1;
inline void Tls::clear_ca_certificates() {
  ca_certificates_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Tls::ca_certificates() const {
  // @@protoc_insertion_point(field_get:istio.policy.v1beta1.Tls.ca_certificates)
  return ca_certificates_.GetNoArena();
}
inline void Tls::set_ca_certificates(const ::std::string& value) {
  
  ca_certificates_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.policy.v1beta1.Tls.ca_certificates)
}
#if LANG_CXX11
inline void Tls::set_ca_certificates(::std::string&& value) {
  
  ca_certificates_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.policy.v1beta1.Tls.ca_certificates)
}
#endif
inline void Tls::set_ca_certificates(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ca_certificates_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.policy.v1beta1.Tls.ca_certificates)
}
inline void Tls::set_ca_certificates(const char* value, size_t size) {
  
  ca_certificates_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.policy.v1beta1.Tls.ca_certificates)
}
inline ::std::string* Tls::mutable_ca_certificates() {
  
  // @@protoc_insertion_point(field_mutable:istio.policy.v1beta1.Tls.ca_certificates)
  return ca_certificates_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Tls::release_ca_certificates() {
  // @@protoc_insertion_point(field_release:istio.policy.v1beta1.Tls.ca_certificates)
  
  return ca_certificates_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Tls::set_allocated_ca_certificates(::std::string* ca_certificates) {
  if (ca_certificates != NULL) {
    
  } else {
    
  }
  ca_certificates_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ca_certificates);
  // @@protoc_insertion_point(field_set_allocated:istio.policy.v1beta1.Tls.ca_certificates)
}

// string token_path = 2;
inline bool Tls::has_token_path() const {
  return token_source_case() == kTokenPath;
}
inline void Tls::set_has_token_path() {
  _oneof_case_[0] = kTokenPath;
}
inline void Tls::clear_token_path() {
  if (has_token_path()) {
    token_source_.token_path_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_token_source();
  }
}
inline const ::std::string& Tls::token_path() const {
  // @@protoc_insertion_point(field_get:istio.policy.v1beta1.Tls.token_path)
  if (has_token_path()) {
    return token_source_.token_path_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void Tls::set_token_path(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:istio.policy.v1beta1.Tls.token_path)
  if (!has_token_path()) {
    clear_token_source();
    set_has_token_path();
    token_source_.token_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  token_source_.token_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.policy.v1beta1.Tls.token_path)
}
#if LANG_CXX11
inline void Tls::set_token_path(::std::string&& value) {
  // @@protoc_insertion_point(field_set:istio.policy.v1beta1.Tls.token_path)
  if (!has_token_path()) {
    clear_token_source();
    set_has_token_path();
    token_source_.token_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  token_source_.token_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.policy.v1beta1.Tls.token_path)
}
#endif
inline void Tls::set_token_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_token_path()) {
    clear_token_source();
    set_has_token_path();
    token_source_.token_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  token_source_.token_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.policy.v1beta1.Tls.token_path)
}
inline void Tls::set_token_path(const char* value, size_t size) {
  if (!has_token_path()) {
    clear_token_source();
    set_has_token_path();
    token_source_.token_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  token_source_.token_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.policy.v1beta1.Tls.token_path)
}
inline ::std::string* Tls::mutable_token_path() {
  if (!has_token_path()) {
    clear_token_source();
    set_has_token_path();
    token_source_.token_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:istio.policy.v1beta1.Tls.token_path)
  return token_source_.token_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Tls::release_token_path() {
  // @@protoc_insertion_point(field_release:istio.policy.v1beta1.Tls.token_path)
  if (has_token_path()) {
    clear_has_token_source();
    return token_source_.token_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void Tls::set_allocated_token_path(::std::string* token_path) {
  if (!has_token_path()) {
    token_source_.token_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_token_source();
  if (token_path != NULL) {
    set_has_token_path();
    token_source_.token_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        token_path);
  }
  // @@protoc_insertion_point(field_set_allocated:istio.policy.v1beta1.Tls.token_path)
}

// .istio.policy.v1beta1.OAuth oauth = 3;
inline bool Tls::has_oauth() const {
  return token_source_case() == kOauth;
}
inline void Tls::set_has_oauth() {
  _oneof_case_[0] = kOauth;
}
inline void Tls::clear_oauth() {
  if (has_oauth()) {
    delete token_source_.oauth_;
    clear_has_token_source();
  }
}
inline ::istio::policy::v1beta1::OAuth* Tls::release_oauth() {
  // @@protoc_insertion_point(field_release:istio.policy.v1beta1.Tls.oauth)
  if (has_oauth()) {
    clear_has_token_source();
      ::istio::policy::v1beta1::OAuth* temp = token_source_.oauth_;
    token_source_.oauth_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::istio::policy::v1beta1::OAuth& Tls::oauth() const {
  // @@protoc_insertion_point(field_get:istio.policy.v1beta1.Tls.oauth)
  return has_oauth()
      ? *token_source_.oauth_
      : *reinterpret_cast< ::istio::policy::v1beta1::OAuth*>(&::istio::policy::v1beta1::_OAuth_default_instance_);
}
inline ::istio::policy::v1beta1::OAuth* Tls::mutable_oauth() {
  if (!has_oauth()) {
    clear_token_source();
    set_has_oauth();
    token_source_.oauth_ = new ::istio::policy::v1beta1::OAuth;
  }
  // @@protoc_insertion_point(field_mutable:istio.policy.v1beta1.Tls.oauth)
  return token_source_.oauth_;
}

// .istio.policy.v1beta1.Tls.AuthHeader auth_header = 4;
inline bool Tls::has_auth_header() const {
  return token_type_case() == kAuthHeader;
}
inline void Tls::set_has_auth_header() {
  _oneof_case_[1] = kAuthHeader;
}
inline void Tls::clear_auth_header() {
  if (has_auth_header()) {
    token_type_.auth_header_ = 0;
    clear_has_token_type();
  }
}
inline ::istio::policy::v1beta1::Tls_AuthHeader Tls::auth_header() const {
  // @@protoc_insertion_point(field_get:istio.policy.v1beta1.Tls.auth_header)
  if (has_auth_header()) {
    return static_cast< ::istio::policy::v1beta1::Tls_AuthHeader >(token_type_.auth_header_);
  }
  return static_cast< ::istio::policy::v1beta1::Tls_AuthHeader >(0);
}
inline void Tls::set_auth_header(::istio::policy::v1beta1::Tls_AuthHeader value) {
  if (!has_auth_header()) {
    clear_token_type();
    set_has_auth_header();
  }
  token_type_.auth_header_ = value;
  // @@protoc_insertion_point(field_set:istio.policy.v1beta1.Tls.auth_header)
}

// string custom_header = 5;
inline bool Tls::has_custom_header() const {
  return token_type_case() == kCustomHeader;
}
inline void Tls::set_has_custom_header() {
  _oneof_case_[1] = kCustomHeader;
}
inline void Tls::clear_custom_header() {
  if (has_custom_header()) {
    token_type_.custom_header_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_token_type();
  }
}
inline const ::std::string& Tls::custom_header() const {
  // @@protoc_insertion_point(field_get:istio.policy.v1beta1.Tls.custom_header)
  if (has_custom_header()) {
    return token_type_.custom_header_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void Tls::set_custom_header(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:istio.policy.v1beta1.Tls.custom_header)
  if (!has_custom_header()) {
    clear_token_type();
    set_has_custom_header();
    token_type_.custom_header_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  token_type_.custom_header_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.policy.v1beta1.Tls.custom_header)
}
#if LANG_CXX11
inline void Tls::set_custom_header(::std::string&& value) {
  // @@protoc_insertion_point(field_set:istio.policy.v1beta1.Tls.custom_header)
  if (!has_custom_header()) {
    clear_token_type();
    set_has_custom_header();
    token_type_.custom_header_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  token_type_.custom_header_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.policy.v1beta1.Tls.custom_header)
}
#endif
inline void Tls::set_custom_header(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_custom_header()) {
    clear_token_type();
    set_has_custom_header();
    token_type_.custom_header_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  token_type_.custom_header_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.policy.v1beta1.Tls.custom_header)
}
inline void Tls::set_custom_header(const char* value, size_t size) {
  if (!has_custom_header()) {
    clear_token_type();
    set_has_custom_header();
    token_type_.custom_header_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  token_type_.custom_header_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.policy.v1beta1.Tls.custom_header)
}
inline ::std::string* Tls::mutable_custom_header() {
  if (!has_custom_header()) {
    clear_token_type();
    set_has_custom_header();
    token_type_.custom_header_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:istio.policy.v1beta1.Tls.custom_header)
  return token_type_.custom_header_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Tls::release_custom_header() {
  // @@protoc_insertion_point(field_release:istio.policy.v1beta1.Tls.custom_header)
  if (has_custom_header()) {
    clear_has_token_type();
    return token_type_.custom_header_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void Tls::set_allocated_custom_header(::std::string* custom_header) {
  if (!has_custom_header()) {
    token_type_.custom_header_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_token_type();
  if (custom_header != NULL) {
    set_has_custom_header();
    token_type_.custom_header_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        custom_header);
  }
  // @@protoc_insertion_point(field_set_allocated:istio.policy.v1beta1.Tls.custom_header)
}

// string server_name = 6;
inline void Tls::clear_server_name() {
  server_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Tls::server_name() const {
  // @@protoc_insertion_point(field_get:istio.policy.v1beta1.Tls.server_name)
  return server_name_.GetNoArena();
}
inline void Tls::set_server_name(const ::std::string& value) {
  
  server_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.policy.v1beta1.Tls.server_name)
}
#if LANG_CXX11
inline void Tls::set_server_name(::std::string&& value) {
  
  server_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.policy.v1beta1.Tls.server_name)
}
#endif
inline void Tls::set_server_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  server_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.policy.v1beta1.Tls.server_name)
}
inline void Tls::set_server_name(const char* value, size_t size) {
  
  server_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.policy.v1beta1.Tls.server_name)
}
inline ::std::string* Tls::mutable_server_name() {
  
  // @@protoc_insertion_point(field_mutable:istio.policy.v1beta1.Tls.server_name)
  return server_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Tls::release_server_name() {
  // @@protoc_insertion_point(field_release:istio.policy.v1beta1.Tls.server_name)
  
  return server_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Tls::set_allocated_server_name(::std::string* server_name) {
  if (server_name != NULL) {
    
  } else {
    
  }
  server_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), server_name);
  // @@protoc_insertion_point(field_set_allocated:istio.policy.v1beta1.Tls.server_name)
}

inline bool Tls::has_token_source() const {
  return token_source_case() != TOKEN_SOURCE_NOT_SET;
}
inline void Tls::clear_has_token_source() {
  _oneof_case_[0] = TOKEN_SOURCE_NOT_SET;
}
inline bool Tls::has_token_type() const {
  return token_type_case() != TOKEN_TYPE_NOT_SET;
}
inline void Tls::clear_has_token_type() {
  _oneof_case_[1] = TOKEN_TYPE_NOT_SET;
}
inline Tls::TokenSourceCase Tls::token_source_case() const {
  return Tls::TokenSourceCase(_oneof_case_[0]);
}
inline Tls::TokenTypeCase Tls::token_type_case() const {
  return Tls::TokenTypeCase(_oneof_case_[1]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// OAuth

// string client_id = 1;
inline void OAuth::clear_client_id() {
  client_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OAuth::client_id() const {
  // @@protoc_insertion_point(field_get:istio.policy.v1beta1.OAuth.client_id)
  return client_id_.GetNoArena();
}
inline void OAuth::set_client_id(const ::std::string& value) {
  
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.policy.v1beta1.OAuth.client_id)
}
#if LANG_CXX11
inline void OAuth::set_client_id(::std::string&& value) {
  
  client_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.policy.v1beta1.OAuth.client_id)
}
#endif
inline void OAuth::set_client_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.policy.v1beta1.OAuth.client_id)
}
inline void OAuth::set_client_id(const char* value, size_t size) {
  
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.policy.v1beta1.OAuth.client_id)
}
inline ::std::string* OAuth::mutable_client_id() {
  
  // @@protoc_insertion_point(field_mutable:istio.policy.v1beta1.OAuth.client_id)
  return client_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OAuth::release_client_id() {
  // @@protoc_insertion_point(field_release:istio.policy.v1beta1.OAuth.client_id)
  
  return client_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OAuth::set_allocated_client_id(::std::string* client_id) {
  if (client_id != NULL) {
    
  } else {
    
  }
  client_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_id);
  // @@protoc_insertion_point(field_set_allocated:istio.policy.v1beta1.OAuth.client_id)
}

// string client_secret = 2;
inline void OAuth::clear_client_secret() {
  client_secret_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OAuth::client_secret() const {
  // @@protoc_insertion_point(field_get:istio.policy.v1beta1.OAuth.client_secret)
  return client_secret_.GetNoArena();
}
inline void OAuth::set_client_secret(const ::std::string& value) {
  
  client_secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.policy.v1beta1.OAuth.client_secret)
}
#if LANG_CXX11
inline void OAuth::set_client_secret(::std::string&& value) {
  
  client_secret_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.policy.v1beta1.OAuth.client_secret)
}
#endif
inline void OAuth::set_client_secret(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  client_secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.policy.v1beta1.OAuth.client_secret)
}
inline void OAuth::set_client_secret(const char* value, size_t size) {
  
  client_secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.policy.v1beta1.OAuth.client_secret)
}
inline ::std::string* OAuth::mutable_client_secret() {
  
  // @@protoc_insertion_point(field_mutable:istio.policy.v1beta1.OAuth.client_secret)
  return client_secret_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OAuth::release_client_secret() {
  // @@protoc_insertion_point(field_release:istio.policy.v1beta1.OAuth.client_secret)
  
  return client_secret_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OAuth::set_allocated_client_secret(::std::string* client_secret) {
  if (client_secret != NULL) {
    
  } else {
    
  }
  client_secret_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_secret);
  // @@protoc_insertion_point(field_set_allocated:istio.policy.v1beta1.OAuth.client_secret)
}

// string token_url = 3;
inline void OAuth::clear_token_url() {
  token_url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OAuth::token_url() const {
  // @@protoc_insertion_point(field_get:istio.policy.v1beta1.OAuth.token_url)
  return token_url_.GetNoArena();
}
inline void OAuth::set_token_url(const ::std::string& value) {
  
  token_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.policy.v1beta1.OAuth.token_url)
}
#if LANG_CXX11
inline void OAuth::set_token_url(::std::string&& value) {
  
  token_url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.policy.v1beta1.OAuth.token_url)
}
#endif
inline void OAuth::set_token_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  token_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.policy.v1beta1.OAuth.token_url)
}
inline void OAuth::set_token_url(const char* value, size_t size) {
  
  token_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.policy.v1beta1.OAuth.token_url)
}
inline ::std::string* OAuth::mutable_token_url() {
  
  // @@protoc_insertion_point(field_mutable:istio.policy.v1beta1.OAuth.token_url)
  return token_url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OAuth::release_token_url() {
  // @@protoc_insertion_point(field_release:istio.policy.v1beta1.OAuth.token_url)
  
  return token_url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OAuth::set_allocated_token_url(::std::string* token_url) {
  if (token_url != NULL) {
    
  } else {
    
  }
  token_url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), token_url);
  // @@protoc_insertion_point(field_set_allocated:istio.policy.v1beta1.OAuth.token_url)
}

// repeated string scopes = 4;
inline int OAuth::scopes_size() const {
  return scopes_.size();
}
inline void OAuth::clear_scopes() {
  scopes_.Clear();
}
inline const ::std::string& OAuth::scopes(int index) const {
  // @@protoc_insertion_point(field_get:istio.policy.v1beta1.OAuth.scopes)
  return scopes_.Get(index);
}
inline ::std::string* OAuth::mutable_scopes(int index) {
  // @@protoc_insertion_point(field_mutable:istio.policy.v1beta1.OAuth.scopes)
  return scopes_.Mutable(index);
}
inline void OAuth::set_scopes(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:istio.policy.v1beta1.OAuth.scopes)
  scopes_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void OAuth::set_scopes(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:istio.policy.v1beta1.OAuth.scopes)
  scopes_.Mutable(index)->assign(std::move(value));
}
#endif
inline void OAuth::set_scopes(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  scopes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:istio.policy.v1beta1.OAuth.scopes)
}
inline void OAuth::set_scopes(int index, const char* value, size_t size) {
  scopes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:istio.policy.v1beta1.OAuth.scopes)
}
inline ::std::string* OAuth::add_scopes() {
  // @@protoc_insertion_point(field_add_mutable:istio.policy.v1beta1.OAuth.scopes)
  return scopes_.Add();
}
inline void OAuth::add_scopes(const ::std::string& value) {
  scopes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:istio.policy.v1beta1.OAuth.scopes)
}
#if LANG_CXX11
inline void OAuth::add_scopes(::std::string&& value) {
  scopes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:istio.policy.v1beta1.OAuth.scopes)
}
#endif
inline void OAuth::add_scopes(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  scopes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:istio.policy.v1beta1.OAuth.scopes)
}
inline void OAuth::add_scopes(const char* value, size_t size) {
  scopes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:istio.policy.v1beta1.OAuth.scopes)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
OAuth::scopes() const {
  // @@protoc_insertion_point(field_list:istio.policy.v1beta1.OAuth.scopes)
  return scopes_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
OAuth::mutable_scopes() {
  // @@protoc_insertion_point(field_mutable_list:istio.policy.v1beta1.OAuth.scopes)
  return &scopes_;
}

// map<string, string> endpoint_params = 5;
inline int OAuth::endpoint_params_size() const {
  return endpoint_params_.size();
}
inline void OAuth::clear_endpoint_params() {
  endpoint_params_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
OAuth::endpoint_params() const {
  // @@protoc_insertion_point(field_map:istio.policy.v1beta1.OAuth.endpoint_params)
  return endpoint_params_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
OAuth::mutable_endpoint_params() {
  // @@protoc_insertion_point(field_mutable_map:istio.policy.v1beta1.OAuth.endpoint_params)
  return endpoint_params_.MutableMap();
}

// -------------------------------------------------------------------

// Mutual

// string private_key = 1;
inline void Mutual::clear_private_key() {
  private_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Mutual::private_key() const {
  // @@protoc_insertion_point(field_get:istio.policy.v1beta1.Mutual.private_key)
  return private_key_.GetNoArena();
}
inline void Mutual::set_private_key(const ::std::string& value) {
  
  private_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.policy.v1beta1.Mutual.private_key)
}
#if LANG_CXX11
inline void Mutual::set_private_key(::std::string&& value) {
  
  private_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.policy.v1beta1.Mutual.private_key)
}
#endif
inline void Mutual::set_private_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  private_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.policy.v1beta1.Mutual.private_key)
}
inline void Mutual::set_private_key(const char* value, size_t size) {
  
  private_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.policy.v1beta1.Mutual.private_key)
}
inline ::std::string* Mutual::mutable_private_key() {
  
  // @@protoc_insertion_point(field_mutable:istio.policy.v1beta1.Mutual.private_key)
  return private_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Mutual::release_private_key() {
  // @@protoc_insertion_point(field_release:istio.policy.v1beta1.Mutual.private_key)
  
  return private_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mutual::set_allocated_private_key(::std::string* private_key) {
  if (private_key != NULL) {
    
  } else {
    
  }
  private_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), private_key);
  // @@protoc_insertion_point(field_set_allocated:istio.policy.v1beta1.Mutual.private_key)
}

// string client_certificate = 2;
inline void Mutual::clear_client_certificate() {
  client_certificate_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Mutual::client_certificate() const {
  // @@protoc_insertion_point(field_get:istio.policy.v1beta1.Mutual.client_certificate)
  return client_certificate_.GetNoArena();
}
inline void Mutual::set_client_certificate(const ::std::string& value) {
  
  client_certificate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.policy.v1beta1.Mutual.client_certificate)
}
#if LANG_CXX11
inline void Mutual::set_client_certificate(::std::string&& value) {
  
  client_certificate_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.policy.v1beta1.Mutual.client_certificate)
}
#endif
inline void Mutual::set_client_certificate(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  client_certificate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.policy.v1beta1.Mutual.client_certificate)
}
inline void Mutual::set_client_certificate(const char* value, size_t size) {
  
  client_certificate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.policy.v1beta1.Mutual.client_certificate)
}
inline ::std::string* Mutual::mutable_client_certificate() {
  
  // @@protoc_insertion_point(field_mutable:istio.policy.v1beta1.Mutual.client_certificate)
  return client_certificate_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Mutual::release_client_certificate() {
  // @@protoc_insertion_point(field_release:istio.policy.v1beta1.Mutual.client_certificate)
  
  return client_certificate_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mutual::set_allocated_client_certificate(::std::string* client_certificate) {
  if (client_certificate != NULL) {
    
  } else {
    
  }
  client_certificate_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_certificate);
  // @@protoc_insertion_point(field_set_allocated:istio.policy.v1beta1.Mutual.client_certificate)
}

// string ca_certificates = 3;
inline void Mutual::clear_ca_certificates() {
  ca_certificates_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Mutual::ca_certificates() const {
  // @@protoc_insertion_point(field_get:istio.policy.v1beta1.Mutual.ca_certificates)
  return ca_certificates_.GetNoArena();
}
inline void Mutual::set_ca_certificates(const ::std::string& value) {
  
  ca_certificates_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.policy.v1beta1.Mutual.ca_certificates)
}
#if LANG_CXX11
inline void Mutual::set_ca_certificates(::std::string&& value) {
  
  ca_certificates_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.policy.v1beta1.Mutual.ca_certificates)
}
#endif
inline void Mutual::set_ca_certificates(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ca_certificates_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.policy.v1beta1.Mutual.ca_certificates)
}
inline void Mutual::set_ca_certificates(const char* value, size_t size) {
  
  ca_certificates_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.policy.v1beta1.Mutual.ca_certificates)
}
inline ::std::string* Mutual::mutable_ca_certificates() {
  
  // @@protoc_insertion_point(field_mutable:istio.policy.v1beta1.Mutual.ca_certificates)
  return ca_certificates_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Mutual::release_ca_certificates() {
  // @@protoc_insertion_point(field_release:istio.policy.v1beta1.Mutual.ca_certificates)
  
  return ca_certificates_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mutual::set_allocated_ca_certificates(::std::string* ca_certificates) {
  if (ca_certificates != NULL) {
    
  } else {
    
  }
  ca_certificates_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ca_certificates);
  // @@protoc_insertion_point(field_set_allocated:istio.policy.v1beta1.Mutual.ca_certificates)
}

// string server_name = 4;
inline void Mutual::clear_server_name() {
  server_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Mutual::server_name() const {
  // @@protoc_insertion_point(field_get:istio.policy.v1beta1.Mutual.server_name)
  return server_name_.GetNoArena();
}
inline void Mutual::set_server_name(const ::std::string& value) {
  
  server_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:istio.policy.v1beta1.Mutual.server_name)
}
#if LANG_CXX11
inline void Mutual::set_server_name(::std::string&& value) {
  
  server_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:istio.policy.v1beta1.Mutual.server_name)
}
#endif
inline void Mutual::set_server_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  server_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:istio.policy.v1beta1.Mutual.server_name)
}
inline void Mutual::set_server_name(const char* value, size_t size) {
  
  server_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:istio.policy.v1beta1.Mutual.server_name)
}
inline ::std::string* Mutual::mutable_server_name() {
  
  // @@protoc_insertion_point(field_mutable:istio.policy.v1beta1.Mutual.server_name)
  return server_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Mutual::release_server_name() {
  // @@protoc_insertion_point(field_release:istio.policy.v1beta1.Mutual.server_name)
  
  return server_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mutual::set_allocated_server_name(::std::string* server_name) {
  if (server_name != NULL) {
    
  } else {
    
  }
  server_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), server_name);
  // @@protoc_insertion_point(field_set_allocated:istio.policy.v1beta1.Mutual.server_name)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1beta1
}  // namespace policy
}  // namespace istio

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::istio::policy::v1beta1::Rule_HeaderOperationTemplate_Operation> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::istio::policy::v1beta1::Rule_HeaderOperationTemplate_Operation>() {
  return ::istio::policy::v1beta1::Rule_HeaderOperationTemplate_Operation_descriptor();
}
template <> struct is_proto_enum< ::istio::policy::v1beta1::FractionalPercent_DenominatorType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::istio::policy::v1beta1::FractionalPercent_DenominatorType>() {
  return ::istio::policy::v1beta1::FractionalPercent_DenominatorType_descriptor();
}
template <> struct is_proto_enum< ::istio::policy::v1beta1::Tls_AuthHeader> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::istio::policy::v1beta1::Tls_AuthHeader>() {
  return ::istio::policy::v1beta1::Tls_AuthHeader_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_policy_2fv1beta1_2fcfg_2eproto__INCLUDED
